/*
 * DNS Configuration API
 * The DNS application is a BloxOne DDI service that provides cloud-based DNS configuration with on-prem host serving DNS protocol. It is part of the full-featured BloxOne DDI solution that enables customers the ability to deploy large numbers of protocol servers in the delivery of DNS and DHCP throughout their enterprise network.   
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ConfigACLItem;
import org.openapitools.client.model.ConfigDNSSECValidateException;
import org.openapitools.client.model.ConfigDisplayView;
import org.openapitools.client.model.ConfigECSZone;
import org.openapitools.client.model.ConfigFTCConfig;
import org.openapitools.client.model.ConfigForwarder;
import org.openapitools.client.model.ConfigKerberosKey;
import org.openapitools.client.model.ConfigLoggingConfig;
import org.openapitools.client.model.ConfigRootNS;
import org.openapitools.client.model.ConfigServerInheritance;
import org.openapitools.client.model.ConfigSortListItem;
import org.openapitools.client.model.ConfigTrustAnchor;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A DNS Config Profile (_dns/server_) is a named configuration for specified list of hosts.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:28.384903+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class ConfigServer {
  public static final String SERIALIZED_NAME_ADD_EDNS_OPTION_IN_OUTGOING_QUERY = "add_edns_option_in_outgoing_query";
  @SerializedName(SERIALIZED_NAME_ADD_EDNS_OPTION_IN_OUTGOING_QUERY)
  @javax.annotation.Nullable
  private Boolean addEdnsOptionInOutgoingQuery;

  public static final String SERIALIZED_NAME_AUTO_SORT_VIEWS = "auto_sort_views";
  @SerializedName(SERIALIZED_NAME_AUTO_SORT_VIEWS)
  @javax.annotation.Nullable
  private Boolean autoSortViews;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  @javax.annotation.Nullable
  private String comment;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_CUSTOM_ROOT_NS = "custom_root_ns";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ROOT_NS)
  @javax.annotation.Nullable
  private List<ConfigRootNS> customRootNs = new ArrayList<>();

  public static final String SERIALIZED_NAME_CUSTOM_ROOT_NS_ENABLED = "custom_root_ns_enabled";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ROOT_NS_ENABLED)
  @javax.annotation.Nullable
  private Boolean customRootNsEnabled;

  public static final String SERIALIZED_NAME_DNSSEC_ENABLE_VALIDATION = "dnssec_enable_validation";
  @SerializedName(SERIALIZED_NAME_DNSSEC_ENABLE_VALIDATION)
  @javax.annotation.Nullable
  private Boolean dnssecEnableValidation;

  public static final String SERIALIZED_NAME_DNSSEC_ENABLED = "dnssec_enabled";
  @SerializedName(SERIALIZED_NAME_DNSSEC_ENABLED)
  @javax.annotation.Nullable
  private Boolean dnssecEnabled;

  public static final String SERIALIZED_NAME_DNSSEC_ROOT_KEYS = "dnssec_root_keys";
  @SerializedName(SERIALIZED_NAME_DNSSEC_ROOT_KEYS)
  @javax.annotation.Nullable
  private List<ConfigTrustAnchor> dnssecRootKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_DNSSEC_TRUST_ANCHORS = "dnssec_trust_anchors";
  @SerializedName(SERIALIZED_NAME_DNSSEC_TRUST_ANCHORS)
  @javax.annotation.Nullable
  private List<ConfigTrustAnchor> dnssecTrustAnchors = new ArrayList<>();

  public static final String SERIALIZED_NAME_DNSSEC_VALIDATE_EXCEPTIONS = "dnssec_validate_exceptions";
  @SerializedName(SERIALIZED_NAME_DNSSEC_VALIDATE_EXCEPTIONS)
  @javax.annotation.Nullable
  private List<ConfigDNSSECValidateException> dnssecValidateExceptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DNSSEC_VALIDATE_EXPIRY = "dnssec_validate_expiry";
  @SerializedName(SERIALIZED_NAME_DNSSEC_VALIDATE_EXPIRY)
  @javax.annotation.Nullable
  private Boolean dnssecValidateExpiry;

  public static final String SERIALIZED_NAME_ECS_ENABLED = "ecs_enabled";
  @SerializedName(SERIALIZED_NAME_ECS_ENABLED)
  @javax.annotation.Nullable
  private Boolean ecsEnabled;

  public static final String SERIALIZED_NAME_ECS_FORWARDING = "ecs_forwarding";
  @SerializedName(SERIALIZED_NAME_ECS_FORWARDING)
  @javax.annotation.Nullable
  private Boolean ecsForwarding;

  public static final String SERIALIZED_NAME_ECS_PREFIX_V4 = "ecs_prefix_v4";
  @SerializedName(SERIALIZED_NAME_ECS_PREFIX_V4)
  @javax.annotation.Nullable
  private Long ecsPrefixV4;

  public static final String SERIALIZED_NAME_ECS_PREFIX_V6 = "ecs_prefix_v6";
  @SerializedName(SERIALIZED_NAME_ECS_PREFIX_V6)
  @javax.annotation.Nullable
  private Long ecsPrefixV6;

  public static final String SERIALIZED_NAME_ECS_ZONES = "ecs_zones";
  @SerializedName(SERIALIZED_NAME_ECS_ZONES)
  @javax.annotation.Nullable
  private List<ConfigECSZone> ecsZones = new ArrayList<>();

  public static final String SERIALIZED_NAME_FAULT_TOLERANT_CACHING = "fault_tolerant_caching";
  @SerializedName(SERIALIZED_NAME_FAULT_TOLERANT_CACHING)
  @javax.annotation.Nullable
  private ConfigFTCConfig faultTolerantCaching;

  public static final String SERIALIZED_NAME_FILTER_AAAA_ACL = "filter_aaaa_acl";
  @SerializedName(SERIALIZED_NAME_FILTER_AAAA_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> filterAaaaAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_FILTER_AAAA_ON_V4 = "filter_aaaa_on_v4";
  @SerializedName(SERIALIZED_NAME_FILTER_AAAA_ON_V4)
  @javax.annotation.Nullable
  private String filterAaaaOnV4;

  public static final String SERIALIZED_NAME_FORWARDERS = "forwarders";
  @SerializedName(SERIALIZED_NAME_FORWARDERS)
  @javax.annotation.Nullable
  private List<ConfigForwarder> forwarders = new ArrayList<>();

  public static final String SERIALIZED_NAME_FORWARDERS_ONLY = "forwarders_only";
  @SerializedName(SERIALIZED_NAME_FORWARDERS_ONLY)
  @javax.annotation.Nullable
  private Boolean forwardersOnly;

  public static final String SERIALIZED_NAME_GSS_TSIG_ENABLED = "gss_tsig_enabled";
  @SerializedName(SERIALIZED_NAME_GSS_TSIG_ENABLED)
  @javax.annotation.Nullable
  private Boolean gssTsigEnabled;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_INHERITANCE_SOURCES = "inheritance_sources";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_SOURCES)
  @javax.annotation.Nullable
  private ConfigServerInheritance inheritanceSources;

  public static final String SERIALIZED_NAME_KERBEROS_KEYS = "kerberos_keys";
  @SerializedName(SERIALIZED_NAME_KERBEROS_KEYS)
  @javax.annotation.Nullable
  private List<ConfigKerberosKey> kerberosKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_LAME_TTL = "lame_ttl";
  @SerializedName(SERIALIZED_NAME_LAME_TTL)
  @javax.annotation.Nullable
  private Long lameTtl;

  public static final String SERIALIZED_NAME_LOG_QUERY_RESPONSE = "log_query_response";
  @SerializedName(SERIALIZED_NAME_LOG_QUERY_RESPONSE)
  @javax.annotation.Nullable
  private Boolean logQueryResponse;

  public static final String SERIALIZED_NAME_LOGGING_CONFIGURATION = "logging_configuration";
  @SerializedName(SERIALIZED_NAME_LOGGING_CONFIGURATION)
  @javax.annotation.Nullable
  private ConfigLoggingConfig loggingConfiguration;

  public static final String SERIALIZED_NAME_MATCH_RECURSIVE_ONLY = "match_recursive_only";
  @SerializedName(SERIALIZED_NAME_MATCH_RECURSIVE_ONLY)
  @javax.annotation.Nullable
  private Boolean matchRecursiveOnly;

  public static final String SERIALIZED_NAME_MAX_CACHE_TTL = "max_cache_ttl";
  @SerializedName(SERIALIZED_NAME_MAX_CACHE_TTL)
  @javax.annotation.Nullable
  private Long maxCacheTtl;

  public static final String SERIALIZED_NAME_MAX_NEGATIVE_TTL = "max_negative_ttl";
  @SerializedName(SERIALIZED_NAME_MAX_NEGATIVE_TTL)
  @javax.annotation.Nullable
  private Long maxNegativeTtl;

  public static final String SERIALIZED_NAME_MINIMAL_RESPONSES = "minimal_responses";
  @SerializedName(SERIALIZED_NAME_MINIMAL_RESPONSES)
  @javax.annotation.Nullable
  private Boolean minimalResponses;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nonnull
  private String name;

  public static final String SERIALIZED_NAME_NOTIFY = "notify";
  @SerializedName(SERIALIZED_NAME_NOTIFY)
  @javax.annotation.Nullable
  private Boolean notify;

  public static final String SERIALIZED_NAME_QUERY_ACL = "query_acl";
  @SerializedName(SERIALIZED_NAME_QUERY_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> queryAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_QUERY_PORT = "query_port";
  @SerializedName(SERIALIZED_NAME_QUERY_PORT)
  @javax.annotation.Nullable
  private Long queryPort;

  public static final String SERIALIZED_NAME_RECURSION_ACL = "recursion_acl";
  @SerializedName(SERIALIZED_NAME_RECURSION_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> recursionAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_RECURSION_ENABLED = "recursion_enabled";
  @SerializedName(SERIALIZED_NAME_RECURSION_ENABLED)
  @javax.annotation.Nullable
  private Boolean recursionEnabled;

  public static final String SERIALIZED_NAME_RECURSIVE_CLIENTS = "recursive_clients";
  @SerializedName(SERIALIZED_NAME_RECURSIVE_CLIENTS)
  @javax.annotation.Nullable
  private Long recursiveClients;

  public static final String SERIALIZED_NAME_RESOLVER_QUERY_TIMEOUT = "resolver_query_timeout";
  @SerializedName(SERIALIZED_NAME_RESOLVER_QUERY_TIMEOUT)
  @javax.annotation.Nullable
  private Long resolverQueryTimeout;

  public static final String SERIALIZED_NAME_SECONDARY_AXFR_QUERY_LIMIT = "secondary_axfr_query_limit";
  @SerializedName(SERIALIZED_NAME_SECONDARY_AXFR_QUERY_LIMIT)
  @javax.annotation.Nullable
  private Long secondaryAxfrQueryLimit;

  public static final String SERIALIZED_NAME_SECONDARY_SOA_QUERY_LIMIT = "secondary_soa_query_limit";
  @SerializedName(SERIALIZED_NAME_SECONDARY_SOA_QUERY_LIMIT)
  @javax.annotation.Nullable
  private Long secondarySoaQueryLimit;

  public static final String SERIALIZED_NAME_SORT_LIST = "sort_list";
  @SerializedName(SERIALIZED_NAME_SORT_LIST)
  @javax.annotation.Nullable
  private List<ConfigSortListItem> sortList = new ArrayList<>();

  public static final String SERIALIZED_NAME_SYNTHESIZE_ADDRESS_RECORDS_FROM_HTTPS = "synthesize_address_records_from_https";
  @SerializedName(SERIALIZED_NAME_SYNTHESIZE_ADDRESS_RECORDS_FROM_HTTPS)
  @javax.annotation.Nullable
  private Boolean synthesizeAddressRecordsFromHttps;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  @javax.annotation.Nullable
  private Object tags;

  public static final String SERIALIZED_NAME_TRANSFER_ACL = "transfer_acl";
  @SerializedName(SERIALIZED_NAME_TRANSFER_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> transferAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_UPDATE_ACL = "update_acl";
  @SerializedName(SERIALIZED_NAME_UPDATE_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> updateAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_USE_FORWARDERS_FOR_SUBZONES = "use_forwarders_for_subzones";
  @SerializedName(SERIALIZED_NAME_USE_FORWARDERS_FOR_SUBZONES)
  @javax.annotation.Nullable
  private Boolean useForwardersForSubzones;

  public static final String SERIALIZED_NAME_USE_ROOT_FORWARDERS_FOR_LOCAL_RESOLUTION_WITH_B1TD = "use_root_forwarders_for_local_resolution_with_b1td";
  @SerializedName(SERIALIZED_NAME_USE_ROOT_FORWARDERS_FOR_LOCAL_RESOLUTION_WITH_B1TD)
  @javax.annotation.Nullable
  private Boolean useRootForwardersForLocalResolutionWithB1td;

  public static final String SERIALIZED_NAME_VIEWS = "views";
  @SerializedName(SERIALIZED_NAME_VIEWS)
  @javax.annotation.Nullable
  private List<ConfigDisplayView> views = new ArrayList<>();

  public ConfigServer() {
  }

  public ConfigServer(
     OffsetDateTime createdAt, 
     List<ConfigTrustAnchor> dnssecRootKeys, 
     String id, 
     OffsetDateTime updatedAt
  ) {
    this();
    this.createdAt = createdAt;
    this.dnssecRootKeys = dnssecRootKeys;
    this.id = id;
    this.updatedAt = updatedAt;
  }

  public ConfigServer addEdnsOptionInOutgoingQuery(@javax.annotation.Nullable Boolean addEdnsOptionInOutgoingQuery) {
    this.addEdnsOptionInOutgoingQuery = addEdnsOptionInOutgoingQuery;
    return this;
  }

  /**
   * _add_edns_option_in_outgoing_query_ adds client IP, MAC address and view name into outgoing recursive query. Defaults to _false_.
   * @return addEdnsOptionInOutgoingQuery
   */
  @javax.annotation.Nullable
  public Boolean getAddEdnsOptionInOutgoingQuery() {
    return addEdnsOptionInOutgoingQuery;
  }

  public void setAddEdnsOptionInOutgoingQuery(@javax.annotation.Nullable Boolean addEdnsOptionInOutgoingQuery) {
    this.addEdnsOptionInOutgoingQuery = addEdnsOptionInOutgoingQuery;
  }


  public ConfigServer autoSortViews(@javax.annotation.Nullable Boolean autoSortViews) {
    this.autoSortViews = autoSortViews;
    return this;
  }

  /**
   * Optional. Controls manual/automatic views ordering.  Defaults to _true_.
   * @return autoSortViews
   */
  @javax.annotation.Nullable
  public Boolean getAutoSortViews() {
    return autoSortViews;
  }

  public void setAutoSortViews(@javax.annotation.Nullable Boolean autoSortViews) {
    this.autoSortViews = autoSortViews;
  }


  public ConfigServer comment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * Optional. Comment for configuration.
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
  }


  /**
   * Time when the object has been created.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  public ConfigServer customRootNs(@javax.annotation.Nullable List<ConfigRootNS> customRootNs) {
    this.customRootNs = customRootNs;
    return this;
  }

  public ConfigServer addCustomRootNsItem(ConfigRootNS customRootNsItem) {
    if (this.customRootNs == null) {
      this.customRootNs = new ArrayList<>();
    }
    this.customRootNs.add(customRootNsItem);
    return this;
  }

  /**
   * Optional. List of custom root nameservers. The order does not matter.  Error if empty while _custom_root_ns_enabled_ is _true_. Error if there are duplicate items in the list.  Defaults to empty.
   * @return customRootNs
   */
  @javax.annotation.Nullable
  public List<ConfigRootNS> getCustomRootNs() {
    return customRootNs;
  }

  public void setCustomRootNs(@javax.annotation.Nullable List<ConfigRootNS> customRootNs) {
    this.customRootNs = customRootNs;
  }


  public ConfigServer customRootNsEnabled(@javax.annotation.Nullable Boolean customRootNsEnabled) {
    this.customRootNsEnabled = customRootNsEnabled;
    return this;
  }

  /**
   * Optional. _true_ to use custom root nameservers instead of the default ones.  The _custom_root_ns_ is validated when enabled.  Defaults to _false_.
   * @return customRootNsEnabled
   */
  @javax.annotation.Nullable
  public Boolean getCustomRootNsEnabled() {
    return customRootNsEnabled;
  }

  public void setCustomRootNsEnabled(@javax.annotation.Nullable Boolean customRootNsEnabled) {
    this.customRootNsEnabled = customRootNsEnabled;
  }


  public ConfigServer dnssecEnableValidation(@javax.annotation.Nullable Boolean dnssecEnableValidation) {
    this.dnssecEnableValidation = dnssecEnableValidation;
    return this;
  }

  /**
   * Optional. _true_ to perform DNSSEC validation. Ignored if _dnssec_enabled_ is _false_.  Defaults to _true_.
   * @return dnssecEnableValidation
   */
  @javax.annotation.Nullable
  public Boolean getDnssecEnableValidation() {
    return dnssecEnableValidation;
  }

  public void setDnssecEnableValidation(@javax.annotation.Nullable Boolean dnssecEnableValidation) {
    this.dnssecEnableValidation = dnssecEnableValidation;
  }


  public ConfigServer dnssecEnabled(@javax.annotation.Nullable Boolean dnssecEnabled) {
    this.dnssecEnabled = dnssecEnabled;
    return this;
  }

  /**
   * Optional. Master toggle for all DNSSEC processing. Other _dnssec_*_ configuration is unused if this is disabled.  Defaults to _true_.
   * @return dnssecEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDnssecEnabled() {
    return dnssecEnabled;
  }

  public void setDnssecEnabled(@javax.annotation.Nullable Boolean dnssecEnabled) {
    this.dnssecEnabled = dnssecEnabled;
  }


  /**
   * DNSSEC root keys. The root keys are not configurable.  A default list is provided by cloud management and included here for config generation.
   * @return dnssecRootKeys
   */
  @javax.annotation.Nullable
  public List<ConfigTrustAnchor> getDnssecRootKeys() {
    return dnssecRootKeys;
  }



  public ConfigServer dnssecTrustAnchors(@javax.annotation.Nullable List<ConfigTrustAnchor> dnssecTrustAnchors) {
    this.dnssecTrustAnchors = dnssecTrustAnchors;
    return this;
  }

  public ConfigServer addDnssecTrustAnchorsItem(ConfigTrustAnchor dnssecTrustAnchorsItem) {
    if (this.dnssecTrustAnchors == null) {
      this.dnssecTrustAnchors = new ArrayList<>();
    }
    this.dnssecTrustAnchors.add(dnssecTrustAnchorsItem);
    return this;
  }

  /**
   * Optional. DNSSEC trust anchors.  Error if there are list items with duplicate (_zone_, _sep_, _algorithm_) combinations.  Defaults to empty.
   * @return dnssecTrustAnchors
   */
  @javax.annotation.Nullable
  public List<ConfigTrustAnchor> getDnssecTrustAnchors() {
    return dnssecTrustAnchors;
  }

  public void setDnssecTrustAnchors(@javax.annotation.Nullable List<ConfigTrustAnchor> dnssecTrustAnchors) {
    this.dnssecTrustAnchors = dnssecTrustAnchors;
  }


  public ConfigServer dnssecValidateExceptions(@javax.annotation.Nullable List<ConfigDNSSECValidateException> dnssecValidateExceptions) {
    this.dnssecValidateExceptions = dnssecValidateExceptions;
    return this;
  }

  public ConfigServer addDnssecValidateExceptionsItem(ConfigDNSSECValidateException dnssecValidateExceptionsItem) {
    if (this.dnssecValidateExceptions == null) {
      this.dnssecValidateExceptions = new ArrayList<>();
    }
    this.dnssecValidateExceptions.add(dnssecValidateExceptionsItem);
    return this;
  }

  /**
   * Optional. DNSSEC validate exceptions.  Error if there are duplicate exception domains (compared as a DNS name including case-insensitive comparison).  Defaults to empty.
   * @return dnssecValidateExceptions
   */
  @javax.annotation.Nullable
  public List<ConfigDNSSECValidateException> getDnssecValidateExceptions() {
    return dnssecValidateExceptions;
  }

  public void setDnssecValidateExceptions(@javax.annotation.Nullable List<ConfigDNSSECValidateException> dnssecValidateExceptions) {
    this.dnssecValidateExceptions = dnssecValidateExceptions;
  }


  public ConfigServer dnssecValidateExpiry(@javax.annotation.Nullable Boolean dnssecValidateExpiry) {
    this.dnssecValidateExpiry = dnssecValidateExpiry;
    return this;
  }

  /**
   * Optional. _true_ to reject expired DNSSEC keys. Ignored if either _dnssec_enabled_ or _dnssec_enable_validation_ is _false_.  Defaults to _true_.
   * @return dnssecValidateExpiry
   */
  @javax.annotation.Nullable
  public Boolean getDnssecValidateExpiry() {
    return dnssecValidateExpiry;
  }

  public void setDnssecValidateExpiry(@javax.annotation.Nullable Boolean dnssecValidateExpiry) {
    this.dnssecValidateExpiry = dnssecValidateExpiry;
  }


  public ConfigServer ecsEnabled(@javax.annotation.Nullable Boolean ecsEnabled) {
    this.ecsEnabled = ecsEnabled;
    return this;
  }

  /**
   * Optional. _true_ to enable EDNS client subnet for recursive queries. Other _ecs_*_ fields are ignored if this field is not enabled.  Defaults to _false_.
   * @return ecsEnabled
   */
  @javax.annotation.Nullable
  public Boolean getEcsEnabled() {
    return ecsEnabled;
  }

  public void setEcsEnabled(@javax.annotation.Nullable Boolean ecsEnabled) {
    this.ecsEnabled = ecsEnabled;
  }


  public ConfigServer ecsForwarding(@javax.annotation.Nullable Boolean ecsForwarding) {
    this.ecsForwarding = ecsForwarding;
    return this;
  }

  /**
   * Optional. _true_ to enable ECS options in outbound queries. This functionality has additional overhead so it is disabled by default.  Defaults to _false_.
   * @return ecsForwarding
   */
  @javax.annotation.Nullable
  public Boolean getEcsForwarding() {
    return ecsForwarding;
  }

  public void setEcsForwarding(@javax.annotation.Nullable Boolean ecsForwarding) {
    this.ecsForwarding = ecsForwarding;
  }


  public ConfigServer ecsPrefixV4(@javax.annotation.Nullable Long ecsPrefixV4) {
    this.ecsPrefixV4 = ecsPrefixV4;
    return this;
  }

  /**
   * Optional. Maximum scope length for v4 ECS.  Unsigned integer, min 1 max 24  Defaults to 24.
   * @return ecsPrefixV4
   */
  @javax.annotation.Nullable
  public Long getEcsPrefixV4() {
    return ecsPrefixV4;
  }

  public void setEcsPrefixV4(@javax.annotation.Nullable Long ecsPrefixV4) {
    this.ecsPrefixV4 = ecsPrefixV4;
  }


  public ConfigServer ecsPrefixV6(@javax.annotation.Nullable Long ecsPrefixV6) {
    this.ecsPrefixV6 = ecsPrefixV6;
    return this;
  }

  /**
   * Optional. Maximum scope length for v6 ECS.  Unsigned integer, min 1 max 56  Defaults to 56.
   * @return ecsPrefixV6
   */
  @javax.annotation.Nullable
  public Long getEcsPrefixV6() {
    return ecsPrefixV6;
  }

  public void setEcsPrefixV6(@javax.annotation.Nullable Long ecsPrefixV6) {
    this.ecsPrefixV6 = ecsPrefixV6;
  }


  public ConfigServer ecsZones(@javax.annotation.Nullable List<ConfigECSZone> ecsZones) {
    this.ecsZones = ecsZones;
    return this;
  }

  public ConfigServer addEcsZonesItem(ConfigECSZone ecsZonesItem) {
    if (this.ecsZones == null) {
      this.ecsZones = new ArrayList<>();
    }
    this.ecsZones.add(ecsZonesItem);
    return this;
  }

  /**
   * Optional. List of zones where ECS queries may be sent.  Error if empty while _ecs_enabled_ is _true_. Error if there are duplicate FQDNs in the list.  Defaults to empty.
   * @return ecsZones
   */
  @javax.annotation.Nullable
  public List<ConfigECSZone> getEcsZones() {
    return ecsZones;
  }

  public void setEcsZones(@javax.annotation.Nullable List<ConfigECSZone> ecsZones) {
    this.ecsZones = ecsZones;
  }


  public ConfigServer faultTolerantCaching(@javax.annotation.Nullable ConfigFTCConfig faultTolerantCaching) {
    this.faultTolerantCaching = faultTolerantCaching;
    return this;
  }

  /**
   * Get faultTolerantCaching
   * @return faultTolerantCaching
   */
  @javax.annotation.Nullable
  public ConfigFTCConfig getFaultTolerantCaching() {
    return faultTolerantCaching;
  }

  public void setFaultTolerantCaching(@javax.annotation.Nullable ConfigFTCConfig faultTolerantCaching) {
    this.faultTolerantCaching = faultTolerantCaching;
  }


  public ConfigServer filterAaaaAcl(@javax.annotation.Nullable List<ConfigACLItem> filterAaaaAcl) {
    this.filterAaaaAcl = filterAaaaAcl;
    return this;
  }

  public ConfigServer addFilterAaaaAclItem(ConfigACLItem filterAaaaAclItem) {
    if (this.filterAaaaAcl == null) {
      this.filterAaaaAcl = new ArrayList<>();
    }
    this.filterAaaaAcl.add(filterAaaaAclItem);
    return this;
  }

  /**
   * Optional. Specifies a list of client addresses for which AAAA filtering is to be applied.  Defaults to _empty_.
   * @return filterAaaaAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getFilterAaaaAcl() {
    return filterAaaaAcl;
  }

  public void setFilterAaaaAcl(@javax.annotation.Nullable List<ConfigACLItem> filterAaaaAcl) {
    this.filterAaaaAcl = filterAaaaAcl;
  }


  public ConfigServer filterAaaaOnV4(@javax.annotation.Nullable String filterAaaaOnV4) {
    this.filterAaaaOnV4 = filterAaaaOnV4;
    return this;
  }

  /**
   * _filter_aaaa_on_v4_ allows named to omit some IPv6 addresses when responding to IPv4 clients.  Allowed values: * _yes_, * _no_, * _break_dnssec_.  Defaults to _no_
   * @return filterAaaaOnV4
   */
  @javax.annotation.Nullable
  public String getFilterAaaaOnV4() {
    return filterAaaaOnV4;
  }

  public void setFilterAaaaOnV4(@javax.annotation.Nullable String filterAaaaOnV4) {
    this.filterAaaaOnV4 = filterAaaaOnV4;
  }


  public ConfigServer forwarders(@javax.annotation.Nullable List<ConfigForwarder> forwarders) {
    this.forwarders = forwarders;
    return this;
  }

  public ConfigServer addForwardersItem(ConfigForwarder forwardersItem) {
    if (this.forwarders == null) {
      this.forwarders = new ArrayList<>();
    }
    this.forwarders.add(forwardersItem);
    return this;
  }

  /**
   * Optional. List of forwarders.  Error if empty while _forwarders_only_ or _use_root_forwarders_for_local_resolution_with_b1td_ is _true_. Error if there are items in the list with duplicate addresses.  Defaults to empty.
   * @return forwarders
   */
  @javax.annotation.Nullable
  public List<ConfigForwarder> getForwarders() {
    return forwarders;
  }

  public void setForwarders(@javax.annotation.Nullable List<ConfigForwarder> forwarders) {
    this.forwarders = forwarders;
  }


  public ConfigServer forwardersOnly(@javax.annotation.Nullable Boolean forwardersOnly) {
    this.forwardersOnly = forwardersOnly;
    return this;
  }

  /**
   * Optional. _true_ to only forward.  Defaults to _false_.
   * @return forwardersOnly
   */
  @javax.annotation.Nullable
  public Boolean getForwardersOnly() {
    return forwardersOnly;
  }

  public void setForwardersOnly(@javax.annotation.Nullable Boolean forwardersOnly) {
    this.forwardersOnly = forwardersOnly;
  }


  public ConfigServer gssTsigEnabled(@javax.annotation.Nullable Boolean gssTsigEnabled) {
    this.gssTsigEnabled = gssTsigEnabled;
    return this;
  }

  /**
   * _gss_tsig_enabled_ enables/disables GSS-TSIG signed dynamic updates.  Defaults to _false_.
   * @return gssTsigEnabled
   */
  @javax.annotation.Nullable
  public Boolean getGssTsigEnabled() {
    return gssTsigEnabled;
  }

  public void setGssTsigEnabled(@javax.annotation.Nullable Boolean gssTsigEnabled) {
    this.gssTsigEnabled = gssTsigEnabled;
  }


  /**
   * The resource identifier.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public ConfigServer inheritanceSources(@javax.annotation.Nullable ConfigServerInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
    return this;
  }

  /**
   * Get inheritanceSources
   * @return inheritanceSources
   */
  @javax.annotation.Nullable
  public ConfigServerInheritance getInheritanceSources() {
    return inheritanceSources;
  }

  public void setInheritanceSources(@javax.annotation.Nullable ConfigServerInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
  }


  public ConfigServer kerberosKeys(@javax.annotation.Nullable List<ConfigKerberosKey> kerberosKeys) {
    this.kerberosKeys = kerberosKeys;
    return this;
  }

  public ConfigServer addKerberosKeysItem(ConfigKerberosKey kerberosKeysItem) {
    if (this.kerberosKeys == null) {
      this.kerberosKeys = new ArrayList<>();
    }
    this.kerberosKeys.add(kerberosKeysItem);
    return this;
  }

  /**
   * _kerberos_keys_ contains a list of keys for GSS-TSIG signed dynamic updates.  Defaults to empty.
   * @return kerberosKeys
   */
  @javax.annotation.Nullable
  public List<ConfigKerberosKey> getKerberosKeys() {
    return kerberosKeys;
  }

  public void setKerberosKeys(@javax.annotation.Nullable List<ConfigKerberosKey> kerberosKeys) {
    this.kerberosKeys = kerberosKeys;
  }


  public ConfigServer lameTtl(@javax.annotation.Nullable Long lameTtl) {
    this.lameTtl = lameTtl;
    return this;
  }

  /**
   * Optional. Unused in the current on-prem DNS server implementation.  Unsigned integer, min 0 max 3600 (1h).  Defaults to 600.
   * @return lameTtl
   */
  @javax.annotation.Nullable
  public Long getLameTtl() {
    return lameTtl;
  }

  public void setLameTtl(@javax.annotation.Nullable Long lameTtl) {
    this.lameTtl = lameTtl;
  }


  public ConfigServer logQueryResponse(@javax.annotation.Nullable Boolean logQueryResponse) {
    this.logQueryResponse = logQueryResponse;
    return this;
  }

  /**
   * Optional. Control DNS query/response logging functionality.  Defaults to _true_.
   * @return logQueryResponse
   */
  @javax.annotation.Nullable
  public Boolean getLogQueryResponse() {
    return logQueryResponse;
  }

  public void setLogQueryResponse(@javax.annotation.Nullable Boolean logQueryResponse) {
    this.logQueryResponse = logQueryResponse;
  }


  public ConfigServer loggingConfiguration(@javax.annotation.Nullable ConfigLoggingConfig loggingConfiguration) {
    this.loggingConfiguration = loggingConfiguration;
    return this;
  }

  /**
   * Get loggingConfiguration
   * @return loggingConfiguration
   */
  @javax.annotation.Nullable
  public ConfigLoggingConfig getLoggingConfiguration() {
    return loggingConfiguration;
  }

  public void setLoggingConfiguration(@javax.annotation.Nullable ConfigLoggingConfig loggingConfiguration) {
    this.loggingConfiguration = loggingConfiguration;
  }


  public ConfigServer matchRecursiveOnly(@javax.annotation.Nullable Boolean matchRecursiveOnly) {
    this.matchRecursiveOnly = matchRecursiveOnly;
    return this;
  }

  /**
   * Optional. If _true_ only recursive queries from matching clients access the view.  Defaults to _false_.
   * @return matchRecursiveOnly
   */
  @javax.annotation.Nullable
  public Boolean getMatchRecursiveOnly() {
    return matchRecursiveOnly;
  }

  public void setMatchRecursiveOnly(@javax.annotation.Nullable Boolean matchRecursiveOnly) {
    this.matchRecursiveOnly = matchRecursiveOnly;
  }


  public ConfigServer maxCacheTtl(@javax.annotation.Nullable Long maxCacheTtl) {
    this.maxCacheTtl = maxCacheTtl;
    return this;
  }

  /**
   * Optional. Seconds to cache positive responses.  Unsigned integer, min 1 max 604800 (7d).  Defaults to 604800 (7d).
   * @return maxCacheTtl
   */
  @javax.annotation.Nullable
  public Long getMaxCacheTtl() {
    return maxCacheTtl;
  }

  public void setMaxCacheTtl(@javax.annotation.Nullable Long maxCacheTtl) {
    this.maxCacheTtl = maxCacheTtl;
  }


  public ConfigServer maxNegativeTtl(@javax.annotation.Nullable Long maxNegativeTtl) {
    this.maxNegativeTtl = maxNegativeTtl;
    return this;
  }

  /**
   * Optional. Seconds to cache negative responses.  Unsigned integer, min 1 max 604800 (7d).  Defaults to 10800 (3h).
   * @return maxNegativeTtl
   */
  @javax.annotation.Nullable
  public Long getMaxNegativeTtl() {
    return maxNegativeTtl;
  }

  public void setMaxNegativeTtl(@javax.annotation.Nullable Long maxNegativeTtl) {
    this.maxNegativeTtl = maxNegativeTtl;
  }


  public ConfigServer minimalResponses(@javax.annotation.Nullable Boolean minimalResponses) {
    this.minimalResponses = minimalResponses;
    return this;
  }

  /**
   * Optional. When enabled, the DNS server will only add records to the authority and additional data sections when they are required.  Defaults to _false_.
   * @return minimalResponses
   */
  @javax.annotation.Nullable
  public Boolean getMinimalResponses() {
    return minimalResponses;
  }

  public void setMinimalResponses(@javax.annotation.Nullable Boolean minimalResponses) {
    this.minimalResponses = minimalResponses;
  }


  public ConfigServer name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of configuration.
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public ConfigServer notify(@javax.annotation.Nullable Boolean notify) {
    this.notify = notify;
    return this;
  }

  /**
   * _notify_ all external secondary DNS servers.  Defaults to _false_.
   * @return notify
   */
  @javax.annotation.Nullable
  public Boolean getNotify() {
    return notify;
  }

  public void setNotify(@javax.annotation.Nullable Boolean notify) {
    this.notify = notify;
  }


  public ConfigServer queryAcl(@javax.annotation.Nullable List<ConfigACLItem> queryAcl) {
    this.queryAcl = queryAcl;
    return this;
  }

  public ConfigServer addQueryAclItem(ConfigACLItem queryAclItem) {
    if (this.queryAcl == null) {
      this.queryAcl = new ArrayList<>();
    }
    this.queryAcl.add(queryAclItem);
    return this;
  }

  /**
   * Optional. Clients must match this ACL to make authoritative queries. Also used for recursive queries if that ACL is unset.  Defaults to empty.
   * @return queryAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getQueryAcl() {
    return queryAcl;
  }

  public void setQueryAcl(@javax.annotation.Nullable List<ConfigACLItem> queryAcl) {
    this.queryAcl = queryAcl;
  }


  public ConfigServer queryPort(@javax.annotation.Nullable Long queryPort) {
    this.queryPort = queryPort;
    return this;
  }

  /**
   * Optional. Source port for outbound DNS queries. When set to 0 the port is unspecified and the implementation may randomize it using any available ports.  Defaults to 0.
   * @return queryPort
   */
  @javax.annotation.Nullable
  public Long getQueryPort() {
    return queryPort;
  }

  public void setQueryPort(@javax.annotation.Nullable Long queryPort) {
    this.queryPort = queryPort;
  }


  public ConfigServer recursionAcl(@javax.annotation.Nullable List<ConfigACLItem> recursionAcl) {
    this.recursionAcl = recursionAcl;
    return this;
  }

  public ConfigServer addRecursionAclItem(ConfigACLItem recursionAclItem) {
    if (this.recursionAcl == null) {
      this.recursionAcl = new ArrayList<>();
    }
    this.recursionAcl.add(recursionAclItem);
    return this;
  }

  /**
   * Optional. Clients must match this ACL to make recursive queries. If this ACL is empty, then the _query_acl_ field will be used instead.  Defaults to empty.
   * @return recursionAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getRecursionAcl() {
    return recursionAcl;
  }

  public void setRecursionAcl(@javax.annotation.Nullable List<ConfigACLItem> recursionAcl) {
    this.recursionAcl = recursionAcl;
  }


  public ConfigServer recursionEnabled(@javax.annotation.Nullable Boolean recursionEnabled) {
    this.recursionEnabled = recursionEnabled;
    return this;
  }

  /**
   * Optional. _true_ to allow recursive DNS queries.  Defaults to _true_.
   * @return recursionEnabled
   */
  @javax.annotation.Nullable
  public Boolean getRecursionEnabled() {
    return recursionEnabled;
  }

  public void setRecursionEnabled(@javax.annotation.Nullable Boolean recursionEnabled) {
    this.recursionEnabled = recursionEnabled;
  }


  public ConfigServer recursiveClients(@javax.annotation.Nullable Long recursiveClients) {
    this.recursiveClients = recursiveClients;
    return this;
  }

  /**
   * Optional. Defines the number of simultaneous recursive lookups the server will perform on behalf of its clients.  Defaults to 1000.
   * @return recursiveClients
   */
  @javax.annotation.Nullable
  public Long getRecursiveClients() {
    return recursiveClients;
  }

  public void setRecursiveClients(@javax.annotation.Nullable Long recursiveClients) {
    this.recursiveClients = recursiveClients;
  }


  public ConfigServer resolverQueryTimeout(@javax.annotation.Nullable Long resolverQueryTimeout) {
    this.resolverQueryTimeout = resolverQueryTimeout;
    return this;
  }

  /**
   * Optional. Seconds before a recursive query times out.  Unsigned integer, min 10 max 30.  Defaults to 10.
   * @return resolverQueryTimeout
   */
  @javax.annotation.Nullable
  public Long getResolverQueryTimeout() {
    return resolverQueryTimeout;
  }

  public void setResolverQueryTimeout(@javax.annotation.Nullable Long resolverQueryTimeout) {
    this.resolverQueryTimeout = resolverQueryTimeout;
  }


  public ConfigServer secondaryAxfrQueryLimit(@javax.annotation.Nullable Long secondaryAxfrQueryLimit) {
    this.secondaryAxfrQueryLimit = secondaryAxfrQueryLimit;
    return this;
  }

  /**
   * Optional. Maximum concurrent inbound AXFRs. When set to 0 a host-dependent default will be used.  Defaults to 0.
   * @return secondaryAxfrQueryLimit
   */
  @javax.annotation.Nullable
  public Long getSecondaryAxfrQueryLimit() {
    return secondaryAxfrQueryLimit;
  }

  public void setSecondaryAxfrQueryLimit(@javax.annotation.Nullable Long secondaryAxfrQueryLimit) {
    this.secondaryAxfrQueryLimit = secondaryAxfrQueryLimit;
  }


  public ConfigServer secondarySoaQueryLimit(@javax.annotation.Nullable Long secondarySoaQueryLimit) {
    this.secondarySoaQueryLimit = secondarySoaQueryLimit;
    return this;
  }

  /**
   * Optional. Maximum concurrent outbound SOA queries. When set to 0 a host-dependent default will be used.  Defaults to 0.
   * @return secondarySoaQueryLimit
   */
  @javax.annotation.Nullable
  public Long getSecondarySoaQueryLimit() {
    return secondarySoaQueryLimit;
  }

  public void setSecondarySoaQueryLimit(@javax.annotation.Nullable Long secondarySoaQueryLimit) {
    this.secondarySoaQueryLimit = secondarySoaQueryLimit;
  }


  public ConfigServer sortList(@javax.annotation.Nullable List<ConfigSortListItem> sortList) {
    this.sortList = sortList;
    return this;
  }

  public ConfigServer addSortListItem(ConfigSortListItem sortListItem) {
    if (this.sortList == null) {
      this.sortList = new ArrayList<>();
    }
    this.sortList.add(sortListItem);
    return this;
  }

  /**
   * Optional. Specifies a sorted network list for A/AAAA records in DNS query response.  Defaults to _empty_.
   * @return sortList
   */
  @javax.annotation.Nullable
  public List<ConfigSortListItem> getSortList() {
    return sortList;
  }

  public void setSortList(@javax.annotation.Nullable List<ConfigSortListItem> sortList) {
    this.sortList = sortList;
  }


  public ConfigServer synthesizeAddressRecordsFromHttps(@javax.annotation.Nullable Boolean synthesizeAddressRecordsFromHttps) {
    this.synthesizeAddressRecordsFromHttps = synthesizeAddressRecordsFromHttps;
    return this;
  }

  /**
   * _synthesize_address_records_from_https_ enables/disables creation of A/AAAA records from HTTPS RR Defaults to _false_.
   * @return synthesizeAddressRecordsFromHttps
   */
  @javax.annotation.Nullable
  public Boolean getSynthesizeAddressRecordsFromHttps() {
    return synthesizeAddressRecordsFromHttps;
  }

  public void setSynthesizeAddressRecordsFromHttps(@javax.annotation.Nullable Boolean synthesizeAddressRecordsFromHttps) {
    this.synthesizeAddressRecordsFromHttps = synthesizeAddressRecordsFromHttps;
  }


  public ConfigServer tags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
    return this;
  }

  /**
   * Tagging specifics.
   * @return tags
   */
  @javax.annotation.Nullable
  public Object getTags() {
    return tags;
  }

  public void setTags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
  }


  public ConfigServer transferAcl(@javax.annotation.Nullable List<ConfigACLItem> transferAcl) {
    this.transferAcl = transferAcl;
    return this;
  }

  public ConfigServer addTransferAclItem(ConfigACLItem transferAclItem) {
    if (this.transferAcl == null) {
      this.transferAcl = new ArrayList<>();
    }
    this.transferAcl.add(transferAclItem);
    return this;
  }

  /**
   * Optional. Clients must match this ACL to receive zone transfers.  Defaults to empty.
   * @return transferAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getTransferAcl() {
    return transferAcl;
  }

  public void setTransferAcl(@javax.annotation.Nullable List<ConfigACLItem> transferAcl) {
    this.transferAcl = transferAcl;
  }


  public ConfigServer updateAcl(@javax.annotation.Nullable List<ConfigACLItem> updateAcl) {
    this.updateAcl = updateAcl;
    return this;
  }

  public ConfigServer addUpdateAclItem(ConfigACLItem updateAclItem) {
    if (this.updateAcl == null) {
      this.updateAcl = new ArrayList<>();
    }
    this.updateAcl.add(updateAclItem);
    return this;
  }

  /**
   * Optional. Specifies which hosts are allowed to issue Dynamic DNS updates for authoritative zones of _primary_type_ _cloud_.  Defaults to empty.
   * @return updateAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getUpdateAcl() {
    return updateAcl;
  }

  public void setUpdateAcl(@javax.annotation.Nullable List<ConfigACLItem> updateAcl) {
    this.updateAcl = updateAcl;
  }


  /**
   * Time when the object has been updated. Equals to _created_at_ if not updated after creation.
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }



  public ConfigServer useForwardersForSubzones(@javax.annotation.Nullable Boolean useForwardersForSubzones) {
    this.useForwardersForSubzones = useForwardersForSubzones;
    return this;
  }

  /**
   * Optional. Use default forwarders to resolve queries for subzones.  Defaults to _true_.
   * @return useForwardersForSubzones
   */
  @javax.annotation.Nullable
  public Boolean getUseForwardersForSubzones() {
    return useForwardersForSubzones;
  }

  public void setUseForwardersForSubzones(@javax.annotation.Nullable Boolean useForwardersForSubzones) {
    this.useForwardersForSubzones = useForwardersForSubzones;
  }


  public ConfigServer useRootForwardersForLocalResolutionWithB1td(@javax.annotation.Nullable Boolean useRootForwardersForLocalResolutionWithB1td) {
    this.useRootForwardersForLocalResolutionWithB1td = useRootForwardersForLocalResolutionWithB1td;
    return this;
  }

  /**
   * _use_root_forwarders_for_local_resolution_with_b1td_ allows DNS recursive queries sent to root forwarders for local resolution when deployed alongside BloxOne Thread Defense. Defaults to _false_.
   * @return useRootForwardersForLocalResolutionWithB1td
   */
  @javax.annotation.Nullable
  public Boolean getUseRootForwardersForLocalResolutionWithB1td() {
    return useRootForwardersForLocalResolutionWithB1td;
  }

  public void setUseRootForwardersForLocalResolutionWithB1td(@javax.annotation.Nullable Boolean useRootForwardersForLocalResolutionWithB1td) {
    this.useRootForwardersForLocalResolutionWithB1td = useRootForwardersForLocalResolutionWithB1td;
  }


  public ConfigServer views(@javax.annotation.Nullable List<ConfigDisplayView> views) {
    this.views = views;
    return this;
  }

  public ConfigServer addViewsItem(ConfigDisplayView viewsItem) {
    if (this.views == null) {
      this.views = new ArrayList<>();
    }
    this.views.add(viewsItem);
    return this;
  }

  /**
   * Optional. Ordered list of _dns/display_view_ objects served by any of _dns/host_ assigned to a particular DNS Config Profile. Automatically determined. Allows re-ordering only.
   * @return views
   */
  @javax.annotation.Nullable
  public List<ConfigDisplayView> getViews() {
    return views;
  }

  public void setViews(@javax.annotation.Nullable List<ConfigDisplayView> views) {
    this.views = views;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConfigServer configServer = (ConfigServer) o;
    return Objects.equals(this.addEdnsOptionInOutgoingQuery, configServer.addEdnsOptionInOutgoingQuery) &&
        Objects.equals(this.autoSortViews, configServer.autoSortViews) &&
        Objects.equals(this.comment, configServer.comment) &&
        Objects.equals(this.createdAt, configServer.createdAt) &&
        Objects.equals(this.customRootNs, configServer.customRootNs) &&
        Objects.equals(this.customRootNsEnabled, configServer.customRootNsEnabled) &&
        Objects.equals(this.dnssecEnableValidation, configServer.dnssecEnableValidation) &&
        Objects.equals(this.dnssecEnabled, configServer.dnssecEnabled) &&
        Objects.equals(this.dnssecRootKeys, configServer.dnssecRootKeys) &&
        Objects.equals(this.dnssecTrustAnchors, configServer.dnssecTrustAnchors) &&
        Objects.equals(this.dnssecValidateExceptions, configServer.dnssecValidateExceptions) &&
        Objects.equals(this.dnssecValidateExpiry, configServer.dnssecValidateExpiry) &&
        Objects.equals(this.ecsEnabled, configServer.ecsEnabled) &&
        Objects.equals(this.ecsForwarding, configServer.ecsForwarding) &&
        Objects.equals(this.ecsPrefixV4, configServer.ecsPrefixV4) &&
        Objects.equals(this.ecsPrefixV6, configServer.ecsPrefixV6) &&
        Objects.equals(this.ecsZones, configServer.ecsZones) &&
        Objects.equals(this.faultTolerantCaching, configServer.faultTolerantCaching) &&
        Objects.equals(this.filterAaaaAcl, configServer.filterAaaaAcl) &&
        Objects.equals(this.filterAaaaOnV4, configServer.filterAaaaOnV4) &&
        Objects.equals(this.forwarders, configServer.forwarders) &&
        Objects.equals(this.forwardersOnly, configServer.forwardersOnly) &&
        Objects.equals(this.gssTsigEnabled, configServer.gssTsigEnabled) &&
        Objects.equals(this.id, configServer.id) &&
        Objects.equals(this.inheritanceSources, configServer.inheritanceSources) &&
        Objects.equals(this.kerberosKeys, configServer.kerberosKeys) &&
        Objects.equals(this.lameTtl, configServer.lameTtl) &&
        Objects.equals(this.logQueryResponse, configServer.logQueryResponse) &&
        Objects.equals(this.loggingConfiguration, configServer.loggingConfiguration) &&
        Objects.equals(this.matchRecursiveOnly, configServer.matchRecursiveOnly) &&
        Objects.equals(this.maxCacheTtl, configServer.maxCacheTtl) &&
        Objects.equals(this.maxNegativeTtl, configServer.maxNegativeTtl) &&
        Objects.equals(this.minimalResponses, configServer.minimalResponses) &&
        Objects.equals(this.name, configServer.name) &&
        Objects.equals(this.notify, configServer.notify) &&
        Objects.equals(this.queryAcl, configServer.queryAcl) &&
        Objects.equals(this.queryPort, configServer.queryPort) &&
        Objects.equals(this.recursionAcl, configServer.recursionAcl) &&
        Objects.equals(this.recursionEnabled, configServer.recursionEnabled) &&
        Objects.equals(this.recursiveClients, configServer.recursiveClients) &&
        Objects.equals(this.resolverQueryTimeout, configServer.resolverQueryTimeout) &&
        Objects.equals(this.secondaryAxfrQueryLimit, configServer.secondaryAxfrQueryLimit) &&
        Objects.equals(this.secondarySoaQueryLimit, configServer.secondarySoaQueryLimit) &&
        Objects.equals(this.sortList, configServer.sortList) &&
        Objects.equals(this.synthesizeAddressRecordsFromHttps, configServer.synthesizeAddressRecordsFromHttps) &&
        Objects.equals(this.tags, configServer.tags) &&
        Objects.equals(this.transferAcl, configServer.transferAcl) &&
        Objects.equals(this.updateAcl, configServer.updateAcl) &&
        Objects.equals(this.updatedAt, configServer.updatedAt) &&
        Objects.equals(this.useForwardersForSubzones, configServer.useForwardersForSubzones) &&
        Objects.equals(this.useRootForwardersForLocalResolutionWithB1td, configServer.useRootForwardersForLocalResolutionWithB1td) &&
        Objects.equals(this.views, configServer.views);
  }

  @Override
  public int hashCode() {
    return Objects.hash(addEdnsOptionInOutgoingQuery, autoSortViews, comment, createdAt, customRootNs, customRootNsEnabled, dnssecEnableValidation, dnssecEnabled, dnssecRootKeys, dnssecTrustAnchors, dnssecValidateExceptions, dnssecValidateExpiry, ecsEnabled, ecsForwarding, ecsPrefixV4, ecsPrefixV6, ecsZones, faultTolerantCaching, filterAaaaAcl, filterAaaaOnV4, forwarders, forwardersOnly, gssTsigEnabled, id, inheritanceSources, kerberosKeys, lameTtl, logQueryResponse, loggingConfiguration, matchRecursiveOnly, maxCacheTtl, maxNegativeTtl, minimalResponses, name, notify, queryAcl, queryPort, recursionAcl, recursionEnabled, recursiveClients, resolverQueryTimeout, secondaryAxfrQueryLimit, secondarySoaQueryLimit, sortList, synthesizeAddressRecordsFromHttps, tags, transferAcl, updateAcl, updatedAt, useForwardersForSubzones, useRootForwardersForLocalResolutionWithB1td, views);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConfigServer {\n");
    sb.append("    addEdnsOptionInOutgoingQuery: ").append(toIndentedString(addEdnsOptionInOutgoingQuery)).append("\n");
    sb.append("    autoSortViews: ").append(toIndentedString(autoSortViews)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    customRootNs: ").append(toIndentedString(customRootNs)).append("\n");
    sb.append("    customRootNsEnabled: ").append(toIndentedString(customRootNsEnabled)).append("\n");
    sb.append("    dnssecEnableValidation: ").append(toIndentedString(dnssecEnableValidation)).append("\n");
    sb.append("    dnssecEnabled: ").append(toIndentedString(dnssecEnabled)).append("\n");
    sb.append("    dnssecRootKeys: ").append(toIndentedString(dnssecRootKeys)).append("\n");
    sb.append("    dnssecTrustAnchors: ").append(toIndentedString(dnssecTrustAnchors)).append("\n");
    sb.append("    dnssecValidateExceptions: ").append(toIndentedString(dnssecValidateExceptions)).append("\n");
    sb.append("    dnssecValidateExpiry: ").append(toIndentedString(dnssecValidateExpiry)).append("\n");
    sb.append("    ecsEnabled: ").append(toIndentedString(ecsEnabled)).append("\n");
    sb.append("    ecsForwarding: ").append(toIndentedString(ecsForwarding)).append("\n");
    sb.append("    ecsPrefixV4: ").append(toIndentedString(ecsPrefixV4)).append("\n");
    sb.append("    ecsPrefixV6: ").append(toIndentedString(ecsPrefixV6)).append("\n");
    sb.append("    ecsZones: ").append(toIndentedString(ecsZones)).append("\n");
    sb.append("    faultTolerantCaching: ").append(toIndentedString(faultTolerantCaching)).append("\n");
    sb.append("    filterAaaaAcl: ").append(toIndentedString(filterAaaaAcl)).append("\n");
    sb.append("    filterAaaaOnV4: ").append(toIndentedString(filterAaaaOnV4)).append("\n");
    sb.append("    forwarders: ").append(toIndentedString(forwarders)).append("\n");
    sb.append("    forwardersOnly: ").append(toIndentedString(forwardersOnly)).append("\n");
    sb.append("    gssTsigEnabled: ").append(toIndentedString(gssTsigEnabled)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    inheritanceSources: ").append(toIndentedString(inheritanceSources)).append("\n");
    sb.append("    kerberosKeys: ").append(toIndentedString(kerberosKeys)).append("\n");
    sb.append("    lameTtl: ").append(toIndentedString(lameTtl)).append("\n");
    sb.append("    logQueryResponse: ").append(toIndentedString(logQueryResponse)).append("\n");
    sb.append("    loggingConfiguration: ").append(toIndentedString(loggingConfiguration)).append("\n");
    sb.append("    matchRecursiveOnly: ").append(toIndentedString(matchRecursiveOnly)).append("\n");
    sb.append("    maxCacheTtl: ").append(toIndentedString(maxCacheTtl)).append("\n");
    sb.append("    maxNegativeTtl: ").append(toIndentedString(maxNegativeTtl)).append("\n");
    sb.append("    minimalResponses: ").append(toIndentedString(minimalResponses)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    notify: ").append(toIndentedString(notify)).append("\n");
    sb.append("    queryAcl: ").append(toIndentedString(queryAcl)).append("\n");
    sb.append("    queryPort: ").append(toIndentedString(queryPort)).append("\n");
    sb.append("    recursionAcl: ").append(toIndentedString(recursionAcl)).append("\n");
    sb.append("    recursionEnabled: ").append(toIndentedString(recursionEnabled)).append("\n");
    sb.append("    recursiveClients: ").append(toIndentedString(recursiveClients)).append("\n");
    sb.append("    resolverQueryTimeout: ").append(toIndentedString(resolverQueryTimeout)).append("\n");
    sb.append("    secondaryAxfrQueryLimit: ").append(toIndentedString(secondaryAxfrQueryLimit)).append("\n");
    sb.append("    secondarySoaQueryLimit: ").append(toIndentedString(secondarySoaQueryLimit)).append("\n");
    sb.append("    sortList: ").append(toIndentedString(sortList)).append("\n");
    sb.append("    synthesizeAddressRecordsFromHttps: ").append(toIndentedString(synthesizeAddressRecordsFromHttps)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    transferAcl: ").append(toIndentedString(transferAcl)).append("\n");
    sb.append("    updateAcl: ").append(toIndentedString(updateAcl)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    useForwardersForSubzones: ").append(toIndentedString(useForwardersForSubzones)).append("\n");
    sb.append("    useRootForwardersForLocalResolutionWithB1td: ").append(toIndentedString(useRootForwardersForLocalResolutionWithB1td)).append("\n");
    sb.append("    views: ").append(toIndentedString(views)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("add_edns_option_in_outgoing_query");
    openapiFields.add("auto_sort_views");
    openapiFields.add("comment");
    openapiFields.add("created_at");
    openapiFields.add("custom_root_ns");
    openapiFields.add("custom_root_ns_enabled");
    openapiFields.add("dnssec_enable_validation");
    openapiFields.add("dnssec_enabled");
    openapiFields.add("dnssec_root_keys");
    openapiFields.add("dnssec_trust_anchors");
    openapiFields.add("dnssec_validate_exceptions");
    openapiFields.add("dnssec_validate_expiry");
    openapiFields.add("ecs_enabled");
    openapiFields.add("ecs_forwarding");
    openapiFields.add("ecs_prefix_v4");
    openapiFields.add("ecs_prefix_v6");
    openapiFields.add("ecs_zones");
    openapiFields.add("fault_tolerant_caching");
    openapiFields.add("filter_aaaa_acl");
    openapiFields.add("filter_aaaa_on_v4");
    openapiFields.add("forwarders");
    openapiFields.add("forwarders_only");
    openapiFields.add("gss_tsig_enabled");
    openapiFields.add("id");
    openapiFields.add("inheritance_sources");
    openapiFields.add("kerberos_keys");
    openapiFields.add("lame_ttl");
    openapiFields.add("log_query_response");
    openapiFields.add("logging_configuration");
    openapiFields.add("match_recursive_only");
    openapiFields.add("max_cache_ttl");
    openapiFields.add("max_negative_ttl");
    openapiFields.add("minimal_responses");
    openapiFields.add("name");
    openapiFields.add("notify");
    openapiFields.add("query_acl");
    openapiFields.add("query_port");
    openapiFields.add("recursion_acl");
    openapiFields.add("recursion_enabled");
    openapiFields.add("recursive_clients");
    openapiFields.add("resolver_query_timeout");
    openapiFields.add("secondary_axfr_query_limit");
    openapiFields.add("secondary_soa_query_limit");
    openapiFields.add("sort_list");
    openapiFields.add("synthesize_address_records_from_https");
    openapiFields.add("tags");
    openapiFields.add("transfer_acl");
    openapiFields.add("update_acl");
    openapiFields.add("updated_at");
    openapiFields.add("use_forwarders_for_subzones");
    openapiFields.add("use_root_forwarders_for_local_resolution_with_b1td");
    openapiFields.add("views");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ConfigServer
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ConfigServer.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConfigServer is not found in the empty JSON string", ConfigServer.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ConfigServer.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ConfigServer` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ConfigServer.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if (jsonObj.get("custom_root_ns") != null && !jsonObj.get("custom_root_ns").isJsonNull()) {
        JsonArray jsonArraycustomRootNs = jsonObj.getAsJsonArray("custom_root_ns");
        if (jsonArraycustomRootNs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("custom_root_ns").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `custom_root_ns` to be an array in the JSON string but got `%s`", jsonObj.get("custom_root_ns").toString()));
          }

          // validate the optional field `custom_root_ns` (array)
          for (int i = 0; i < jsonArraycustomRootNs.size(); i++) {
            ConfigRootNS.validateJsonElement(jsonArraycustomRootNs.get(i));
          };
        }
      }
      if (jsonObj.get("dnssec_root_keys") != null && !jsonObj.get("dnssec_root_keys").isJsonNull()) {
        JsonArray jsonArraydnssecRootKeys = jsonObj.getAsJsonArray("dnssec_root_keys");
        if (jsonArraydnssecRootKeys != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dnssec_root_keys").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dnssec_root_keys` to be an array in the JSON string but got `%s`", jsonObj.get("dnssec_root_keys").toString()));
          }

          // validate the optional field `dnssec_root_keys` (array)
          for (int i = 0; i < jsonArraydnssecRootKeys.size(); i++) {
            ConfigTrustAnchor.validateJsonElement(jsonArraydnssecRootKeys.get(i));
          };
        }
      }
      if (jsonObj.get("dnssec_trust_anchors") != null && !jsonObj.get("dnssec_trust_anchors").isJsonNull()) {
        JsonArray jsonArraydnssecTrustAnchors = jsonObj.getAsJsonArray("dnssec_trust_anchors");
        if (jsonArraydnssecTrustAnchors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dnssec_trust_anchors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dnssec_trust_anchors` to be an array in the JSON string but got `%s`", jsonObj.get("dnssec_trust_anchors").toString()));
          }

          // validate the optional field `dnssec_trust_anchors` (array)
          for (int i = 0; i < jsonArraydnssecTrustAnchors.size(); i++) {
            ConfigTrustAnchor.validateJsonElement(jsonArraydnssecTrustAnchors.get(i));
          };
        }
      }
      if (jsonObj.get("dnssec_validate_exceptions") != null && !jsonObj.get("dnssec_validate_exceptions").isJsonNull()) {
        JsonArray jsonArraydnssecValidateExceptions = jsonObj.getAsJsonArray("dnssec_validate_exceptions");
        if (jsonArraydnssecValidateExceptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dnssec_validate_exceptions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dnssec_validate_exceptions` to be an array in the JSON string but got `%s`", jsonObj.get("dnssec_validate_exceptions").toString()));
          }

          // validate the optional field `dnssec_validate_exceptions` (array)
          for (int i = 0; i < jsonArraydnssecValidateExceptions.size(); i++) {
            ConfigDNSSECValidateException.validateJsonElement(jsonArraydnssecValidateExceptions.get(i));
          };
        }
      }
      if (jsonObj.get("ecs_zones") != null && !jsonObj.get("ecs_zones").isJsonNull()) {
        JsonArray jsonArrayecsZones = jsonObj.getAsJsonArray("ecs_zones");
        if (jsonArrayecsZones != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ecs_zones").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ecs_zones` to be an array in the JSON string but got `%s`", jsonObj.get("ecs_zones").toString()));
          }

          // validate the optional field `ecs_zones` (array)
          for (int i = 0; i < jsonArrayecsZones.size(); i++) {
            ConfigECSZone.validateJsonElement(jsonArrayecsZones.get(i));
          };
        }
      }
      // validate the optional field `fault_tolerant_caching`
      if (jsonObj.get("fault_tolerant_caching") != null && !jsonObj.get("fault_tolerant_caching").isJsonNull()) {
        ConfigFTCConfig.validateJsonElement(jsonObj.get("fault_tolerant_caching"));
      }
      if (jsonObj.get("filter_aaaa_acl") != null && !jsonObj.get("filter_aaaa_acl").isJsonNull()) {
        JsonArray jsonArrayfilterAaaaAcl = jsonObj.getAsJsonArray("filter_aaaa_acl");
        if (jsonArrayfilterAaaaAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("filter_aaaa_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `filter_aaaa_acl` to be an array in the JSON string but got `%s`", jsonObj.get("filter_aaaa_acl").toString()));
          }

          // validate the optional field `filter_aaaa_acl` (array)
          for (int i = 0; i < jsonArrayfilterAaaaAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayfilterAaaaAcl.get(i));
          };
        }
      }
      if ((jsonObj.get("filter_aaaa_on_v4") != null && !jsonObj.get("filter_aaaa_on_v4").isJsonNull()) && !jsonObj.get("filter_aaaa_on_v4").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filter_aaaa_on_v4` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filter_aaaa_on_v4").toString()));
      }
      if (jsonObj.get("forwarders") != null && !jsonObj.get("forwarders").isJsonNull()) {
        JsonArray jsonArrayforwarders = jsonObj.getAsJsonArray("forwarders");
        if (jsonArrayforwarders != null) {
          // ensure the json data is an array
          if (!jsonObj.get("forwarders").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `forwarders` to be an array in the JSON string but got `%s`", jsonObj.get("forwarders").toString()));
          }

          // validate the optional field `forwarders` (array)
          for (int i = 0; i < jsonArrayforwarders.size(); i++) {
            ConfigForwarder.validateJsonElement(jsonArrayforwarders.get(i));
          };
        }
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `inheritance_sources`
      if (jsonObj.get("inheritance_sources") != null && !jsonObj.get("inheritance_sources").isJsonNull()) {
        ConfigServerInheritance.validateJsonElement(jsonObj.get("inheritance_sources"));
      }
      if (jsonObj.get("kerberos_keys") != null && !jsonObj.get("kerberos_keys").isJsonNull()) {
        JsonArray jsonArraykerberosKeys = jsonObj.getAsJsonArray("kerberos_keys");
        if (jsonArraykerberosKeys != null) {
          // ensure the json data is an array
          if (!jsonObj.get("kerberos_keys").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `kerberos_keys` to be an array in the JSON string but got `%s`", jsonObj.get("kerberos_keys").toString()));
          }

          // validate the optional field `kerberos_keys` (array)
          for (int i = 0; i < jsonArraykerberosKeys.size(); i++) {
            ConfigKerberosKey.validateJsonElement(jsonArraykerberosKeys.get(i));
          };
        }
      }
      // validate the optional field `logging_configuration`
      if (jsonObj.get("logging_configuration") != null && !jsonObj.get("logging_configuration").isJsonNull()) {
        ConfigLoggingConfig.validateJsonElement(jsonObj.get("logging_configuration"));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (jsonObj.get("query_acl") != null && !jsonObj.get("query_acl").isJsonNull()) {
        JsonArray jsonArrayqueryAcl = jsonObj.getAsJsonArray("query_acl");
        if (jsonArrayqueryAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("query_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `query_acl` to be an array in the JSON string but got `%s`", jsonObj.get("query_acl").toString()));
          }

          // validate the optional field `query_acl` (array)
          for (int i = 0; i < jsonArrayqueryAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayqueryAcl.get(i));
          };
        }
      }
      if (jsonObj.get("recursion_acl") != null && !jsonObj.get("recursion_acl").isJsonNull()) {
        JsonArray jsonArrayrecursionAcl = jsonObj.getAsJsonArray("recursion_acl");
        if (jsonArrayrecursionAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("recursion_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `recursion_acl` to be an array in the JSON string but got `%s`", jsonObj.get("recursion_acl").toString()));
          }

          // validate the optional field `recursion_acl` (array)
          for (int i = 0; i < jsonArrayrecursionAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayrecursionAcl.get(i));
          };
        }
      }
      if (jsonObj.get("sort_list") != null && !jsonObj.get("sort_list").isJsonNull()) {
        JsonArray jsonArraysortList = jsonObj.getAsJsonArray("sort_list");
        if (jsonArraysortList != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sort_list").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sort_list` to be an array in the JSON string but got `%s`", jsonObj.get("sort_list").toString()));
          }

          // validate the optional field `sort_list` (array)
          for (int i = 0; i < jsonArraysortList.size(); i++) {
            ConfigSortListItem.validateJsonElement(jsonArraysortList.get(i));
          };
        }
      }
      if (jsonObj.get("transfer_acl") != null && !jsonObj.get("transfer_acl").isJsonNull()) {
        JsonArray jsonArraytransferAcl = jsonObj.getAsJsonArray("transfer_acl");
        if (jsonArraytransferAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("transfer_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `transfer_acl` to be an array in the JSON string but got `%s`", jsonObj.get("transfer_acl").toString()));
          }

          // validate the optional field `transfer_acl` (array)
          for (int i = 0; i < jsonArraytransferAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArraytransferAcl.get(i));
          };
        }
      }
      if (jsonObj.get("update_acl") != null && !jsonObj.get("update_acl").isJsonNull()) {
        JsonArray jsonArrayupdateAcl = jsonObj.getAsJsonArray("update_acl");
        if (jsonArrayupdateAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("update_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `update_acl` to be an array in the JSON string but got `%s`", jsonObj.get("update_acl").toString()));
          }

          // validate the optional field `update_acl` (array)
          for (int i = 0; i < jsonArrayupdateAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayupdateAcl.get(i));
          };
        }
      }
      if (jsonObj.get("views") != null && !jsonObj.get("views").isJsonNull()) {
        JsonArray jsonArrayviews = jsonObj.getAsJsonArray("views");
        if (jsonArrayviews != null) {
          // ensure the json data is an array
          if (!jsonObj.get("views").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `views` to be an array in the JSON string but got `%s`", jsonObj.get("views").toString()));
          }

          // validate the optional field `views` (array)
          for (int i = 0; i < jsonArrayviews.size(); i++) {
            ConfigDisplayView.validateJsonElement(jsonArrayviews.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConfigServer.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConfigServer' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConfigServer> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConfigServer.class));

       return (TypeAdapter<T>) new TypeAdapter<ConfigServer>() {
           @Override
           public void write(JsonWriter out, ConfigServer value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ConfigServer read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ConfigServer given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ConfigServer
   * @throws IOException if the JSON string is invalid with respect to ConfigServer
   */
  public static ConfigServer fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConfigServer.class);
  }

  /**
   * Convert an instance of ConfigServer to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

