/*
 * DNS Configuration API
 * The DNS application is a BloxOne DDI service that provides cloud-based DNS configuration with on-prem host serving DNS protocol. It is part of the full-featured BloxOne DDI solution that enables customers the ability to deploy large numbers of protocol servers in the delivery of DNS and DHCP throughout their enterprise network.   
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ConfigACLItem;
import org.openapitools.client.model.ConfigDNSSECValidateException;
import org.openapitools.client.model.ConfigDTCConfig;
import org.openapitools.client.model.ConfigECSZone;
import org.openapitools.client.model.ConfigForwarder;
import org.openapitools.client.model.ConfigRootNS;
import org.openapitools.client.model.ConfigSortListItem;
import org.openapitools.client.model.ConfigTrustAnchor;
import org.openapitools.client.model.ConfigViewInheritance;
import org.openapitools.client.model.ConfigZoneAuthority;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * Named collection of DNS View settings.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:28.384903+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class ConfigView {
  public static final String SERIALIZED_NAME_ADD_EDNS_OPTION_IN_OUTGOING_QUERY = "add_edns_option_in_outgoing_query";
  @SerializedName(SERIALIZED_NAME_ADD_EDNS_OPTION_IN_OUTGOING_QUERY)
  @javax.annotation.Nullable
  private Boolean addEdnsOptionInOutgoingQuery;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  @javax.annotation.Nullable
  private String comment;

  public static final String SERIALIZED_NAME_COMPARTMENT_ID = "compartment_id";
  @SerializedName(SERIALIZED_NAME_COMPARTMENT_ID)
  @javax.annotation.Nullable
  private String compartmentId;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_CUSTOM_ROOT_NS = "custom_root_ns";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ROOT_NS)
  @javax.annotation.Nullable
  private List<ConfigRootNS> customRootNs = new ArrayList<>();

  public static final String SERIALIZED_NAME_CUSTOM_ROOT_NS_ENABLED = "custom_root_ns_enabled";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ROOT_NS_ENABLED)
  @javax.annotation.Nullable
  private Boolean customRootNsEnabled;

  public static final String SERIALIZED_NAME_DISABLED = "disabled";
  @SerializedName(SERIALIZED_NAME_DISABLED)
  @javax.annotation.Nullable
  private Boolean disabled;

  public static final String SERIALIZED_NAME_DNSSEC_ENABLE_VALIDATION = "dnssec_enable_validation";
  @SerializedName(SERIALIZED_NAME_DNSSEC_ENABLE_VALIDATION)
  @javax.annotation.Nullable
  private Boolean dnssecEnableValidation;

  public static final String SERIALIZED_NAME_DNSSEC_ENABLED = "dnssec_enabled";
  @SerializedName(SERIALIZED_NAME_DNSSEC_ENABLED)
  @javax.annotation.Nullable
  private Boolean dnssecEnabled;

  public static final String SERIALIZED_NAME_DNSSEC_ROOT_KEYS = "dnssec_root_keys";
  @SerializedName(SERIALIZED_NAME_DNSSEC_ROOT_KEYS)
  @javax.annotation.Nullable
  private List<ConfigTrustAnchor> dnssecRootKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_DNSSEC_TRUST_ANCHORS = "dnssec_trust_anchors";
  @SerializedName(SERIALIZED_NAME_DNSSEC_TRUST_ANCHORS)
  @javax.annotation.Nullable
  private List<ConfigTrustAnchor> dnssecTrustAnchors = new ArrayList<>();

  public static final String SERIALIZED_NAME_DNSSEC_VALIDATE_EXCEPTIONS = "dnssec_validate_exceptions";
  @SerializedName(SERIALIZED_NAME_DNSSEC_VALIDATE_EXCEPTIONS)
  @javax.annotation.Nullable
  private List<ConfigDNSSECValidateException> dnssecValidateExceptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DNSSEC_VALIDATE_EXPIRY = "dnssec_validate_expiry";
  @SerializedName(SERIALIZED_NAME_DNSSEC_VALIDATE_EXPIRY)
  @javax.annotation.Nullable
  private Boolean dnssecValidateExpiry;

  public static final String SERIALIZED_NAME_DTC_CONFIG = "dtc_config";
  @SerializedName(SERIALIZED_NAME_DTC_CONFIG)
  @javax.annotation.Nullable
  private ConfigDTCConfig dtcConfig;

  public static final String SERIALIZED_NAME_ECS_ENABLED = "ecs_enabled";
  @SerializedName(SERIALIZED_NAME_ECS_ENABLED)
  @javax.annotation.Nullable
  private Boolean ecsEnabled;

  public static final String SERIALIZED_NAME_ECS_FORWARDING = "ecs_forwarding";
  @SerializedName(SERIALIZED_NAME_ECS_FORWARDING)
  @javax.annotation.Nullable
  private Boolean ecsForwarding;

  public static final String SERIALIZED_NAME_ECS_PREFIX_V4 = "ecs_prefix_v4";
  @SerializedName(SERIALIZED_NAME_ECS_PREFIX_V4)
  @javax.annotation.Nullable
  private Long ecsPrefixV4;

  public static final String SERIALIZED_NAME_ECS_PREFIX_V6 = "ecs_prefix_v6";
  @SerializedName(SERIALIZED_NAME_ECS_PREFIX_V6)
  @javax.annotation.Nullable
  private Long ecsPrefixV6;

  public static final String SERIALIZED_NAME_ECS_ZONES = "ecs_zones";
  @SerializedName(SERIALIZED_NAME_ECS_ZONES)
  @javax.annotation.Nullable
  private List<ConfigECSZone> ecsZones = new ArrayList<>();

  public static final String SERIALIZED_NAME_EDNS_UDP_SIZE = "edns_udp_size";
  @SerializedName(SERIALIZED_NAME_EDNS_UDP_SIZE)
  @javax.annotation.Nullable
  private Long ednsUdpSize;

  public static final String SERIALIZED_NAME_EXTERNAL_PROVIDERS_METADATA = "external_providers_metadata";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_PROVIDERS_METADATA)
  @javax.annotation.Nullable
  private Object externalProvidersMetadata;

  public static final String SERIALIZED_NAME_FILTER_AAAA_ACL = "filter_aaaa_acl";
  @SerializedName(SERIALIZED_NAME_FILTER_AAAA_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> filterAaaaAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_FILTER_AAAA_ON_V4 = "filter_aaaa_on_v4";
  @SerializedName(SERIALIZED_NAME_FILTER_AAAA_ON_V4)
  @javax.annotation.Nullable
  private String filterAaaaOnV4;

  public static final String SERIALIZED_NAME_FORWARDERS = "forwarders";
  @SerializedName(SERIALIZED_NAME_FORWARDERS)
  @javax.annotation.Nullable
  private List<ConfigForwarder> forwarders = new ArrayList<>();

  public static final String SERIALIZED_NAME_FORWARDERS_ONLY = "forwarders_only";
  @SerializedName(SERIALIZED_NAME_FORWARDERS_ONLY)
  @javax.annotation.Nullable
  private Boolean forwardersOnly;

  public static final String SERIALIZED_NAME_GSS_TSIG_ENABLED = "gss_tsig_enabled";
  @SerializedName(SERIALIZED_NAME_GSS_TSIG_ENABLED)
  @javax.annotation.Nullable
  private Boolean gssTsigEnabled;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_INHERITANCE_SOURCES = "inheritance_sources";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_SOURCES)
  @javax.annotation.Nullable
  private ConfigViewInheritance inheritanceSources;

  public static final String SERIALIZED_NAME_IP_SPACES = "ip_spaces";
  @SerializedName(SERIALIZED_NAME_IP_SPACES)
  @javax.annotation.Nullable
  private List<String> ipSpaces = new ArrayList<>();

  public static final String SERIALIZED_NAME_LAME_TTL = "lame_ttl";
  @SerializedName(SERIALIZED_NAME_LAME_TTL)
  @javax.annotation.Nullable
  private Long lameTtl;

  public static final String SERIALIZED_NAME_MATCH_CLIENTS_ACL = "match_clients_acl";
  @SerializedName(SERIALIZED_NAME_MATCH_CLIENTS_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> matchClientsAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_MATCH_DESTINATIONS_ACL = "match_destinations_acl";
  @SerializedName(SERIALIZED_NAME_MATCH_DESTINATIONS_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> matchDestinationsAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_MATCH_RECURSIVE_ONLY = "match_recursive_only";
  @SerializedName(SERIALIZED_NAME_MATCH_RECURSIVE_ONLY)
  @javax.annotation.Nullable
  private Boolean matchRecursiveOnly;

  public static final String SERIALIZED_NAME_MAX_CACHE_TTL = "max_cache_ttl";
  @SerializedName(SERIALIZED_NAME_MAX_CACHE_TTL)
  @javax.annotation.Nullable
  private Long maxCacheTtl;

  public static final String SERIALIZED_NAME_MAX_NEGATIVE_TTL = "max_negative_ttl";
  @SerializedName(SERIALIZED_NAME_MAX_NEGATIVE_TTL)
  @javax.annotation.Nullable
  private Long maxNegativeTtl;

  public static final String SERIALIZED_NAME_MAX_UDP_SIZE = "max_udp_size";
  @SerializedName(SERIALIZED_NAME_MAX_UDP_SIZE)
  @javax.annotation.Nullable
  private Long maxUdpSize;

  public static final String SERIALIZED_NAME_MINIMAL_RESPONSES = "minimal_responses";
  @SerializedName(SERIALIZED_NAME_MINIMAL_RESPONSES)
  @javax.annotation.Nullable
  private Boolean minimalResponses;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nonnull
  private String name;

  public static final String SERIALIZED_NAME_NIOS_METADATA = "nios_metadata";
  @SerializedName(SERIALIZED_NAME_NIOS_METADATA)
  @javax.annotation.Nullable
  private Object niosMetadata;

  public static final String SERIALIZED_NAME_NOTIFY = "notify";
  @SerializedName(SERIALIZED_NAME_NOTIFY)
  @javax.annotation.Nullable
  private Boolean notify;

  public static final String SERIALIZED_NAME_QUERY_ACL = "query_acl";
  @SerializedName(SERIALIZED_NAME_QUERY_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> queryAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_RECURSION_ACL = "recursion_acl";
  @SerializedName(SERIALIZED_NAME_RECURSION_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> recursionAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_RECURSION_ENABLED = "recursion_enabled";
  @SerializedName(SERIALIZED_NAME_RECURSION_ENABLED)
  @javax.annotation.Nullable
  private Boolean recursionEnabled;

  public static final String SERIALIZED_NAME_SORT_LIST = "sort_list";
  @SerializedName(SERIALIZED_NAME_SORT_LIST)
  @javax.annotation.Nullable
  private List<ConfigSortListItem> sortList = new ArrayList<>();

  public static final String SERIALIZED_NAME_SYNTHESIZE_ADDRESS_RECORDS_FROM_HTTPS = "synthesize_address_records_from_https";
  @SerializedName(SERIALIZED_NAME_SYNTHESIZE_ADDRESS_RECORDS_FROM_HTTPS)
  @javax.annotation.Nullable
  private Boolean synthesizeAddressRecordsFromHttps;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  @javax.annotation.Nullable
  private Object tags;

  public static final String SERIALIZED_NAME_TRANSFER_ACL = "transfer_acl";
  @SerializedName(SERIALIZED_NAME_TRANSFER_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> transferAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_UPDATE_ACL = "update_acl";
  @SerializedName(SERIALIZED_NAME_UPDATE_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> updateAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_USE_FORWARDERS_FOR_SUBZONES = "use_forwarders_for_subzones";
  @SerializedName(SERIALIZED_NAME_USE_FORWARDERS_FOR_SUBZONES)
  @javax.annotation.Nullable
  private Boolean useForwardersForSubzones;

  public static final String SERIALIZED_NAME_USE_ROOT_FORWARDERS_FOR_LOCAL_RESOLUTION_WITH_B1TD = "use_root_forwarders_for_local_resolution_with_b1td";
  @SerializedName(SERIALIZED_NAME_USE_ROOT_FORWARDERS_FOR_LOCAL_RESOLUTION_WITH_B1TD)
  @javax.annotation.Nullable
  private Boolean useRootForwardersForLocalResolutionWithB1td;

  public static final String SERIALIZED_NAME_ZONE_AUTHORITY = "zone_authority";
  @SerializedName(SERIALIZED_NAME_ZONE_AUTHORITY)
  @javax.annotation.Nullable
  private ConfigZoneAuthority zoneAuthority;

  public ConfigView() {
  }

  public ConfigView(
     OffsetDateTime createdAt, 
     List<ConfigTrustAnchor> dnssecRootKeys, 
     String id, 
     OffsetDateTime updatedAt
  ) {
    this();
    this.createdAt = createdAt;
    this.dnssecRootKeys = dnssecRootKeys;
    this.id = id;
    this.updatedAt = updatedAt;
  }

  public ConfigView addEdnsOptionInOutgoingQuery(@javax.annotation.Nullable Boolean addEdnsOptionInOutgoingQuery) {
    this.addEdnsOptionInOutgoingQuery = addEdnsOptionInOutgoingQuery;
    return this;
  }

  /**
   * _add_edns_option_in_outgoing_query_ adds client IP, MAC address and view name into outgoing recursive query. Defaults to _false_.
   * @return addEdnsOptionInOutgoingQuery
   */
  @javax.annotation.Nullable
  public Boolean getAddEdnsOptionInOutgoingQuery() {
    return addEdnsOptionInOutgoingQuery;
  }

  public void setAddEdnsOptionInOutgoingQuery(@javax.annotation.Nullable Boolean addEdnsOptionInOutgoingQuery) {
    this.addEdnsOptionInOutgoingQuery = addEdnsOptionInOutgoingQuery;
  }


  public ConfigView comment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * Optional. Comment for view.
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
  }


  public ConfigView compartmentId(@javax.annotation.Nullable String compartmentId) {
    this.compartmentId = compartmentId;
    return this;
  }

  /**
   * The access view associated with the object. If no access view is associated with the object, the value defaults to empty.
   * @return compartmentId
   */
  @javax.annotation.Nullable
  public String getCompartmentId() {
    return compartmentId;
  }

  public void setCompartmentId(@javax.annotation.Nullable String compartmentId) {
    this.compartmentId = compartmentId;
  }


  /**
   * The timestamp when the object has been created.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  public ConfigView customRootNs(@javax.annotation.Nullable List<ConfigRootNS> customRootNs) {
    this.customRootNs = customRootNs;
    return this;
  }

  public ConfigView addCustomRootNsItem(ConfigRootNS customRootNsItem) {
    if (this.customRootNs == null) {
      this.customRootNs = new ArrayList<>();
    }
    this.customRootNs.add(customRootNsItem);
    return this;
  }

  /**
   * Optional. List of custom root nameservers. The order does not matter.  Error if empty while _custom_root_ns_enabled_ is _true_. Error if there are duplicate items in the list.  Defaults to empty.
   * @return customRootNs
   */
  @javax.annotation.Nullable
  public List<ConfigRootNS> getCustomRootNs() {
    return customRootNs;
  }

  public void setCustomRootNs(@javax.annotation.Nullable List<ConfigRootNS> customRootNs) {
    this.customRootNs = customRootNs;
  }


  public ConfigView customRootNsEnabled(@javax.annotation.Nullable Boolean customRootNsEnabled) {
    this.customRootNsEnabled = customRootNsEnabled;
    return this;
  }

  /**
   * Optional. _true_ to use custom root nameservers instead of the default ones.  The _custom_root_ns_ is validated when enabled.  Defaults to _false_.
   * @return customRootNsEnabled
   */
  @javax.annotation.Nullable
  public Boolean getCustomRootNsEnabled() {
    return customRootNsEnabled;
  }

  public void setCustomRootNsEnabled(@javax.annotation.Nullable Boolean customRootNsEnabled) {
    this.customRootNsEnabled = customRootNsEnabled;
  }


  public ConfigView disabled(@javax.annotation.Nullable Boolean disabled) {
    this.disabled = disabled;
    return this;
  }

  /**
   * Optional. _true_ to disable object. A disabled object is effectively non-existent when generating configuration.
   * @return disabled
   */
  @javax.annotation.Nullable
  public Boolean getDisabled() {
    return disabled;
  }

  public void setDisabled(@javax.annotation.Nullable Boolean disabled) {
    this.disabled = disabled;
  }


  public ConfigView dnssecEnableValidation(@javax.annotation.Nullable Boolean dnssecEnableValidation) {
    this.dnssecEnableValidation = dnssecEnableValidation;
    return this;
  }

  /**
   * Optional. _true_ to perform DNSSEC validation. Ignored if _dnssec_enabled_ is _false_.  Defaults to _true_.
   * @return dnssecEnableValidation
   */
  @javax.annotation.Nullable
  public Boolean getDnssecEnableValidation() {
    return dnssecEnableValidation;
  }

  public void setDnssecEnableValidation(@javax.annotation.Nullable Boolean dnssecEnableValidation) {
    this.dnssecEnableValidation = dnssecEnableValidation;
  }


  public ConfigView dnssecEnabled(@javax.annotation.Nullable Boolean dnssecEnabled) {
    this.dnssecEnabled = dnssecEnabled;
    return this;
  }

  /**
   * Optional. Master toggle for all DNSSEC processing. Other _dnssec_*_ configuration is unused if this is disabled.  Defaults to _true_.
   * @return dnssecEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDnssecEnabled() {
    return dnssecEnabled;
  }

  public void setDnssecEnabled(@javax.annotation.Nullable Boolean dnssecEnabled) {
    this.dnssecEnabled = dnssecEnabled;
  }


  /**
   * DNSSEC root keys. The root keys are not configurable.  A default list is provided by cloud management and included here for config generation.
   * @return dnssecRootKeys
   */
  @javax.annotation.Nullable
  public List<ConfigTrustAnchor> getDnssecRootKeys() {
    return dnssecRootKeys;
  }



  public ConfigView dnssecTrustAnchors(@javax.annotation.Nullable List<ConfigTrustAnchor> dnssecTrustAnchors) {
    this.dnssecTrustAnchors = dnssecTrustAnchors;
    return this;
  }

  public ConfigView addDnssecTrustAnchorsItem(ConfigTrustAnchor dnssecTrustAnchorsItem) {
    if (this.dnssecTrustAnchors == null) {
      this.dnssecTrustAnchors = new ArrayList<>();
    }
    this.dnssecTrustAnchors.add(dnssecTrustAnchorsItem);
    return this;
  }

  /**
   * Optional. DNSSEC trust anchors.  Error if there are list items with duplicate (_zone_, _sep_, _algorithm_) combinations.  Defaults to empty.
   * @return dnssecTrustAnchors
   */
  @javax.annotation.Nullable
  public List<ConfigTrustAnchor> getDnssecTrustAnchors() {
    return dnssecTrustAnchors;
  }

  public void setDnssecTrustAnchors(@javax.annotation.Nullable List<ConfigTrustAnchor> dnssecTrustAnchors) {
    this.dnssecTrustAnchors = dnssecTrustAnchors;
  }


  public ConfigView dnssecValidateExceptions(@javax.annotation.Nullable List<ConfigDNSSECValidateException> dnssecValidateExceptions) {
    this.dnssecValidateExceptions = dnssecValidateExceptions;
    return this;
  }

  public ConfigView addDnssecValidateExceptionsItem(ConfigDNSSECValidateException dnssecValidateExceptionsItem) {
    if (this.dnssecValidateExceptions == null) {
      this.dnssecValidateExceptions = new ArrayList<>();
    }
    this.dnssecValidateExceptions.add(dnssecValidateExceptionsItem);
    return this;
  }

  /**
   * Optional. DNSSEC validate exceptions.  Error if there are duplicate exception domains (compared as a DNS name including case-insensitive comparison).  Defaults to empty.
   * @return dnssecValidateExceptions
   */
  @javax.annotation.Nullable
  public List<ConfigDNSSECValidateException> getDnssecValidateExceptions() {
    return dnssecValidateExceptions;
  }

  public void setDnssecValidateExceptions(@javax.annotation.Nullable List<ConfigDNSSECValidateException> dnssecValidateExceptions) {
    this.dnssecValidateExceptions = dnssecValidateExceptions;
  }


  public ConfigView dnssecValidateExpiry(@javax.annotation.Nullable Boolean dnssecValidateExpiry) {
    this.dnssecValidateExpiry = dnssecValidateExpiry;
    return this;
  }

  /**
   * Optional. _true_ to reject expired DNSSEC keys. Ignored if either _dnssec_enabled_ or _dnssec_enable_validation_ is _false_.  Defaults to _true_.
   * @return dnssecValidateExpiry
   */
  @javax.annotation.Nullable
  public Boolean getDnssecValidateExpiry() {
    return dnssecValidateExpiry;
  }

  public void setDnssecValidateExpiry(@javax.annotation.Nullable Boolean dnssecValidateExpiry) {
    this.dnssecValidateExpiry = dnssecValidateExpiry;
  }


  public ConfigView dtcConfig(@javax.annotation.Nullable ConfigDTCConfig dtcConfig) {
    this.dtcConfig = dtcConfig;
    return this;
  }

  /**
   * Get dtcConfig
   * @return dtcConfig
   */
  @javax.annotation.Nullable
  public ConfigDTCConfig getDtcConfig() {
    return dtcConfig;
  }

  public void setDtcConfig(@javax.annotation.Nullable ConfigDTCConfig dtcConfig) {
    this.dtcConfig = dtcConfig;
  }


  public ConfigView ecsEnabled(@javax.annotation.Nullable Boolean ecsEnabled) {
    this.ecsEnabled = ecsEnabled;
    return this;
  }

  /**
   * Optional. _true_ to enable EDNS client subnet for recursive queries. Other _ecs_*_ fields are ignored if this field is not enabled.  Defaults to _false-.
   * @return ecsEnabled
   */
  @javax.annotation.Nullable
  public Boolean getEcsEnabled() {
    return ecsEnabled;
  }

  public void setEcsEnabled(@javax.annotation.Nullable Boolean ecsEnabled) {
    this.ecsEnabled = ecsEnabled;
  }


  public ConfigView ecsForwarding(@javax.annotation.Nullable Boolean ecsForwarding) {
    this.ecsForwarding = ecsForwarding;
    return this;
  }

  /**
   * Optional. _true_ to enable ECS options in outbound queries. This functionality has additional overhead so it is disabled by default.  Defaults to _false_.
   * @return ecsForwarding
   */
  @javax.annotation.Nullable
  public Boolean getEcsForwarding() {
    return ecsForwarding;
  }

  public void setEcsForwarding(@javax.annotation.Nullable Boolean ecsForwarding) {
    this.ecsForwarding = ecsForwarding;
  }


  public ConfigView ecsPrefixV4(@javax.annotation.Nullable Long ecsPrefixV4) {
    this.ecsPrefixV4 = ecsPrefixV4;
    return this;
  }

  /**
   * Optional. Maximum scope length for v4 ECS.  Unsigned integer, min 1 max 24  Defaults to 24.
   * @return ecsPrefixV4
   */
  @javax.annotation.Nullable
  public Long getEcsPrefixV4() {
    return ecsPrefixV4;
  }

  public void setEcsPrefixV4(@javax.annotation.Nullable Long ecsPrefixV4) {
    this.ecsPrefixV4 = ecsPrefixV4;
  }


  public ConfigView ecsPrefixV6(@javax.annotation.Nullable Long ecsPrefixV6) {
    this.ecsPrefixV6 = ecsPrefixV6;
    return this;
  }

  /**
   * Optional. Maximum scope length for v6 ECS.  Unsigned integer, min 1 max 56  Defaults to 56.
   * @return ecsPrefixV6
   */
  @javax.annotation.Nullable
  public Long getEcsPrefixV6() {
    return ecsPrefixV6;
  }

  public void setEcsPrefixV6(@javax.annotation.Nullable Long ecsPrefixV6) {
    this.ecsPrefixV6 = ecsPrefixV6;
  }


  public ConfigView ecsZones(@javax.annotation.Nullable List<ConfigECSZone> ecsZones) {
    this.ecsZones = ecsZones;
    return this;
  }

  public ConfigView addEcsZonesItem(ConfigECSZone ecsZonesItem) {
    if (this.ecsZones == null) {
      this.ecsZones = new ArrayList<>();
    }
    this.ecsZones.add(ecsZonesItem);
    return this;
  }

  /**
   * Optional. List of zones where ECS queries may be sent.  Error if empty while _ecs_enabled_ is _true_. Error if there are duplicate FQDNs in the list.  Defaults to empty.
   * @return ecsZones
   */
  @javax.annotation.Nullable
  public List<ConfigECSZone> getEcsZones() {
    return ecsZones;
  }

  public void setEcsZones(@javax.annotation.Nullable List<ConfigECSZone> ecsZones) {
    this.ecsZones = ecsZones;
  }


  public ConfigView ednsUdpSize(@javax.annotation.Nullable Long ednsUdpSize) {
    this.ednsUdpSize = ednsUdpSize;
    return this;
  }

  /**
   * Optional. _edns_udp_size_ represents the edns UDP size. The size a querying DNS server advertises to the DNS server it’s sending a query to.  Defaults to 1232 bytes.
   * @return ednsUdpSize
   */
  @javax.annotation.Nullable
  public Long getEdnsUdpSize() {
    return ednsUdpSize;
  }

  public void setEdnsUdpSize(@javax.annotation.Nullable Long ednsUdpSize) {
    this.ednsUdpSize = ednsUdpSize;
  }


  public ConfigView externalProvidersMetadata(@javax.annotation.Nullable Object externalProvidersMetadata) {
    this.externalProvidersMetadata = externalProvidersMetadata;
    return this;
  }

  /**
   * External DNS providers metadata.
   * @return externalProvidersMetadata
   */
  @javax.annotation.Nullable
  public Object getExternalProvidersMetadata() {
    return externalProvidersMetadata;
  }

  public void setExternalProvidersMetadata(@javax.annotation.Nullable Object externalProvidersMetadata) {
    this.externalProvidersMetadata = externalProvidersMetadata;
  }


  public ConfigView filterAaaaAcl(@javax.annotation.Nullable List<ConfigACLItem> filterAaaaAcl) {
    this.filterAaaaAcl = filterAaaaAcl;
    return this;
  }

  public ConfigView addFilterAaaaAclItem(ConfigACLItem filterAaaaAclItem) {
    if (this.filterAaaaAcl == null) {
      this.filterAaaaAcl = new ArrayList<>();
    }
    this.filterAaaaAcl.add(filterAaaaAclItem);
    return this;
  }

  /**
   * Optional. Specifies a list of client addresses for which AAAA filtering is to be applied.  Defaults to _empty_.
   * @return filterAaaaAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getFilterAaaaAcl() {
    return filterAaaaAcl;
  }

  public void setFilterAaaaAcl(@javax.annotation.Nullable List<ConfigACLItem> filterAaaaAcl) {
    this.filterAaaaAcl = filterAaaaAcl;
  }


  public ConfigView filterAaaaOnV4(@javax.annotation.Nullable String filterAaaaOnV4) {
    this.filterAaaaOnV4 = filterAaaaOnV4;
    return this;
  }

  /**
   * _filter_aaaa_on_v4_ allows named to omit some IPv6 addresses when responding to IPv4 clients.  Allowed values: * _yes_, * _no_, * _break_dnssec_.  Defaults to _no_
   * @return filterAaaaOnV4
   */
  @javax.annotation.Nullable
  public String getFilterAaaaOnV4() {
    return filterAaaaOnV4;
  }

  public void setFilterAaaaOnV4(@javax.annotation.Nullable String filterAaaaOnV4) {
    this.filterAaaaOnV4 = filterAaaaOnV4;
  }


  public ConfigView forwarders(@javax.annotation.Nullable List<ConfigForwarder> forwarders) {
    this.forwarders = forwarders;
    return this;
  }

  public ConfigView addForwardersItem(ConfigForwarder forwardersItem) {
    if (this.forwarders == null) {
      this.forwarders = new ArrayList<>();
    }
    this.forwarders.add(forwardersItem);
    return this;
  }

  /**
   * Optional. List of forwarders.  Error if empty while _forwarders_only_ or _use_root_forwarders_for_local_resolution_with_b1td_ is _true_. Error if there are items in the list with duplicate addresses.  Defaults to empty.
   * @return forwarders
   */
  @javax.annotation.Nullable
  public List<ConfigForwarder> getForwarders() {
    return forwarders;
  }

  public void setForwarders(@javax.annotation.Nullable List<ConfigForwarder> forwarders) {
    this.forwarders = forwarders;
  }


  public ConfigView forwardersOnly(@javax.annotation.Nullable Boolean forwardersOnly) {
    this.forwardersOnly = forwardersOnly;
    return this;
  }

  /**
   * Optional. _true_ to only forward.  Defaults to _false_.
   * @return forwardersOnly
   */
  @javax.annotation.Nullable
  public Boolean getForwardersOnly() {
    return forwardersOnly;
  }

  public void setForwardersOnly(@javax.annotation.Nullable Boolean forwardersOnly) {
    this.forwardersOnly = forwardersOnly;
  }


  public ConfigView gssTsigEnabled(@javax.annotation.Nullable Boolean gssTsigEnabled) {
    this.gssTsigEnabled = gssTsigEnabled;
    return this;
  }

  /**
   * _gss_tsig_enabled_ enables/disables GSS-TSIG signed dynamic updates.  Defaults to _false_.
   * @return gssTsigEnabled
   */
  @javax.annotation.Nullable
  public Boolean getGssTsigEnabled() {
    return gssTsigEnabled;
  }

  public void setGssTsigEnabled(@javax.annotation.Nullable Boolean gssTsigEnabled) {
    this.gssTsigEnabled = gssTsigEnabled;
  }


  /**
   * The resource identifier.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public ConfigView inheritanceSources(@javax.annotation.Nullable ConfigViewInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
    return this;
  }

  /**
   * Get inheritanceSources
   * @return inheritanceSources
   */
  @javax.annotation.Nullable
  public ConfigViewInheritance getInheritanceSources() {
    return inheritanceSources;
  }

  public void setInheritanceSources(@javax.annotation.Nullable ConfigViewInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
  }


  public ConfigView ipSpaces(@javax.annotation.Nullable List<String> ipSpaces) {
    this.ipSpaces = ipSpaces;
    return this;
  }

  public ConfigView addIpSpacesItem(String ipSpacesItem) {
    if (this.ipSpaces == null) {
      this.ipSpaces = new ArrayList<>();
    }
    this.ipSpaces.add(ipSpacesItem);
    return this;
  }

  /**
   * The resource identifier.
   * @return ipSpaces
   */
  @javax.annotation.Nullable
  public List<String> getIpSpaces() {
    return ipSpaces;
  }

  public void setIpSpaces(@javax.annotation.Nullable List<String> ipSpaces) {
    this.ipSpaces = ipSpaces;
  }


  public ConfigView lameTtl(@javax.annotation.Nullable Long lameTtl) {
    this.lameTtl = lameTtl;
    return this;
  }

  /**
   * Optional. Unused in the current on-prem DNS server implementation.  Unsigned integer, min 0 max 3600 (1h).  Defaults to 600.
   * @return lameTtl
   */
  @javax.annotation.Nullable
  public Long getLameTtl() {
    return lameTtl;
  }

  public void setLameTtl(@javax.annotation.Nullable Long lameTtl) {
    this.lameTtl = lameTtl;
  }


  public ConfigView matchClientsAcl(@javax.annotation.Nullable List<ConfigACLItem> matchClientsAcl) {
    this.matchClientsAcl = matchClientsAcl;
    return this;
  }

  public ConfigView addMatchClientsAclItem(ConfigACLItem matchClientsAclItem) {
    if (this.matchClientsAcl == null) {
      this.matchClientsAcl = new ArrayList<>();
    }
    this.matchClientsAcl.add(matchClientsAclItem);
    return this;
  }

  /**
   * Optional. Specifies which clients have access to the view.  Defaults to empty.
   * @return matchClientsAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getMatchClientsAcl() {
    return matchClientsAcl;
  }

  public void setMatchClientsAcl(@javax.annotation.Nullable List<ConfigACLItem> matchClientsAcl) {
    this.matchClientsAcl = matchClientsAcl;
  }


  public ConfigView matchDestinationsAcl(@javax.annotation.Nullable List<ConfigACLItem> matchDestinationsAcl) {
    this.matchDestinationsAcl = matchDestinationsAcl;
    return this;
  }

  public ConfigView addMatchDestinationsAclItem(ConfigACLItem matchDestinationsAclItem) {
    if (this.matchDestinationsAcl == null) {
      this.matchDestinationsAcl = new ArrayList<>();
    }
    this.matchDestinationsAcl.add(matchDestinationsAclItem);
    return this;
  }

  /**
   * Optional. Specifies which destination addresses have access to the view.  Defaults to empty.
   * @return matchDestinationsAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getMatchDestinationsAcl() {
    return matchDestinationsAcl;
  }

  public void setMatchDestinationsAcl(@javax.annotation.Nullable List<ConfigACLItem> matchDestinationsAcl) {
    this.matchDestinationsAcl = matchDestinationsAcl;
  }


  public ConfigView matchRecursiveOnly(@javax.annotation.Nullable Boolean matchRecursiveOnly) {
    this.matchRecursiveOnly = matchRecursiveOnly;
    return this;
  }

  /**
   * Optional. If _true_ only recursive queries from matching clients access the view.  Defaults to _false_.
   * @return matchRecursiveOnly
   */
  @javax.annotation.Nullable
  public Boolean getMatchRecursiveOnly() {
    return matchRecursiveOnly;
  }

  public void setMatchRecursiveOnly(@javax.annotation.Nullable Boolean matchRecursiveOnly) {
    this.matchRecursiveOnly = matchRecursiveOnly;
  }


  public ConfigView maxCacheTtl(@javax.annotation.Nullable Long maxCacheTtl) {
    this.maxCacheTtl = maxCacheTtl;
    return this;
  }

  /**
   * Optional. Seconds to cache positive responses.  Unsigned integer, min 1 max 604800 (7d).  Defaults to 604800 (7d).
   * @return maxCacheTtl
   */
  @javax.annotation.Nullable
  public Long getMaxCacheTtl() {
    return maxCacheTtl;
  }

  public void setMaxCacheTtl(@javax.annotation.Nullable Long maxCacheTtl) {
    this.maxCacheTtl = maxCacheTtl;
  }


  public ConfigView maxNegativeTtl(@javax.annotation.Nullable Long maxNegativeTtl) {
    this.maxNegativeTtl = maxNegativeTtl;
    return this;
  }

  /**
   * Optional. Seconds to cache negative responses.  Unsigned integer, min 1 max 604800 (7d).  Defaults to 10800 (3h).
   * @return maxNegativeTtl
   */
  @javax.annotation.Nullable
  public Long getMaxNegativeTtl() {
    return maxNegativeTtl;
  }

  public void setMaxNegativeTtl(@javax.annotation.Nullable Long maxNegativeTtl) {
    this.maxNegativeTtl = maxNegativeTtl;
  }


  public ConfigView maxUdpSize(@javax.annotation.Nullable Long maxUdpSize) {
    this.maxUdpSize = maxUdpSize;
    return this;
  }

  /**
   * Optional. _max_udp_size_ represents maximum UDP payload size. The maximum number of bytes a responding DNS server will send to a UDP datagram.  Defaults to 1232 bytes.
   * @return maxUdpSize
   */
  @javax.annotation.Nullable
  public Long getMaxUdpSize() {
    return maxUdpSize;
  }

  public void setMaxUdpSize(@javax.annotation.Nullable Long maxUdpSize) {
    this.maxUdpSize = maxUdpSize;
  }


  public ConfigView minimalResponses(@javax.annotation.Nullable Boolean minimalResponses) {
    this.minimalResponses = minimalResponses;
    return this;
  }

  /**
   * Optional. When enabled, the DNS server will only add records to the authority and additional data sections when they are required.  Defaults to _false_.
   * @return minimalResponses
   */
  @javax.annotation.Nullable
  public Boolean getMinimalResponses() {
    return minimalResponses;
  }

  public void setMinimalResponses(@javax.annotation.Nullable Boolean minimalResponses) {
    this.minimalResponses = minimalResponses;
  }


  public ConfigView name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of view.
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public ConfigView niosMetadata(@javax.annotation.Nullable Object niosMetadata) {
    this.niosMetadata = niosMetadata;
    return this;
  }

  /**
   * NIOS Metadata holds NIOS grid&#39;s data.
   * @return niosMetadata
   */
  @javax.annotation.Nullable
  public Object getNiosMetadata() {
    return niosMetadata;
  }

  public void setNiosMetadata(@javax.annotation.Nullable Object niosMetadata) {
    this.niosMetadata = niosMetadata;
  }


  public ConfigView notify(@javax.annotation.Nullable Boolean notify) {
    this.notify = notify;
    return this;
  }

  /**
   * _notify_ all external secondary DNS servers.  Defaults to _false_.
   * @return notify
   */
  @javax.annotation.Nullable
  public Boolean getNotify() {
    return notify;
  }

  public void setNotify(@javax.annotation.Nullable Boolean notify) {
    this.notify = notify;
  }


  public ConfigView queryAcl(@javax.annotation.Nullable List<ConfigACLItem> queryAcl) {
    this.queryAcl = queryAcl;
    return this;
  }

  public ConfigView addQueryAclItem(ConfigACLItem queryAclItem) {
    if (this.queryAcl == null) {
      this.queryAcl = new ArrayList<>();
    }
    this.queryAcl.add(queryAclItem);
    return this;
  }

  /**
   * Optional. Clients must match this ACL to make authoritative queries. Also used for recursive queries if that ACL is unset.  Defaults to empty.
   * @return queryAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getQueryAcl() {
    return queryAcl;
  }

  public void setQueryAcl(@javax.annotation.Nullable List<ConfigACLItem> queryAcl) {
    this.queryAcl = queryAcl;
  }


  public ConfigView recursionAcl(@javax.annotation.Nullable List<ConfigACLItem> recursionAcl) {
    this.recursionAcl = recursionAcl;
    return this;
  }

  public ConfigView addRecursionAclItem(ConfigACLItem recursionAclItem) {
    if (this.recursionAcl == null) {
      this.recursionAcl = new ArrayList<>();
    }
    this.recursionAcl.add(recursionAclItem);
    return this;
  }

  /**
   * Optional. Clients must match this ACL to make recursive queries. If this ACL is empty, then the _query_acl_ will be used instead.  Defaults to empty.
   * @return recursionAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getRecursionAcl() {
    return recursionAcl;
  }

  public void setRecursionAcl(@javax.annotation.Nullable List<ConfigACLItem> recursionAcl) {
    this.recursionAcl = recursionAcl;
  }


  public ConfigView recursionEnabled(@javax.annotation.Nullable Boolean recursionEnabled) {
    this.recursionEnabled = recursionEnabled;
    return this;
  }

  /**
   * Optional. _true_ to allow recursive DNS queries.  Defaults to _true_.
   * @return recursionEnabled
   */
  @javax.annotation.Nullable
  public Boolean getRecursionEnabled() {
    return recursionEnabled;
  }

  public void setRecursionEnabled(@javax.annotation.Nullable Boolean recursionEnabled) {
    this.recursionEnabled = recursionEnabled;
  }


  public ConfigView sortList(@javax.annotation.Nullable List<ConfigSortListItem> sortList) {
    this.sortList = sortList;
    return this;
  }

  public ConfigView addSortListItem(ConfigSortListItem sortListItem) {
    if (this.sortList == null) {
      this.sortList = new ArrayList<>();
    }
    this.sortList.add(sortListItem);
    return this;
  }

  /**
   * Optional. Specifies a sorted network list for A/AAAA records in DNS query response.  Defaults to _empty_.
   * @return sortList
   */
  @javax.annotation.Nullable
  public List<ConfigSortListItem> getSortList() {
    return sortList;
  }

  public void setSortList(@javax.annotation.Nullable List<ConfigSortListItem> sortList) {
    this.sortList = sortList;
  }


  public ConfigView synthesizeAddressRecordsFromHttps(@javax.annotation.Nullable Boolean synthesizeAddressRecordsFromHttps) {
    this.synthesizeAddressRecordsFromHttps = synthesizeAddressRecordsFromHttps;
    return this;
  }

  /**
   * _synthesize_address_records_from_https_ enables/disables creation of A/AAAA records from HTTPS RR Defaults to _false_.
   * @return synthesizeAddressRecordsFromHttps
   */
  @javax.annotation.Nullable
  public Boolean getSynthesizeAddressRecordsFromHttps() {
    return synthesizeAddressRecordsFromHttps;
  }

  public void setSynthesizeAddressRecordsFromHttps(@javax.annotation.Nullable Boolean synthesizeAddressRecordsFromHttps) {
    this.synthesizeAddressRecordsFromHttps = synthesizeAddressRecordsFromHttps;
  }


  public ConfigView tags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
    return this;
  }

  /**
   * Tagging specifics.
   * @return tags
   */
  @javax.annotation.Nullable
  public Object getTags() {
    return tags;
  }

  public void setTags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
  }


  public ConfigView transferAcl(@javax.annotation.Nullable List<ConfigACLItem> transferAcl) {
    this.transferAcl = transferAcl;
    return this;
  }

  public ConfigView addTransferAclItem(ConfigACLItem transferAclItem) {
    if (this.transferAcl == null) {
      this.transferAcl = new ArrayList<>();
    }
    this.transferAcl.add(transferAclItem);
    return this;
  }

  /**
   * Optional. Clients must match this ACL to receive zone transfers.  Defaults to empty.
   * @return transferAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getTransferAcl() {
    return transferAcl;
  }

  public void setTransferAcl(@javax.annotation.Nullable List<ConfigACLItem> transferAcl) {
    this.transferAcl = transferAcl;
  }


  public ConfigView updateAcl(@javax.annotation.Nullable List<ConfigACLItem> updateAcl) {
    this.updateAcl = updateAcl;
    return this;
  }

  public ConfigView addUpdateAclItem(ConfigACLItem updateAclItem) {
    if (this.updateAcl == null) {
      this.updateAcl = new ArrayList<>();
    }
    this.updateAcl.add(updateAclItem);
    return this;
  }

  /**
   * Optional. Specifies which hosts are allowed to issue Dynamic DNS updates for authoritative zones of _primary_type_ _cloud_.  Defaults to empty.
   * @return updateAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getUpdateAcl() {
    return updateAcl;
  }

  public void setUpdateAcl(@javax.annotation.Nullable List<ConfigACLItem> updateAcl) {
    this.updateAcl = updateAcl;
  }


  /**
   * The timestamp when the object has been updated. Equals to _created_at_ if not updated after creation.
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }



  public ConfigView useForwardersForSubzones(@javax.annotation.Nullable Boolean useForwardersForSubzones) {
    this.useForwardersForSubzones = useForwardersForSubzones;
    return this;
  }

  /**
   * Optional. Use default forwarders to resolve queries for subzones.  Defaults to _true_.
   * @return useForwardersForSubzones
   */
  @javax.annotation.Nullable
  public Boolean getUseForwardersForSubzones() {
    return useForwardersForSubzones;
  }

  public void setUseForwardersForSubzones(@javax.annotation.Nullable Boolean useForwardersForSubzones) {
    this.useForwardersForSubzones = useForwardersForSubzones;
  }


  public ConfigView useRootForwardersForLocalResolutionWithB1td(@javax.annotation.Nullable Boolean useRootForwardersForLocalResolutionWithB1td) {
    this.useRootForwardersForLocalResolutionWithB1td = useRootForwardersForLocalResolutionWithB1td;
    return this;
  }

  /**
   * _use_root_forwarders_for_local_resolution_with_b1td_ allows DNS recursive queries sent to root forwarders for local resolution when deployed alongside BloxOne Thread Defense. Defaults to _false_.
   * @return useRootForwardersForLocalResolutionWithB1td
   */
  @javax.annotation.Nullable
  public Boolean getUseRootForwardersForLocalResolutionWithB1td() {
    return useRootForwardersForLocalResolutionWithB1td;
  }

  public void setUseRootForwardersForLocalResolutionWithB1td(@javax.annotation.Nullable Boolean useRootForwardersForLocalResolutionWithB1td) {
    this.useRootForwardersForLocalResolutionWithB1td = useRootForwardersForLocalResolutionWithB1td;
  }


  public ConfigView zoneAuthority(@javax.annotation.Nullable ConfigZoneAuthority zoneAuthority) {
    this.zoneAuthority = zoneAuthority;
    return this;
  }

  /**
   * Get zoneAuthority
   * @return zoneAuthority
   */
  @javax.annotation.Nullable
  public ConfigZoneAuthority getZoneAuthority() {
    return zoneAuthority;
  }

  public void setZoneAuthority(@javax.annotation.Nullable ConfigZoneAuthority zoneAuthority) {
    this.zoneAuthority = zoneAuthority;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConfigView configView = (ConfigView) o;
    return Objects.equals(this.addEdnsOptionInOutgoingQuery, configView.addEdnsOptionInOutgoingQuery) &&
        Objects.equals(this.comment, configView.comment) &&
        Objects.equals(this.compartmentId, configView.compartmentId) &&
        Objects.equals(this.createdAt, configView.createdAt) &&
        Objects.equals(this.customRootNs, configView.customRootNs) &&
        Objects.equals(this.customRootNsEnabled, configView.customRootNsEnabled) &&
        Objects.equals(this.disabled, configView.disabled) &&
        Objects.equals(this.dnssecEnableValidation, configView.dnssecEnableValidation) &&
        Objects.equals(this.dnssecEnabled, configView.dnssecEnabled) &&
        Objects.equals(this.dnssecRootKeys, configView.dnssecRootKeys) &&
        Objects.equals(this.dnssecTrustAnchors, configView.dnssecTrustAnchors) &&
        Objects.equals(this.dnssecValidateExceptions, configView.dnssecValidateExceptions) &&
        Objects.equals(this.dnssecValidateExpiry, configView.dnssecValidateExpiry) &&
        Objects.equals(this.dtcConfig, configView.dtcConfig) &&
        Objects.equals(this.ecsEnabled, configView.ecsEnabled) &&
        Objects.equals(this.ecsForwarding, configView.ecsForwarding) &&
        Objects.equals(this.ecsPrefixV4, configView.ecsPrefixV4) &&
        Objects.equals(this.ecsPrefixV6, configView.ecsPrefixV6) &&
        Objects.equals(this.ecsZones, configView.ecsZones) &&
        Objects.equals(this.ednsUdpSize, configView.ednsUdpSize) &&
        Objects.equals(this.externalProvidersMetadata, configView.externalProvidersMetadata) &&
        Objects.equals(this.filterAaaaAcl, configView.filterAaaaAcl) &&
        Objects.equals(this.filterAaaaOnV4, configView.filterAaaaOnV4) &&
        Objects.equals(this.forwarders, configView.forwarders) &&
        Objects.equals(this.forwardersOnly, configView.forwardersOnly) &&
        Objects.equals(this.gssTsigEnabled, configView.gssTsigEnabled) &&
        Objects.equals(this.id, configView.id) &&
        Objects.equals(this.inheritanceSources, configView.inheritanceSources) &&
        Objects.equals(this.ipSpaces, configView.ipSpaces) &&
        Objects.equals(this.lameTtl, configView.lameTtl) &&
        Objects.equals(this.matchClientsAcl, configView.matchClientsAcl) &&
        Objects.equals(this.matchDestinationsAcl, configView.matchDestinationsAcl) &&
        Objects.equals(this.matchRecursiveOnly, configView.matchRecursiveOnly) &&
        Objects.equals(this.maxCacheTtl, configView.maxCacheTtl) &&
        Objects.equals(this.maxNegativeTtl, configView.maxNegativeTtl) &&
        Objects.equals(this.maxUdpSize, configView.maxUdpSize) &&
        Objects.equals(this.minimalResponses, configView.minimalResponses) &&
        Objects.equals(this.name, configView.name) &&
        Objects.equals(this.niosMetadata, configView.niosMetadata) &&
        Objects.equals(this.notify, configView.notify) &&
        Objects.equals(this.queryAcl, configView.queryAcl) &&
        Objects.equals(this.recursionAcl, configView.recursionAcl) &&
        Objects.equals(this.recursionEnabled, configView.recursionEnabled) &&
        Objects.equals(this.sortList, configView.sortList) &&
        Objects.equals(this.synthesizeAddressRecordsFromHttps, configView.synthesizeAddressRecordsFromHttps) &&
        Objects.equals(this.tags, configView.tags) &&
        Objects.equals(this.transferAcl, configView.transferAcl) &&
        Objects.equals(this.updateAcl, configView.updateAcl) &&
        Objects.equals(this.updatedAt, configView.updatedAt) &&
        Objects.equals(this.useForwardersForSubzones, configView.useForwardersForSubzones) &&
        Objects.equals(this.useRootForwardersForLocalResolutionWithB1td, configView.useRootForwardersForLocalResolutionWithB1td) &&
        Objects.equals(this.zoneAuthority, configView.zoneAuthority);
  }

  @Override
  public int hashCode() {
    return Objects.hash(addEdnsOptionInOutgoingQuery, comment, compartmentId, createdAt, customRootNs, customRootNsEnabled, disabled, dnssecEnableValidation, dnssecEnabled, dnssecRootKeys, dnssecTrustAnchors, dnssecValidateExceptions, dnssecValidateExpiry, dtcConfig, ecsEnabled, ecsForwarding, ecsPrefixV4, ecsPrefixV6, ecsZones, ednsUdpSize, externalProvidersMetadata, filterAaaaAcl, filterAaaaOnV4, forwarders, forwardersOnly, gssTsigEnabled, id, inheritanceSources, ipSpaces, lameTtl, matchClientsAcl, matchDestinationsAcl, matchRecursiveOnly, maxCacheTtl, maxNegativeTtl, maxUdpSize, minimalResponses, name, niosMetadata, notify, queryAcl, recursionAcl, recursionEnabled, sortList, synthesizeAddressRecordsFromHttps, tags, transferAcl, updateAcl, updatedAt, useForwardersForSubzones, useRootForwardersForLocalResolutionWithB1td, zoneAuthority);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConfigView {\n");
    sb.append("    addEdnsOptionInOutgoingQuery: ").append(toIndentedString(addEdnsOptionInOutgoingQuery)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    compartmentId: ").append(toIndentedString(compartmentId)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    customRootNs: ").append(toIndentedString(customRootNs)).append("\n");
    sb.append("    customRootNsEnabled: ").append(toIndentedString(customRootNsEnabled)).append("\n");
    sb.append("    disabled: ").append(toIndentedString(disabled)).append("\n");
    sb.append("    dnssecEnableValidation: ").append(toIndentedString(dnssecEnableValidation)).append("\n");
    sb.append("    dnssecEnabled: ").append(toIndentedString(dnssecEnabled)).append("\n");
    sb.append("    dnssecRootKeys: ").append(toIndentedString(dnssecRootKeys)).append("\n");
    sb.append("    dnssecTrustAnchors: ").append(toIndentedString(dnssecTrustAnchors)).append("\n");
    sb.append("    dnssecValidateExceptions: ").append(toIndentedString(dnssecValidateExceptions)).append("\n");
    sb.append("    dnssecValidateExpiry: ").append(toIndentedString(dnssecValidateExpiry)).append("\n");
    sb.append("    dtcConfig: ").append(toIndentedString(dtcConfig)).append("\n");
    sb.append("    ecsEnabled: ").append(toIndentedString(ecsEnabled)).append("\n");
    sb.append("    ecsForwarding: ").append(toIndentedString(ecsForwarding)).append("\n");
    sb.append("    ecsPrefixV4: ").append(toIndentedString(ecsPrefixV4)).append("\n");
    sb.append("    ecsPrefixV6: ").append(toIndentedString(ecsPrefixV6)).append("\n");
    sb.append("    ecsZones: ").append(toIndentedString(ecsZones)).append("\n");
    sb.append("    ednsUdpSize: ").append(toIndentedString(ednsUdpSize)).append("\n");
    sb.append("    externalProvidersMetadata: ").append(toIndentedString(externalProvidersMetadata)).append("\n");
    sb.append("    filterAaaaAcl: ").append(toIndentedString(filterAaaaAcl)).append("\n");
    sb.append("    filterAaaaOnV4: ").append(toIndentedString(filterAaaaOnV4)).append("\n");
    sb.append("    forwarders: ").append(toIndentedString(forwarders)).append("\n");
    sb.append("    forwardersOnly: ").append(toIndentedString(forwardersOnly)).append("\n");
    sb.append("    gssTsigEnabled: ").append(toIndentedString(gssTsigEnabled)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    inheritanceSources: ").append(toIndentedString(inheritanceSources)).append("\n");
    sb.append("    ipSpaces: ").append(toIndentedString(ipSpaces)).append("\n");
    sb.append("    lameTtl: ").append(toIndentedString(lameTtl)).append("\n");
    sb.append("    matchClientsAcl: ").append(toIndentedString(matchClientsAcl)).append("\n");
    sb.append("    matchDestinationsAcl: ").append(toIndentedString(matchDestinationsAcl)).append("\n");
    sb.append("    matchRecursiveOnly: ").append(toIndentedString(matchRecursiveOnly)).append("\n");
    sb.append("    maxCacheTtl: ").append(toIndentedString(maxCacheTtl)).append("\n");
    sb.append("    maxNegativeTtl: ").append(toIndentedString(maxNegativeTtl)).append("\n");
    sb.append("    maxUdpSize: ").append(toIndentedString(maxUdpSize)).append("\n");
    sb.append("    minimalResponses: ").append(toIndentedString(minimalResponses)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    niosMetadata: ").append(toIndentedString(niosMetadata)).append("\n");
    sb.append("    notify: ").append(toIndentedString(notify)).append("\n");
    sb.append("    queryAcl: ").append(toIndentedString(queryAcl)).append("\n");
    sb.append("    recursionAcl: ").append(toIndentedString(recursionAcl)).append("\n");
    sb.append("    recursionEnabled: ").append(toIndentedString(recursionEnabled)).append("\n");
    sb.append("    sortList: ").append(toIndentedString(sortList)).append("\n");
    sb.append("    synthesizeAddressRecordsFromHttps: ").append(toIndentedString(synthesizeAddressRecordsFromHttps)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    transferAcl: ").append(toIndentedString(transferAcl)).append("\n");
    sb.append("    updateAcl: ").append(toIndentedString(updateAcl)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    useForwardersForSubzones: ").append(toIndentedString(useForwardersForSubzones)).append("\n");
    sb.append("    useRootForwardersForLocalResolutionWithB1td: ").append(toIndentedString(useRootForwardersForLocalResolutionWithB1td)).append("\n");
    sb.append("    zoneAuthority: ").append(toIndentedString(zoneAuthority)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("add_edns_option_in_outgoing_query");
    openapiFields.add("comment");
    openapiFields.add("compartment_id");
    openapiFields.add("created_at");
    openapiFields.add("custom_root_ns");
    openapiFields.add("custom_root_ns_enabled");
    openapiFields.add("disabled");
    openapiFields.add("dnssec_enable_validation");
    openapiFields.add("dnssec_enabled");
    openapiFields.add("dnssec_root_keys");
    openapiFields.add("dnssec_trust_anchors");
    openapiFields.add("dnssec_validate_exceptions");
    openapiFields.add("dnssec_validate_expiry");
    openapiFields.add("dtc_config");
    openapiFields.add("ecs_enabled");
    openapiFields.add("ecs_forwarding");
    openapiFields.add("ecs_prefix_v4");
    openapiFields.add("ecs_prefix_v6");
    openapiFields.add("ecs_zones");
    openapiFields.add("edns_udp_size");
    openapiFields.add("external_providers_metadata");
    openapiFields.add("filter_aaaa_acl");
    openapiFields.add("filter_aaaa_on_v4");
    openapiFields.add("forwarders");
    openapiFields.add("forwarders_only");
    openapiFields.add("gss_tsig_enabled");
    openapiFields.add("id");
    openapiFields.add("inheritance_sources");
    openapiFields.add("ip_spaces");
    openapiFields.add("lame_ttl");
    openapiFields.add("match_clients_acl");
    openapiFields.add("match_destinations_acl");
    openapiFields.add("match_recursive_only");
    openapiFields.add("max_cache_ttl");
    openapiFields.add("max_negative_ttl");
    openapiFields.add("max_udp_size");
    openapiFields.add("minimal_responses");
    openapiFields.add("name");
    openapiFields.add("nios_metadata");
    openapiFields.add("notify");
    openapiFields.add("query_acl");
    openapiFields.add("recursion_acl");
    openapiFields.add("recursion_enabled");
    openapiFields.add("sort_list");
    openapiFields.add("synthesize_address_records_from_https");
    openapiFields.add("tags");
    openapiFields.add("transfer_acl");
    openapiFields.add("update_acl");
    openapiFields.add("updated_at");
    openapiFields.add("use_forwarders_for_subzones");
    openapiFields.add("use_root_forwarders_for_local_resolution_with_b1td");
    openapiFields.add("zone_authority");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ConfigView
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ConfigView.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConfigView is not found in the empty JSON string", ConfigView.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ConfigView.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ConfigView` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ConfigView.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if ((jsonObj.get("compartment_id") != null && !jsonObj.get("compartment_id").isJsonNull()) && !jsonObj.get("compartment_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compartment_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compartment_id").toString()));
      }
      if (jsonObj.get("custom_root_ns") != null && !jsonObj.get("custom_root_ns").isJsonNull()) {
        JsonArray jsonArraycustomRootNs = jsonObj.getAsJsonArray("custom_root_ns");
        if (jsonArraycustomRootNs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("custom_root_ns").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `custom_root_ns` to be an array in the JSON string but got `%s`", jsonObj.get("custom_root_ns").toString()));
          }

          // validate the optional field `custom_root_ns` (array)
          for (int i = 0; i < jsonArraycustomRootNs.size(); i++) {
            ConfigRootNS.validateJsonElement(jsonArraycustomRootNs.get(i));
          };
        }
      }
      if (jsonObj.get("dnssec_root_keys") != null && !jsonObj.get("dnssec_root_keys").isJsonNull()) {
        JsonArray jsonArraydnssecRootKeys = jsonObj.getAsJsonArray("dnssec_root_keys");
        if (jsonArraydnssecRootKeys != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dnssec_root_keys").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dnssec_root_keys` to be an array in the JSON string but got `%s`", jsonObj.get("dnssec_root_keys").toString()));
          }

          // validate the optional field `dnssec_root_keys` (array)
          for (int i = 0; i < jsonArraydnssecRootKeys.size(); i++) {
            ConfigTrustAnchor.validateJsonElement(jsonArraydnssecRootKeys.get(i));
          };
        }
      }
      if (jsonObj.get("dnssec_trust_anchors") != null && !jsonObj.get("dnssec_trust_anchors").isJsonNull()) {
        JsonArray jsonArraydnssecTrustAnchors = jsonObj.getAsJsonArray("dnssec_trust_anchors");
        if (jsonArraydnssecTrustAnchors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dnssec_trust_anchors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dnssec_trust_anchors` to be an array in the JSON string but got `%s`", jsonObj.get("dnssec_trust_anchors").toString()));
          }

          // validate the optional field `dnssec_trust_anchors` (array)
          for (int i = 0; i < jsonArraydnssecTrustAnchors.size(); i++) {
            ConfigTrustAnchor.validateJsonElement(jsonArraydnssecTrustAnchors.get(i));
          };
        }
      }
      if (jsonObj.get("dnssec_validate_exceptions") != null && !jsonObj.get("dnssec_validate_exceptions").isJsonNull()) {
        JsonArray jsonArraydnssecValidateExceptions = jsonObj.getAsJsonArray("dnssec_validate_exceptions");
        if (jsonArraydnssecValidateExceptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dnssec_validate_exceptions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dnssec_validate_exceptions` to be an array in the JSON string but got `%s`", jsonObj.get("dnssec_validate_exceptions").toString()));
          }

          // validate the optional field `dnssec_validate_exceptions` (array)
          for (int i = 0; i < jsonArraydnssecValidateExceptions.size(); i++) {
            ConfigDNSSECValidateException.validateJsonElement(jsonArraydnssecValidateExceptions.get(i));
          };
        }
      }
      // validate the optional field `dtc_config`
      if (jsonObj.get("dtc_config") != null && !jsonObj.get("dtc_config").isJsonNull()) {
        ConfigDTCConfig.validateJsonElement(jsonObj.get("dtc_config"));
      }
      if (jsonObj.get("ecs_zones") != null && !jsonObj.get("ecs_zones").isJsonNull()) {
        JsonArray jsonArrayecsZones = jsonObj.getAsJsonArray("ecs_zones");
        if (jsonArrayecsZones != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ecs_zones").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ecs_zones` to be an array in the JSON string but got `%s`", jsonObj.get("ecs_zones").toString()));
          }

          // validate the optional field `ecs_zones` (array)
          for (int i = 0; i < jsonArrayecsZones.size(); i++) {
            ConfigECSZone.validateJsonElement(jsonArrayecsZones.get(i));
          };
        }
      }
      if (jsonObj.get("filter_aaaa_acl") != null && !jsonObj.get("filter_aaaa_acl").isJsonNull()) {
        JsonArray jsonArrayfilterAaaaAcl = jsonObj.getAsJsonArray("filter_aaaa_acl");
        if (jsonArrayfilterAaaaAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("filter_aaaa_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `filter_aaaa_acl` to be an array in the JSON string but got `%s`", jsonObj.get("filter_aaaa_acl").toString()));
          }

          // validate the optional field `filter_aaaa_acl` (array)
          for (int i = 0; i < jsonArrayfilterAaaaAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayfilterAaaaAcl.get(i));
          };
        }
      }
      if ((jsonObj.get("filter_aaaa_on_v4") != null && !jsonObj.get("filter_aaaa_on_v4").isJsonNull()) && !jsonObj.get("filter_aaaa_on_v4").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filter_aaaa_on_v4` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filter_aaaa_on_v4").toString()));
      }
      if (jsonObj.get("forwarders") != null && !jsonObj.get("forwarders").isJsonNull()) {
        JsonArray jsonArrayforwarders = jsonObj.getAsJsonArray("forwarders");
        if (jsonArrayforwarders != null) {
          // ensure the json data is an array
          if (!jsonObj.get("forwarders").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `forwarders` to be an array in the JSON string but got `%s`", jsonObj.get("forwarders").toString()));
          }

          // validate the optional field `forwarders` (array)
          for (int i = 0; i < jsonArrayforwarders.size(); i++) {
            ConfigForwarder.validateJsonElement(jsonArrayforwarders.get(i));
          };
        }
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `inheritance_sources`
      if (jsonObj.get("inheritance_sources") != null && !jsonObj.get("inheritance_sources").isJsonNull()) {
        ConfigViewInheritance.validateJsonElement(jsonObj.get("inheritance_sources"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("ip_spaces") != null && !jsonObj.get("ip_spaces").isJsonNull() && !jsonObj.get("ip_spaces").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `ip_spaces` to be an array in the JSON string but got `%s`", jsonObj.get("ip_spaces").toString()));
      }
      if (jsonObj.get("match_clients_acl") != null && !jsonObj.get("match_clients_acl").isJsonNull()) {
        JsonArray jsonArraymatchClientsAcl = jsonObj.getAsJsonArray("match_clients_acl");
        if (jsonArraymatchClientsAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("match_clients_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `match_clients_acl` to be an array in the JSON string but got `%s`", jsonObj.get("match_clients_acl").toString()));
          }

          // validate the optional field `match_clients_acl` (array)
          for (int i = 0; i < jsonArraymatchClientsAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArraymatchClientsAcl.get(i));
          };
        }
      }
      if (jsonObj.get("match_destinations_acl") != null && !jsonObj.get("match_destinations_acl").isJsonNull()) {
        JsonArray jsonArraymatchDestinationsAcl = jsonObj.getAsJsonArray("match_destinations_acl");
        if (jsonArraymatchDestinationsAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("match_destinations_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `match_destinations_acl` to be an array in the JSON string but got `%s`", jsonObj.get("match_destinations_acl").toString()));
          }

          // validate the optional field `match_destinations_acl` (array)
          for (int i = 0; i < jsonArraymatchDestinationsAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArraymatchDestinationsAcl.get(i));
          };
        }
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if (jsonObj.get("query_acl") != null && !jsonObj.get("query_acl").isJsonNull()) {
        JsonArray jsonArrayqueryAcl = jsonObj.getAsJsonArray("query_acl");
        if (jsonArrayqueryAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("query_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `query_acl` to be an array in the JSON string but got `%s`", jsonObj.get("query_acl").toString()));
          }

          // validate the optional field `query_acl` (array)
          for (int i = 0; i < jsonArrayqueryAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayqueryAcl.get(i));
          };
        }
      }
      if (jsonObj.get("recursion_acl") != null && !jsonObj.get("recursion_acl").isJsonNull()) {
        JsonArray jsonArrayrecursionAcl = jsonObj.getAsJsonArray("recursion_acl");
        if (jsonArrayrecursionAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("recursion_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `recursion_acl` to be an array in the JSON string but got `%s`", jsonObj.get("recursion_acl").toString()));
          }

          // validate the optional field `recursion_acl` (array)
          for (int i = 0; i < jsonArrayrecursionAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayrecursionAcl.get(i));
          };
        }
      }
      if (jsonObj.get("sort_list") != null && !jsonObj.get("sort_list").isJsonNull()) {
        JsonArray jsonArraysortList = jsonObj.getAsJsonArray("sort_list");
        if (jsonArraysortList != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sort_list").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sort_list` to be an array in the JSON string but got `%s`", jsonObj.get("sort_list").toString()));
          }

          // validate the optional field `sort_list` (array)
          for (int i = 0; i < jsonArraysortList.size(); i++) {
            ConfigSortListItem.validateJsonElement(jsonArraysortList.get(i));
          };
        }
      }
      if (jsonObj.get("transfer_acl") != null && !jsonObj.get("transfer_acl").isJsonNull()) {
        JsonArray jsonArraytransferAcl = jsonObj.getAsJsonArray("transfer_acl");
        if (jsonArraytransferAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("transfer_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `transfer_acl` to be an array in the JSON string but got `%s`", jsonObj.get("transfer_acl").toString()));
          }

          // validate the optional field `transfer_acl` (array)
          for (int i = 0; i < jsonArraytransferAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArraytransferAcl.get(i));
          };
        }
      }
      if (jsonObj.get("update_acl") != null && !jsonObj.get("update_acl").isJsonNull()) {
        JsonArray jsonArrayupdateAcl = jsonObj.getAsJsonArray("update_acl");
        if (jsonArrayupdateAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("update_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `update_acl` to be an array in the JSON string but got `%s`", jsonObj.get("update_acl").toString()));
          }

          // validate the optional field `update_acl` (array)
          for (int i = 0; i < jsonArrayupdateAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayupdateAcl.get(i));
          };
        }
      }
      // validate the optional field `zone_authority`
      if (jsonObj.get("zone_authority") != null && !jsonObj.get("zone_authority").isJsonNull()) {
        ConfigZoneAuthority.validateJsonElement(jsonObj.get("zone_authority"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConfigView.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConfigView' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConfigView> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConfigView.class));

       return (TypeAdapter<T>) new TypeAdapter<ConfigView>() {
           @Override
           public void write(JsonWriter out, ConfigView value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ConfigView read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ConfigView given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ConfigView
   * @throws IOException if the JSON string is invalid with respect to ConfigView
   */
  public static ConfigView fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConfigView.class);
  }

  /**
   * Convert an instance of ConfigView to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

