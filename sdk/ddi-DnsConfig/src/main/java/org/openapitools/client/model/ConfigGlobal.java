/*
 * DNS Configuration API
 * The DNS application is a BloxOne DDI service that provides cloud-based DNS configuration with on-prem host serving DNS protocol. It is part of the full-featured BloxOne DDI solution that enables customers the ability to deploy large numbers of protocol servers in the delivery of DNS and DHCP throughout their enterprise network.   
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.ConfigACLItem;
import org.openapitools.client.model.ConfigDNSSECValidateException;
import org.openapitools.client.model.ConfigDTCConfig;
import org.openapitools.client.model.ConfigECSZone;
import org.openapitools.client.model.ConfigForwarder;
import org.openapitools.client.model.ConfigKerberosKey;
import org.openapitools.client.model.ConfigLoggingConfig;
import org.openapitools.client.model.ConfigRootNS;
import org.openapitools.client.model.ConfigSortListItem;
import org.openapitools.client.model.ConfigTrustAnchor;
import org.openapitools.client.model.ConfigZoneAuthority;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Global configuration (_dns/global_). Used by default unless more specific configuration exists. There is only one instance of this object.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:28.384903+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class ConfigGlobal {
  public static final String SERIALIZED_NAME_ACTIVE_SEARCH_ENABLE = "active_search_enable";
  @SerializedName(SERIALIZED_NAME_ACTIVE_SEARCH_ENABLE)
  @javax.annotation.Nullable
  private Boolean activeSearchEnable;

  public static final String SERIALIZED_NAME_ADD_EDNS_OPTION_IN_OUTGOING_QUERY = "add_edns_option_in_outgoing_query";
  @SerializedName(SERIALIZED_NAME_ADD_EDNS_OPTION_IN_OUTGOING_QUERY)
  @javax.annotation.Nullable
  private Boolean addEdnsOptionInOutgoingQuery;

  public static final String SERIALIZED_NAME_CUSTOM_ROOT_NS = "custom_root_ns";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ROOT_NS)
  @javax.annotation.Nullable
  private List<ConfigRootNS> customRootNs = new ArrayList<>();

  public static final String SERIALIZED_NAME_CUSTOM_ROOT_NS_ENABLED = "custom_root_ns_enabled";
  @SerializedName(SERIALIZED_NAME_CUSTOM_ROOT_NS_ENABLED)
  @javax.annotation.Nullable
  private Boolean customRootNsEnabled;

  public static final String SERIALIZED_NAME_DNSSEC_ENABLE_VALIDATION = "dnssec_enable_validation";
  @SerializedName(SERIALIZED_NAME_DNSSEC_ENABLE_VALIDATION)
  @javax.annotation.Nullable
  private Boolean dnssecEnableValidation;

  public static final String SERIALIZED_NAME_DNSSEC_ENABLED = "dnssec_enabled";
  @SerializedName(SERIALIZED_NAME_DNSSEC_ENABLED)
  @javax.annotation.Nullable
  private Boolean dnssecEnabled;

  public static final String SERIALIZED_NAME_DNSSEC_ROOT_KEYS = "dnssec_root_keys";
  @SerializedName(SERIALIZED_NAME_DNSSEC_ROOT_KEYS)
  @javax.annotation.Nullable
  private List<ConfigTrustAnchor> dnssecRootKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_DNSSEC_TRUST_ANCHORS = "dnssec_trust_anchors";
  @SerializedName(SERIALIZED_NAME_DNSSEC_TRUST_ANCHORS)
  @javax.annotation.Nullable
  private List<ConfigTrustAnchor> dnssecTrustAnchors = new ArrayList<>();

  public static final String SERIALIZED_NAME_DNSSEC_VALIDATE_EXCEPTIONS = "dnssec_validate_exceptions";
  @SerializedName(SERIALIZED_NAME_DNSSEC_VALIDATE_EXCEPTIONS)
  @javax.annotation.Nullable
  private List<ConfigDNSSECValidateException> dnssecValidateExceptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DNSSEC_VALIDATE_EXPIRY = "dnssec_validate_expiry";
  @SerializedName(SERIALIZED_NAME_DNSSEC_VALIDATE_EXPIRY)
  @javax.annotation.Nullable
  private Boolean dnssecValidateExpiry;

  public static final String SERIALIZED_NAME_DTC_CONFIG = "dtc_config";
  @SerializedName(SERIALIZED_NAME_DTC_CONFIG)
  @javax.annotation.Nullable
  private ConfigDTCConfig dtcConfig;

  public static final String SERIALIZED_NAME_ECS_ENABLED = "ecs_enabled";
  @SerializedName(SERIALIZED_NAME_ECS_ENABLED)
  @javax.annotation.Nullable
  private Boolean ecsEnabled;

  public static final String SERIALIZED_NAME_ECS_FORWARDING = "ecs_forwarding";
  @SerializedName(SERIALIZED_NAME_ECS_FORWARDING)
  @javax.annotation.Nullable
  private Boolean ecsForwarding;

  public static final String SERIALIZED_NAME_ECS_PREFIX_V4 = "ecs_prefix_v4";
  @SerializedName(SERIALIZED_NAME_ECS_PREFIX_V4)
  @javax.annotation.Nullable
  private Long ecsPrefixV4;

  public static final String SERIALIZED_NAME_ECS_PREFIX_V6 = "ecs_prefix_v6";
  @SerializedName(SERIALIZED_NAME_ECS_PREFIX_V6)
  @javax.annotation.Nullable
  private Long ecsPrefixV6;

  public static final String SERIALIZED_NAME_ECS_ZONES = "ecs_zones";
  @SerializedName(SERIALIZED_NAME_ECS_ZONES)
  @javax.annotation.Nullable
  private List<ConfigECSZone> ecsZones = new ArrayList<>();

  public static final String SERIALIZED_NAME_EDNS_UDP_SIZE = "edns_udp_size";
  @SerializedName(SERIALIZED_NAME_EDNS_UDP_SIZE)
  @javax.annotation.Nullable
  private Long ednsUdpSize;

  public static final String SERIALIZED_NAME_FILTER_AAAA_ACL = "filter_aaaa_acl";
  @SerializedName(SERIALIZED_NAME_FILTER_AAAA_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> filterAaaaAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_FILTER_AAAA_ON_V4 = "filter_aaaa_on_v4";
  @SerializedName(SERIALIZED_NAME_FILTER_AAAA_ON_V4)
  @javax.annotation.Nullable
  private String filterAaaaOnV4;

  public static final String SERIALIZED_NAME_FORWARDERS = "forwarders";
  @SerializedName(SERIALIZED_NAME_FORWARDERS)
  @javax.annotation.Nullable
  private List<ConfigForwarder> forwarders = new ArrayList<>();

  public static final String SERIALIZED_NAME_FORWARDERS_ONLY = "forwarders_only";
  @SerializedName(SERIALIZED_NAME_FORWARDERS_ONLY)
  @javax.annotation.Nullable
  private Boolean forwardersOnly;

  public static final String SERIALIZED_NAME_GSS_TSIG_ENABLED = "gss_tsig_enabled";
  @SerializedName(SERIALIZED_NAME_GSS_TSIG_ENABLED)
  @javax.annotation.Nullable
  private Boolean gssTsigEnabled;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nonnull
  private String id;

  public static final String SERIALIZED_NAME_KERBEROS_KEYS = "kerberos_keys";
  @SerializedName(SERIALIZED_NAME_KERBEROS_KEYS)
  @javax.annotation.Nullable
  private List<ConfigKerberosKey> kerberosKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_LAME_TTL = "lame_ttl";
  @SerializedName(SERIALIZED_NAME_LAME_TTL)
  @javax.annotation.Nullable
  private Long lameTtl;

  public static final String SERIALIZED_NAME_LOG_QUERY_RESPONSE = "log_query_response";
  @SerializedName(SERIALIZED_NAME_LOG_QUERY_RESPONSE)
  @javax.annotation.Nullable
  private Boolean logQueryResponse;

  public static final String SERIALIZED_NAME_LOGGING_CONFIGURATION = "logging_configuration";
  @SerializedName(SERIALIZED_NAME_LOGGING_CONFIGURATION)
  @javax.annotation.Nullable
  private ConfigLoggingConfig loggingConfiguration;

  public static final String SERIALIZED_NAME_MATCH_RECURSIVE_ONLY = "match_recursive_only";
  @SerializedName(SERIALIZED_NAME_MATCH_RECURSIVE_ONLY)
  @javax.annotation.Nullable
  private Boolean matchRecursiveOnly;

  public static final String SERIALIZED_NAME_MAX_CACHE_TTL = "max_cache_ttl";
  @SerializedName(SERIALIZED_NAME_MAX_CACHE_TTL)
  @javax.annotation.Nullable
  private Long maxCacheTtl;

  public static final String SERIALIZED_NAME_MAX_NEGATIVE_TTL = "max_negative_ttl";
  @SerializedName(SERIALIZED_NAME_MAX_NEGATIVE_TTL)
  @javax.annotation.Nullable
  private Long maxNegativeTtl;

  public static final String SERIALIZED_NAME_MAX_UDP_SIZE = "max_udp_size";
  @SerializedName(SERIALIZED_NAME_MAX_UDP_SIZE)
  @javax.annotation.Nullable
  private Long maxUdpSize;

  public static final String SERIALIZED_NAME_MINIMAL_RESPONSES = "minimal_responses";
  @SerializedName(SERIALIZED_NAME_MINIMAL_RESPONSES)
  @javax.annotation.Nullable
  private Boolean minimalResponses;

  public static final String SERIALIZED_NAME_NOTIFY = "notify";
  @SerializedName(SERIALIZED_NAME_NOTIFY)
  @javax.annotation.Nullable
  private Boolean notify;

  public static final String SERIALIZED_NAME_QUERY_ACL = "query_acl";
  @SerializedName(SERIALIZED_NAME_QUERY_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> queryAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_QUERY_PORT = "query_port";
  @SerializedName(SERIALIZED_NAME_QUERY_PORT)
  @javax.annotation.Nullable
  private Long queryPort;

  public static final String SERIALIZED_NAME_RECURSION_ACL = "recursion_acl";
  @SerializedName(SERIALIZED_NAME_RECURSION_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> recursionAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_RECURSION_ENABLED = "recursion_enabled";
  @SerializedName(SERIALIZED_NAME_RECURSION_ENABLED)
  @javax.annotation.Nullable
  private Boolean recursionEnabled;

  public static final String SERIALIZED_NAME_RECURSIVE_CLIENTS = "recursive_clients";
  @SerializedName(SERIALIZED_NAME_RECURSIVE_CLIENTS)
  @javax.annotation.Nullable
  private Long recursiveClients;

  public static final String SERIALIZED_NAME_RESOLVER_QUERY_TIMEOUT = "resolver_query_timeout";
  @SerializedName(SERIALIZED_NAME_RESOLVER_QUERY_TIMEOUT)
  @javax.annotation.Nullable
  private Long resolverQueryTimeout;

  public static final String SERIALIZED_NAME_SECONDARY_AXFR_QUERY_LIMIT = "secondary_axfr_query_limit";
  @SerializedName(SERIALIZED_NAME_SECONDARY_AXFR_QUERY_LIMIT)
  @javax.annotation.Nullable
  private Long secondaryAxfrQueryLimit;

  public static final String SERIALIZED_NAME_SECONDARY_SOA_QUERY_LIMIT = "secondary_soa_query_limit";
  @SerializedName(SERIALIZED_NAME_SECONDARY_SOA_QUERY_LIMIT)
  @javax.annotation.Nullable
  private Long secondarySoaQueryLimit;

  public static final String SERIALIZED_NAME_SORT_LIST = "sort_list";
  @SerializedName(SERIALIZED_NAME_SORT_LIST)
  @javax.annotation.Nullable
  private List<ConfigSortListItem> sortList = new ArrayList<>();

  public static final String SERIALIZED_NAME_SYNTHESIZE_ADDRESS_RECORDS_FROM_HTTPS = "synthesize_address_records_from_https";
  @SerializedName(SERIALIZED_NAME_SYNTHESIZE_ADDRESS_RECORDS_FROM_HTTPS)
  @javax.annotation.Nullable
  private Boolean synthesizeAddressRecordsFromHttps;

  public static final String SERIALIZED_NAME_TRANSFER_ACL = "transfer_acl";
  @SerializedName(SERIALIZED_NAME_TRANSFER_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> transferAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_UPDATE_ACL = "update_acl";
  @SerializedName(SERIALIZED_NAME_UPDATE_ACL)
  @javax.annotation.Nullable
  private List<ConfigACLItem> updateAcl = new ArrayList<>();

  public static final String SERIALIZED_NAME_USE_FORWARDERS_FOR_SUBZONES = "use_forwarders_for_subzones";
  @SerializedName(SERIALIZED_NAME_USE_FORWARDERS_FOR_SUBZONES)
  @javax.annotation.Nullable
  private Boolean useForwardersForSubzones;

  public static final String SERIALIZED_NAME_USE_ROOT_FORWARDERS_FOR_LOCAL_RESOLUTION_WITH_B1TD = "use_root_forwarders_for_local_resolution_with_b1td";
  @SerializedName(SERIALIZED_NAME_USE_ROOT_FORWARDERS_FOR_LOCAL_RESOLUTION_WITH_B1TD)
  @javax.annotation.Nullable
  private Boolean useRootForwardersForLocalResolutionWithB1td;

  public static final String SERIALIZED_NAME_ZONE_AUTHORITY = "zone_authority";
  @SerializedName(SERIALIZED_NAME_ZONE_AUTHORITY)
  @javax.annotation.Nullable
  private ConfigZoneAuthority zoneAuthority;

  public ConfigGlobal() {
  }

  public ConfigGlobal(
     List<ConfigTrustAnchor> dnssecRootKeys, 
     String id
  ) {
    this();
    this.dnssecRootKeys = dnssecRootKeys;
    this.id = id;
  }

  public ConfigGlobal activeSearchEnable(@javax.annotation.Nullable Boolean activeSearchEnable) {
    this.activeSearchEnable = activeSearchEnable;
    return this;
  }

  /**
   * Determines if \&quot;30 Day Active Search\&quot; feature is enabled or not.
   * @return activeSearchEnable
   */
  @javax.annotation.Nullable
  public Boolean getActiveSearchEnable() {
    return activeSearchEnable;
  }

  public void setActiveSearchEnable(@javax.annotation.Nullable Boolean activeSearchEnable) {
    this.activeSearchEnable = activeSearchEnable;
  }


  public ConfigGlobal addEdnsOptionInOutgoingQuery(@javax.annotation.Nullable Boolean addEdnsOptionInOutgoingQuery) {
    this.addEdnsOptionInOutgoingQuery = addEdnsOptionInOutgoingQuery;
    return this;
  }

  /**
   * _add_edns_option_in_outgoing_query_ adds client IP, MAC address and view name into outgoing recursive query. Defaults to _false_.
   * @return addEdnsOptionInOutgoingQuery
   */
  @javax.annotation.Nullable
  public Boolean getAddEdnsOptionInOutgoingQuery() {
    return addEdnsOptionInOutgoingQuery;
  }

  public void setAddEdnsOptionInOutgoingQuery(@javax.annotation.Nullable Boolean addEdnsOptionInOutgoingQuery) {
    this.addEdnsOptionInOutgoingQuery = addEdnsOptionInOutgoingQuery;
  }


  public ConfigGlobal customRootNs(@javax.annotation.Nullable List<ConfigRootNS> customRootNs) {
    this.customRootNs = customRootNs;
    return this;
  }

  public ConfigGlobal addCustomRootNsItem(ConfigRootNS customRootNsItem) {
    if (this.customRootNs == null) {
      this.customRootNs = new ArrayList<>();
    }
    this.customRootNs.add(customRootNsItem);
    return this;
  }

  /**
   * Optional. List of custom root nameservers. The order does not matter.  Error if empty while _custom_root_ns_enabled_ is _true_. Error if there are duplicate items in the list.  Defaults to empty.
   * @return customRootNs
   */
  @javax.annotation.Nullable
  public List<ConfigRootNS> getCustomRootNs() {
    return customRootNs;
  }

  public void setCustomRootNs(@javax.annotation.Nullable List<ConfigRootNS> customRootNs) {
    this.customRootNs = customRootNs;
  }


  public ConfigGlobal customRootNsEnabled(@javax.annotation.Nullable Boolean customRootNsEnabled) {
    this.customRootNsEnabled = customRootNsEnabled;
    return this;
  }

  /**
   * Optional. _true_ to use custom root nameservers instead of the default ones.  The _custom_root_ns_ field is validated when enabled.  Defaults to false.
   * @return customRootNsEnabled
   */
  @javax.annotation.Nullable
  public Boolean getCustomRootNsEnabled() {
    return customRootNsEnabled;
  }

  public void setCustomRootNsEnabled(@javax.annotation.Nullable Boolean customRootNsEnabled) {
    this.customRootNsEnabled = customRootNsEnabled;
  }


  public ConfigGlobal dnssecEnableValidation(@javax.annotation.Nullable Boolean dnssecEnableValidation) {
    this.dnssecEnableValidation = dnssecEnableValidation;
    return this;
  }

  /**
   * Optional. _true_ to perform DNSSEC validation. Ignored if _dnssec_enabled_ is _false_.  Defaults to _true_.
   * @return dnssecEnableValidation
   */
  @javax.annotation.Nullable
  public Boolean getDnssecEnableValidation() {
    return dnssecEnableValidation;
  }

  public void setDnssecEnableValidation(@javax.annotation.Nullable Boolean dnssecEnableValidation) {
    this.dnssecEnableValidation = dnssecEnableValidation;
  }


  public ConfigGlobal dnssecEnabled(@javax.annotation.Nullable Boolean dnssecEnabled) {
    this.dnssecEnabled = dnssecEnabled;
    return this;
  }

  /**
   * Optional. Master toggle for all DNSSEC processing. Other _dnssec_*_ configuration is unused if this is disabled.  Defaults to _true_.
   * @return dnssecEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDnssecEnabled() {
    return dnssecEnabled;
  }

  public void setDnssecEnabled(@javax.annotation.Nullable Boolean dnssecEnabled) {
    this.dnssecEnabled = dnssecEnabled;
  }


  /**
   * DNSSEC root keys. The root keys are not configurable.  A default list is provided by cloud management and included here for config generation.
   * @return dnssecRootKeys
   */
  @javax.annotation.Nullable
  public List<ConfigTrustAnchor> getDnssecRootKeys() {
    return dnssecRootKeys;
  }



  public ConfigGlobal dnssecTrustAnchors(@javax.annotation.Nullable List<ConfigTrustAnchor> dnssecTrustAnchors) {
    this.dnssecTrustAnchors = dnssecTrustAnchors;
    return this;
  }

  public ConfigGlobal addDnssecTrustAnchorsItem(ConfigTrustAnchor dnssecTrustAnchorsItem) {
    if (this.dnssecTrustAnchors == null) {
      this.dnssecTrustAnchors = new ArrayList<>();
    }
    this.dnssecTrustAnchors.add(dnssecTrustAnchorsItem);
    return this;
  }

  /**
   * Optional. DNSSEC trust anchors.  Error if there are list items with duplicate (_zone_, _sep_, _algorithm_) combinations.  Defaults to empty.
   * @return dnssecTrustAnchors
   */
  @javax.annotation.Nullable
  public List<ConfigTrustAnchor> getDnssecTrustAnchors() {
    return dnssecTrustAnchors;
  }

  public void setDnssecTrustAnchors(@javax.annotation.Nullable List<ConfigTrustAnchor> dnssecTrustAnchors) {
    this.dnssecTrustAnchors = dnssecTrustAnchors;
  }


  public ConfigGlobal dnssecValidateExceptions(@javax.annotation.Nullable List<ConfigDNSSECValidateException> dnssecValidateExceptions) {
    this.dnssecValidateExceptions = dnssecValidateExceptions;
    return this;
  }

  public ConfigGlobal addDnssecValidateExceptionsItem(ConfigDNSSECValidateException dnssecValidateExceptionsItem) {
    if (this.dnssecValidateExceptions == null) {
      this.dnssecValidateExceptions = new ArrayList<>();
    }
    this.dnssecValidateExceptions.add(dnssecValidateExceptionsItem);
    return this;
  }

  /**
   * Optional. DNSSEC validate exceptions.  Error if there are duplicate exception domains (compared as a DNS name including case-insensitive comparison).  Defaults to empty.
   * @return dnssecValidateExceptions
   */
  @javax.annotation.Nullable
  public List<ConfigDNSSECValidateException> getDnssecValidateExceptions() {
    return dnssecValidateExceptions;
  }

  public void setDnssecValidateExceptions(@javax.annotation.Nullable List<ConfigDNSSECValidateException> dnssecValidateExceptions) {
    this.dnssecValidateExceptions = dnssecValidateExceptions;
  }


  public ConfigGlobal dnssecValidateExpiry(@javax.annotation.Nullable Boolean dnssecValidateExpiry) {
    this.dnssecValidateExpiry = dnssecValidateExpiry;
    return this;
  }

  /**
   * Optional. _true_ to reject expired DNSSEC keys. Ignored if either _dnssec_enabled_ or _dnssec_enable_validation_ is _false_.  Defaults to _true_.
   * @return dnssecValidateExpiry
   */
  @javax.annotation.Nullable
  public Boolean getDnssecValidateExpiry() {
    return dnssecValidateExpiry;
  }

  public void setDnssecValidateExpiry(@javax.annotation.Nullable Boolean dnssecValidateExpiry) {
    this.dnssecValidateExpiry = dnssecValidateExpiry;
  }


  public ConfigGlobal dtcConfig(@javax.annotation.Nullable ConfigDTCConfig dtcConfig) {
    this.dtcConfig = dtcConfig;
    return this;
  }

  /**
   * Get dtcConfig
   * @return dtcConfig
   */
  @javax.annotation.Nullable
  public ConfigDTCConfig getDtcConfig() {
    return dtcConfig;
  }

  public void setDtcConfig(@javax.annotation.Nullable ConfigDTCConfig dtcConfig) {
    this.dtcConfig = dtcConfig;
  }


  public ConfigGlobal ecsEnabled(@javax.annotation.Nullable Boolean ecsEnabled) {
    this.ecsEnabled = ecsEnabled;
    return this;
  }

  /**
   * Optional. _true_ to enable EDNS client subnet for recursive queries. Other _ecs_*_ fields are ignored if this field is not enabled.  Defaults to _false_.
   * @return ecsEnabled
   */
  @javax.annotation.Nullable
  public Boolean getEcsEnabled() {
    return ecsEnabled;
  }

  public void setEcsEnabled(@javax.annotation.Nullable Boolean ecsEnabled) {
    this.ecsEnabled = ecsEnabled;
  }


  public ConfigGlobal ecsForwarding(@javax.annotation.Nullable Boolean ecsForwarding) {
    this.ecsForwarding = ecsForwarding;
    return this;
  }

  /**
   * Optional. _true_ to enable ECS options in outbound queries. This functionality has additional overhead so it is disabled by default.  Defaults to _false_.
   * @return ecsForwarding
   */
  @javax.annotation.Nullable
  public Boolean getEcsForwarding() {
    return ecsForwarding;
  }

  public void setEcsForwarding(@javax.annotation.Nullable Boolean ecsForwarding) {
    this.ecsForwarding = ecsForwarding;
  }


  public ConfigGlobal ecsPrefixV4(@javax.annotation.Nullable Long ecsPrefixV4) {
    this.ecsPrefixV4 = ecsPrefixV4;
    return this;
  }

  /**
   * Optional. Maximum scope length for v4 ECS.  Unsigned integer, min 1 max 24.  Defaults to 24.
   * @return ecsPrefixV4
   */
  @javax.annotation.Nullable
  public Long getEcsPrefixV4() {
    return ecsPrefixV4;
  }

  public void setEcsPrefixV4(@javax.annotation.Nullable Long ecsPrefixV4) {
    this.ecsPrefixV4 = ecsPrefixV4;
  }


  public ConfigGlobal ecsPrefixV6(@javax.annotation.Nullable Long ecsPrefixV6) {
    this.ecsPrefixV6 = ecsPrefixV6;
    return this;
  }

  /**
   * Optional. Maximum scope length for v6 ECS.  Unsigned integer, min 1 max 56.  Defaults to 56.
   * @return ecsPrefixV6
   */
  @javax.annotation.Nullable
  public Long getEcsPrefixV6() {
    return ecsPrefixV6;
  }

  public void setEcsPrefixV6(@javax.annotation.Nullable Long ecsPrefixV6) {
    this.ecsPrefixV6 = ecsPrefixV6;
  }


  public ConfigGlobal ecsZones(@javax.annotation.Nullable List<ConfigECSZone> ecsZones) {
    this.ecsZones = ecsZones;
    return this;
  }

  public ConfigGlobal addEcsZonesItem(ConfigECSZone ecsZonesItem) {
    if (this.ecsZones == null) {
      this.ecsZones = new ArrayList<>();
    }
    this.ecsZones.add(ecsZonesItem);
    return this;
  }

  /**
   * Optional. List of zones where ECS queries may be sent.  Error if empty while _ecs_enabled_ is true. Error if there are duplicate FQDNs in the list.  Defaults to empty.
   * @return ecsZones
   */
  @javax.annotation.Nullable
  public List<ConfigECSZone> getEcsZones() {
    return ecsZones;
  }

  public void setEcsZones(@javax.annotation.Nullable List<ConfigECSZone> ecsZones) {
    this.ecsZones = ecsZones;
  }


  public ConfigGlobal ednsUdpSize(@javax.annotation.Nullable Long ednsUdpSize) {
    this.ednsUdpSize = ednsUdpSize;
    return this;
  }

  /**
   * Optional. _edns_udp_size_ represents the edns UDP size. The size a querying DNS server advertises to the DNS server itâ€™s sending a query to.  Defaults to 1232 bytes.
   * @return ednsUdpSize
   */
  @javax.annotation.Nullable
  public Long getEdnsUdpSize() {
    return ednsUdpSize;
  }

  public void setEdnsUdpSize(@javax.annotation.Nullable Long ednsUdpSize) {
    this.ednsUdpSize = ednsUdpSize;
  }


  public ConfigGlobal filterAaaaAcl(@javax.annotation.Nullable List<ConfigACLItem> filterAaaaAcl) {
    this.filterAaaaAcl = filterAaaaAcl;
    return this;
  }

  public ConfigGlobal addFilterAaaaAclItem(ConfigACLItem filterAaaaAclItem) {
    if (this.filterAaaaAcl == null) {
      this.filterAaaaAcl = new ArrayList<>();
    }
    this.filterAaaaAcl.add(filterAaaaAclItem);
    return this;
  }

  /**
   * Optional. Specifies a list of client addresses for which AAAA filtering is to be applied.  Defaults to _empty_.
   * @return filterAaaaAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getFilterAaaaAcl() {
    return filterAaaaAcl;
  }

  public void setFilterAaaaAcl(@javax.annotation.Nullable List<ConfigACLItem> filterAaaaAcl) {
    this.filterAaaaAcl = filterAaaaAcl;
  }


  public ConfigGlobal filterAaaaOnV4(@javax.annotation.Nullable String filterAaaaOnV4) {
    this.filterAaaaOnV4 = filterAaaaOnV4;
    return this;
  }

  /**
   * _filter_aaaa_on_v4_ allows named to omit some IPv6 addresses when responding to IPv4 clients.  Allowed values: * _yes_, * _no_, * _break_dnssec_.  Defaults to _no_
   * @return filterAaaaOnV4
   */
  @javax.annotation.Nullable
  public String getFilterAaaaOnV4() {
    return filterAaaaOnV4;
  }

  public void setFilterAaaaOnV4(@javax.annotation.Nullable String filterAaaaOnV4) {
    this.filterAaaaOnV4 = filterAaaaOnV4;
  }


  public ConfigGlobal forwarders(@javax.annotation.Nullable List<ConfigForwarder> forwarders) {
    this.forwarders = forwarders;
    return this;
  }

  public ConfigGlobal addForwardersItem(ConfigForwarder forwardersItem) {
    if (this.forwarders == null) {
      this.forwarders = new ArrayList<>();
    }
    this.forwarders.add(forwardersItem);
    return this;
  }

  /**
   * Optional. List of forwarders.  Error if empty while _forwarders_only_ or _use_root_forwarders_for_local_resolution_with_b1td_ is _true_. Error if there are items in the list with duplicate addresses.  Defaults to empty.
   * @return forwarders
   */
  @javax.annotation.Nullable
  public List<ConfigForwarder> getForwarders() {
    return forwarders;
  }

  public void setForwarders(@javax.annotation.Nullable List<ConfigForwarder> forwarders) {
    this.forwarders = forwarders;
  }


  public ConfigGlobal forwardersOnly(@javax.annotation.Nullable Boolean forwardersOnly) {
    this.forwardersOnly = forwardersOnly;
    return this;
  }

  /**
   * Optional. _true_ to only forward.  Defaults to _false_.
   * @return forwardersOnly
   */
  @javax.annotation.Nullable
  public Boolean getForwardersOnly() {
    return forwardersOnly;
  }

  public void setForwardersOnly(@javax.annotation.Nullable Boolean forwardersOnly) {
    this.forwardersOnly = forwardersOnly;
  }


  public ConfigGlobal gssTsigEnabled(@javax.annotation.Nullable Boolean gssTsigEnabled) {
    this.gssTsigEnabled = gssTsigEnabled;
    return this;
  }

  /**
   * _gss_tsig_enabled_ enables/disables GSS-TSIG signed dynamic updates.  Defaults to _false_.
   * @return gssTsigEnabled
   */
  @javax.annotation.Nullable
  public Boolean getGssTsigEnabled() {
    return gssTsigEnabled;
  }

  public void setGssTsigEnabled(@javax.annotation.Nullable Boolean gssTsigEnabled) {
    this.gssTsigEnabled = gssTsigEnabled;
  }


  /**
   * The resource identifier.
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }



  public ConfigGlobal kerberosKeys(@javax.annotation.Nullable List<ConfigKerberosKey> kerberosKeys) {
    this.kerberosKeys = kerberosKeys;
    return this;
  }

  public ConfigGlobal addKerberosKeysItem(ConfigKerberosKey kerberosKeysItem) {
    if (this.kerberosKeys == null) {
      this.kerberosKeys = new ArrayList<>();
    }
    this.kerberosKeys.add(kerberosKeysItem);
    return this;
  }

  /**
   * _kerberos_keys_ contains a list of keys for GSS-TSIG signed dynamic updates.  Defaults to empty.
   * @return kerberosKeys
   */
  @javax.annotation.Nullable
  public List<ConfigKerberosKey> getKerberosKeys() {
    return kerberosKeys;
  }

  public void setKerberosKeys(@javax.annotation.Nullable List<ConfigKerberosKey> kerberosKeys) {
    this.kerberosKeys = kerberosKeys;
  }


  public ConfigGlobal lameTtl(@javax.annotation.Nullable Long lameTtl) {
    this.lameTtl = lameTtl;
    return this;
  }

  /**
   * Optional. Unused in the current on-prem DNS server implementation.  Unsigned integer, min 0 max 3600 (1h).  Defaults to 600.
   * @return lameTtl
   */
  @javax.annotation.Nullable
  public Long getLameTtl() {
    return lameTtl;
  }

  public void setLameTtl(@javax.annotation.Nullable Long lameTtl) {
    this.lameTtl = lameTtl;
  }


  public ConfigGlobal logQueryResponse(@javax.annotation.Nullable Boolean logQueryResponse) {
    this.logQueryResponse = logQueryResponse;
    return this;
  }

  /**
   * Optional. Control DNS query/response logging functionality.  Defaults to _true_.
   * @return logQueryResponse
   */
  @javax.annotation.Nullable
  public Boolean getLogQueryResponse() {
    return logQueryResponse;
  }

  public void setLogQueryResponse(@javax.annotation.Nullable Boolean logQueryResponse) {
    this.logQueryResponse = logQueryResponse;
  }


  public ConfigGlobal loggingConfiguration(@javax.annotation.Nullable ConfigLoggingConfig loggingConfiguration) {
    this.loggingConfiguration = loggingConfiguration;
    return this;
  }

  /**
   * Get loggingConfiguration
   * @return loggingConfiguration
   */
  @javax.annotation.Nullable
  public ConfigLoggingConfig getLoggingConfiguration() {
    return loggingConfiguration;
  }

  public void setLoggingConfiguration(@javax.annotation.Nullable ConfigLoggingConfig loggingConfiguration) {
    this.loggingConfiguration = loggingConfiguration;
  }


  public ConfigGlobal matchRecursiveOnly(@javax.annotation.Nullable Boolean matchRecursiveOnly) {
    this.matchRecursiveOnly = matchRecursiveOnly;
    return this;
  }

  /**
   * Optional. If _true_ only recursive queries from matching clients access the view.  Defaults to _false_.
   * @return matchRecursiveOnly
   */
  @javax.annotation.Nullable
  public Boolean getMatchRecursiveOnly() {
    return matchRecursiveOnly;
  }

  public void setMatchRecursiveOnly(@javax.annotation.Nullable Boolean matchRecursiveOnly) {
    this.matchRecursiveOnly = matchRecursiveOnly;
  }


  public ConfigGlobal maxCacheTtl(@javax.annotation.Nullable Long maxCacheTtl) {
    this.maxCacheTtl = maxCacheTtl;
    return this;
  }

  /**
   * Optional. Seconds to cache positive responses.  Unsigned integer, min 1 max 604800 (7d).  Defaults to 604800 (7d).
   * @return maxCacheTtl
   */
  @javax.annotation.Nullable
  public Long getMaxCacheTtl() {
    return maxCacheTtl;
  }

  public void setMaxCacheTtl(@javax.annotation.Nullable Long maxCacheTtl) {
    this.maxCacheTtl = maxCacheTtl;
  }


  public ConfigGlobal maxNegativeTtl(@javax.annotation.Nullable Long maxNegativeTtl) {
    this.maxNegativeTtl = maxNegativeTtl;
    return this;
  }

  /**
   * Optional. Seconds to cache negative responses.  Unsigned integer, min 1 max 604800 (7d).  Defaults to 10800 (3h).
   * @return maxNegativeTtl
   */
  @javax.annotation.Nullable
  public Long getMaxNegativeTtl() {
    return maxNegativeTtl;
  }

  public void setMaxNegativeTtl(@javax.annotation.Nullable Long maxNegativeTtl) {
    this.maxNegativeTtl = maxNegativeTtl;
  }


  public ConfigGlobal maxUdpSize(@javax.annotation.Nullable Long maxUdpSize) {
    this.maxUdpSize = maxUdpSize;
    return this;
  }

  /**
   * Optional. _max_udp_size_ represents maximum UDP payload size. The maximum number of bytes a responding DNS server will send to a UDP datagram.  Defaults to 1232 bytes.
   * @return maxUdpSize
   */
  @javax.annotation.Nullable
  public Long getMaxUdpSize() {
    return maxUdpSize;
  }

  public void setMaxUdpSize(@javax.annotation.Nullable Long maxUdpSize) {
    this.maxUdpSize = maxUdpSize;
  }


  public ConfigGlobal minimalResponses(@javax.annotation.Nullable Boolean minimalResponses) {
    this.minimalResponses = minimalResponses;
    return this;
  }

  /**
   * Optional. When enabled, the DNS server will only add records to the authority and additional data sections when they are required.  Defaults to _false_.
   * @return minimalResponses
   */
  @javax.annotation.Nullable
  public Boolean getMinimalResponses() {
    return minimalResponses;
  }

  public void setMinimalResponses(@javax.annotation.Nullable Boolean minimalResponses) {
    this.minimalResponses = minimalResponses;
  }


  public ConfigGlobal notify(@javax.annotation.Nullable Boolean notify) {
    this.notify = notify;
    return this;
  }

  /**
   * _notify_ all external secondary DNS servers.  Defaults to _false_.
   * @return notify
   */
  @javax.annotation.Nullable
  public Boolean getNotify() {
    return notify;
  }

  public void setNotify(@javax.annotation.Nullable Boolean notify) {
    this.notify = notify;
  }


  public ConfigGlobal queryAcl(@javax.annotation.Nullable List<ConfigACLItem> queryAcl) {
    this.queryAcl = queryAcl;
    return this;
  }

  public ConfigGlobal addQueryAclItem(ConfigACLItem queryAclItem) {
    if (this.queryAcl == null) {
      this.queryAcl = new ArrayList<>();
    }
    this.queryAcl.add(queryAclItem);
    return this;
  }

  /**
   * Optional. Clients must match this ACL to make authoritative queries. Also used for recursive queries if that ACL is unset.  Defaults to empty.
   * @return queryAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getQueryAcl() {
    return queryAcl;
  }

  public void setQueryAcl(@javax.annotation.Nullable List<ConfigACLItem> queryAcl) {
    this.queryAcl = queryAcl;
  }


  public ConfigGlobal queryPort(@javax.annotation.Nullable Long queryPort) {
    this.queryPort = queryPort;
    return this;
  }

  /**
   * Optional. Source port for outbound DNS queries. When set to 0 the port is unspecified and the implementation may randomize it using any available ports.  Defaults to 0.
   * @return queryPort
   */
  @javax.annotation.Nullable
  public Long getQueryPort() {
    return queryPort;
  }

  public void setQueryPort(@javax.annotation.Nullable Long queryPort) {
    this.queryPort = queryPort;
  }


  public ConfigGlobal recursionAcl(@javax.annotation.Nullable List<ConfigACLItem> recursionAcl) {
    this.recursionAcl = recursionAcl;
    return this;
  }

  public ConfigGlobal addRecursionAclItem(ConfigACLItem recursionAclItem) {
    if (this.recursionAcl == null) {
      this.recursionAcl = new ArrayList<>();
    }
    this.recursionAcl.add(recursionAclItem);
    return this;
  }

  /**
   * Optional. Clients must match this ACL to make recursive queries. If this ACL is empty, then the _query_acl_ field will be used instead.  Defaults to empty.
   * @return recursionAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getRecursionAcl() {
    return recursionAcl;
  }

  public void setRecursionAcl(@javax.annotation.Nullable List<ConfigACLItem> recursionAcl) {
    this.recursionAcl = recursionAcl;
  }


  public ConfigGlobal recursionEnabled(@javax.annotation.Nullable Boolean recursionEnabled) {
    this.recursionEnabled = recursionEnabled;
    return this;
  }

  /**
   * Optional. _true_ to allow recursive DNS queries.  Defaults to _true_.
   * @return recursionEnabled
   */
  @javax.annotation.Nullable
  public Boolean getRecursionEnabled() {
    return recursionEnabled;
  }

  public void setRecursionEnabled(@javax.annotation.Nullable Boolean recursionEnabled) {
    this.recursionEnabled = recursionEnabled;
  }


  public ConfigGlobal recursiveClients(@javax.annotation.Nullable Long recursiveClients) {
    this.recursiveClients = recursiveClients;
    return this;
  }

  /**
   * Optional. Defines the number of simultaneous recursive lookups the server will perform on behalf of its clients.  Defaults to 1000.
   * @return recursiveClients
   */
  @javax.annotation.Nullable
  public Long getRecursiveClients() {
    return recursiveClients;
  }

  public void setRecursiveClients(@javax.annotation.Nullable Long recursiveClients) {
    this.recursiveClients = recursiveClients;
  }


  public ConfigGlobal resolverQueryTimeout(@javax.annotation.Nullable Long resolverQueryTimeout) {
    this.resolverQueryTimeout = resolverQueryTimeout;
    return this;
  }

  /**
   * Optional. Seconds before a recursive query times out.  Unsigned integer, min 10 max 30.  Defaults to 10.
   * @return resolverQueryTimeout
   */
  @javax.annotation.Nullable
  public Long getResolverQueryTimeout() {
    return resolverQueryTimeout;
  }

  public void setResolverQueryTimeout(@javax.annotation.Nullable Long resolverQueryTimeout) {
    this.resolverQueryTimeout = resolverQueryTimeout;
  }


  public ConfigGlobal secondaryAxfrQueryLimit(@javax.annotation.Nullable Long secondaryAxfrQueryLimit) {
    this.secondaryAxfrQueryLimit = secondaryAxfrQueryLimit;
    return this;
  }

  /**
   * Optional. Maximum concurrent inbound AXFRs. When set to 0 a host-dependent default will be used.  Defaults to 0.
   * @return secondaryAxfrQueryLimit
   */
  @javax.annotation.Nullable
  public Long getSecondaryAxfrQueryLimit() {
    return secondaryAxfrQueryLimit;
  }

  public void setSecondaryAxfrQueryLimit(@javax.annotation.Nullable Long secondaryAxfrQueryLimit) {
    this.secondaryAxfrQueryLimit = secondaryAxfrQueryLimit;
  }


  public ConfigGlobal secondarySoaQueryLimit(@javax.annotation.Nullable Long secondarySoaQueryLimit) {
    this.secondarySoaQueryLimit = secondarySoaQueryLimit;
    return this;
  }

  /**
   * Optional. Maximum concurrent outbound SOA queries. When set to 0 a host-dependent default will be used.  Defaults to 0.
   * @return secondarySoaQueryLimit
   */
  @javax.annotation.Nullable
  public Long getSecondarySoaQueryLimit() {
    return secondarySoaQueryLimit;
  }

  public void setSecondarySoaQueryLimit(@javax.annotation.Nullable Long secondarySoaQueryLimit) {
    this.secondarySoaQueryLimit = secondarySoaQueryLimit;
  }


  public ConfigGlobal sortList(@javax.annotation.Nullable List<ConfigSortListItem> sortList) {
    this.sortList = sortList;
    return this;
  }

  public ConfigGlobal addSortListItem(ConfigSortListItem sortListItem) {
    if (this.sortList == null) {
      this.sortList = new ArrayList<>();
    }
    this.sortList.add(sortListItem);
    return this;
  }

  /**
   * Optional. Specifies a sorted network list for A/AAAA records in DNS query response.  Defaults to _empty_.
   * @return sortList
   */
  @javax.annotation.Nullable
  public List<ConfigSortListItem> getSortList() {
    return sortList;
  }

  public void setSortList(@javax.annotation.Nullable List<ConfigSortListItem> sortList) {
    this.sortList = sortList;
  }


  public ConfigGlobal synthesizeAddressRecordsFromHttps(@javax.annotation.Nullable Boolean synthesizeAddressRecordsFromHttps) {
    this.synthesizeAddressRecordsFromHttps = synthesizeAddressRecordsFromHttps;
    return this;
  }

  /**
   * _synthesize_address_records_from_https_ enables/disables creation of A/AAAA records from HTTPS RR Defaults to _false_.
   * @return synthesizeAddressRecordsFromHttps
   */
  @javax.annotation.Nullable
  public Boolean getSynthesizeAddressRecordsFromHttps() {
    return synthesizeAddressRecordsFromHttps;
  }

  public void setSynthesizeAddressRecordsFromHttps(@javax.annotation.Nullable Boolean synthesizeAddressRecordsFromHttps) {
    this.synthesizeAddressRecordsFromHttps = synthesizeAddressRecordsFromHttps;
  }


  public ConfigGlobal transferAcl(@javax.annotation.Nullable List<ConfigACLItem> transferAcl) {
    this.transferAcl = transferAcl;
    return this;
  }

  public ConfigGlobal addTransferAclItem(ConfigACLItem transferAclItem) {
    if (this.transferAcl == null) {
      this.transferAcl = new ArrayList<>();
    }
    this.transferAcl.add(transferAclItem);
    return this;
  }

  /**
   * Optional. Clients must match this ACL to receive zone transfers.  Defaults to \&quot;deny any\&quot;.
   * @return transferAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getTransferAcl() {
    return transferAcl;
  }

  public void setTransferAcl(@javax.annotation.Nullable List<ConfigACLItem> transferAcl) {
    this.transferAcl = transferAcl;
  }


  public ConfigGlobal updateAcl(@javax.annotation.Nullable List<ConfigACLItem> updateAcl) {
    this.updateAcl = updateAcl;
    return this;
  }

  public ConfigGlobal addUpdateAclItem(ConfigACLItem updateAclItem) {
    if (this.updateAcl == null) {
      this.updateAcl = new ArrayList<>();
    }
    this.updateAcl.add(updateAclItem);
    return this;
  }

  /**
   * Optional. Specifies which hosts are allowed to issue Dynamic DNS updates for authoritative zones of _primary_type_ _cloud_.  Defaults to empty.
   * @return updateAcl
   */
  @javax.annotation.Nullable
  public List<ConfigACLItem> getUpdateAcl() {
    return updateAcl;
  }

  public void setUpdateAcl(@javax.annotation.Nullable List<ConfigACLItem> updateAcl) {
    this.updateAcl = updateAcl;
  }


  public ConfigGlobal useForwardersForSubzones(@javax.annotation.Nullable Boolean useForwardersForSubzones) {
    this.useForwardersForSubzones = useForwardersForSubzones;
    return this;
  }

  /**
   * Optional. Use default forwarders to resolve queries for subzones.  Defaults to _true_.
   * @return useForwardersForSubzones
   */
  @javax.annotation.Nullable
  public Boolean getUseForwardersForSubzones() {
    return useForwardersForSubzones;
  }

  public void setUseForwardersForSubzones(@javax.annotation.Nullable Boolean useForwardersForSubzones) {
    this.useForwardersForSubzones = useForwardersForSubzones;
  }


  public ConfigGlobal useRootForwardersForLocalResolutionWithB1td(@javax.annotation.Nullable Boolean useRootForwardersForLocalResolutionWithB1td) {
    this.useRootForwardersForLocalResolutionWithB1td = useRootForwardersForLocalResolutionWithB1td;
    return this;
  }

  /**
   * _use_root_forwarders_for_local_resolution_with_b1td_ allows DNS recursive queries sent to root forwarders for local resolution when deployed alongside BloxOne Thread Defense. Defaults to _false_.
   * @return useRootForwardersForLocalResolutionWithB1td
   */
  @javax.annotation.Nullable
  public Boolean getUseRootForwardersForLocalResolutionWithB1td() {
    return useRootForwardersForLocalResolutionWithB1td;
  }

  public void setUseRootForwardersForLocalResolutionWithB1td(@javax.annotation.Nullable Boolean useRootForwardersForLocalResolutionWithB1td) {
    this.useRootForwardersForLocalResolutionWithB1td = useRootForwardersForLocalResolutionWithB1td;
  }


  public ConfigGlobal zoneAuthority(@javax.annotation.Nullable ConfigZoneAuthority zoneAuthority) {
    this.zoneAuthority = zoneAuthority;
    return this;
  }

  /**
   * Get zoneAuthority
   * @return zoneAuthority
   */
  @javax.annotation.Nullable
  public ConfigZoneAuthority getZoneAuthority() {
    return zoneAuthority;
  }

  public void setZoneAuthority(@javax.annotation.Nullable ConfigZoneAuthority zoneAuthority) {
    this.zoneAuthority = zoneAuthority;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConfigGlobal configGlobal = (ConfigGlobal) o;
    return Objects.equals(this.activeSearchEnable, configGlobal.activeSearchEnable) &&
        Objects.equals(this.addEdnsOptionInOutgoingQuery, configGlobal.addEdnsOptionInOutgoingQuery) &&
        Objects.equals(this.customRootNs, configGlobal.customRootNs) &&
        Objects.equals(this.customRootNsEnabled, configGlobal.customRootNsEnabled) &&
        Objects.equals(this.dnssecEnableValidation, configGlobal.dnssecEnableValidation) &&
        Objects.equals(this.dnssecEnabled, configGlobal.dnssecEnabled) &&
        Objects.equals(this.dnssecRootKeys, configGlobal.dnssecRootKeys) &&
        Objects.equals(this.dnssecTrustAnchors, configGlobal.dnssecTrustAnchors) &&
        Objects.equals(this.dnssecValidateExceptions, configGlobal.dnssecValidateExceptions) &&
        Objects.equals(this.dnssecValidateExpiry, configGlobal.dnssecValidateExpiry) &&
        Objects.equals(this.dtcConfig, configGlobal.dtcConfig) &&
        Objects.equals(this.ecsEnabled, configGlobal.ecsEnabled) &&
        Objects.equals(this.ecsForwarding, configGlobal.ecsForwarding) &&
        Objects.equals(this.ecsPrefixV4, configGlobal.ecsPrefixV4) &&
        Objects.equals(this.ecsPrefixV6, configGlobal.ecsPrefixV6) &&
        Objects.equals(this.ecsZones, configGlobal.ecsZones) &&
        Objects.equals(this.ednsUdpSize, configGlobal.ednsUdpSize) &&
        Objects.equals(this.filterAaaaAcl, configGlobal.filterAaaaAcl) &&
        Objects.equals(this.filterAaaaOnV4, configGlobal.filterAaaaOnV4) &&
        Objects.equals(this.forwarders, configGlobal.forwarders) &&
        Objects.equals(this.forwardersOnly, configGlobal.forwardersOnly) &&
        Objects.equals(this.gssTsigEnabled, configGlobal.gssTsigEnabled) &&
        Objects.equals(this.id, configGlobal.id) &&
        Objects.equals(this.kerberosKeys, configGlobal.kerberosKeys) &&
        Objects.equals(this.lameTtl, configGlobal.lameTtl) &&
        Objects.equals(this.logQueryResponse, configGlobal.logQueryResponse) &&
        Objects.equals(this.loggingConfiguration, configGlobal.loggingConfiguration) &&
        Objects.equals(this.matchRecursiveOnly, configGlobal.matchRecursiveOnly) &&
        Objects.equals(this.maxCacheTtl, configGlobal.maxCacheTtl) &&
        Objects.equals(this.maxNegativeTtl, configGlobal.maxNegativeTtl) &&
        Objects.equals(this.maxUdpSize, configGlobal.maxUdpSize) &&
        Objects.equals(this.minimalResponses, configGlobal.minimalResponses) &&
        Objects.equals(this.notify, configGlobal.notify) &&
        Objects.equals(this.queryAcl, configGlobal.queryAcl) &&
        Objects.equals(this.queryPort, configGlobal.queryPort) &&
        Objects.equals(this.recursionAcl, configGlobal.recursionAcl) &&
        Objects.equals(this.recursionEnabled, configGlobal.recursionEnabled) &&
        Objects.equals(this.recursiveClients, configGlobal.recursiveClients) &&
        Objects.equals(this.resolverQueryTimeout, configGlobal.resolverQueryTimeout) &&
        Objects.equals(this.secondaryAxfrQueryLimit, configGlobal.secondaryAxfrQueryLimit) &&
        Objects.equals(this.secondarySoaQueryLimit, configGlobal.secondarySoaQueryLimit) &&
        Objects.equals(this.sortList, configGlobal.sortList) &&
        Objects.equals(this.synthesizeAddressRecordsFromHttps, configGlobal.synthesizeAddressRecordsFromHttps) &&
        Objects.equals(this.transferAcl, configGlobal.transferAcl) &&
        Objects.equals(this.updateAcl, configGlobal.updateAcl) &&
        Objects.equals(this.useForwardersForSubzones, configGlobal.useForwardersForSubzones) &&
        Objects.equals(this.useRootForwardersForLocalResolutionWithB1td, configGlobal.useRootForwardersForLocalResolutionWithB1td) &&
        Objects.equals(this.zoneAuthority, configGlobal.zoneAuthority);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activeSearchEnable, addEdnsOptionInOutgoingQuery, customRootNs, customRootNsEnabled, dnssecEnableValidation, dnssecEnabled, dnssecRootKeys, dnssecTrustAnchors, dnssecValidateExceptions, dnssecValidateExpiry, dtcConfig, ecsEnabled, ecsForwarding, ecsPrefixV4, ecsPrefixV6, ecsZones, ednsUdpSize, filterAaaaAcl, filterAaaaOnV4, forwarders, forwardersOnly, gssTsigEnabled, id, kerberosKeys, lameTtl, logQueryResponse, loggingConfiguration, matchRecursiveOnly, maxCacheTtl, maxNegativeTtl, maxUdpSize, minimalResponses, notify, queryAcl, queryPort, recursionAcl, recursionEnabled, recursiveClients, resolverQueryTimeout, secondaryAxfrQueryLimit, secondarySoaQueryLimit, sortList, synthesizeAddressRecordsFromHttps, transferAcl, updateAcl, useForwardersForSubzones, useRootForwardersForLocalResolutionWithB1td, zoneAuthority);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConfigGlobal {\n");
    sb.append("    activeSearchEnable: ").append(toIndentedString(activeSearchEnable)).append("\n");
    sb.append("    addEdnsOptionInOutgoingQuery: ").append(toIndentedString(addEdnsOptionInOutgoingQuery)).append("\n");
    sb.append("    customRootNs: ").append(toIndentedString(customRootNs)).append("\n");
    sb.append("    customRootNsEnabled: ").append(toIndentedString(customRootNsEnabled)).append("\n");
    sb.append("    dnssecEnableValidation: ").append(toIndentedString(dnssecEnableValidation)).append("\n");
    sb.append("    dnssecEnabled: ").append(toIndentedString(dnssecEnabled)).append("\n");
    sb.append("    dnssecRootKeys: ").append(toIndentedString(dnssecRootKeys)).append("\n");
    sb.append("    dnssecTrustAnchors: ").append(toIndentedString(dnssecTrustAnchors)).append("\n");
    sb.append("    dnssecValidateExceptions: ").append(toIndentedString(dnssecValidateExceptions)).append("\n");
    sb.append("    dnssecValidateExpiry: ").append(toIndentedString(dnssecValidateExpiry)).append("\n");
    sb.append("    dtcConfig: ").append(toIndentedString(dtcConfig)).append("\n");
    sb.append("    ecsEnabled: ").append(toIndentedString(ecsEnabled)).append("\n");
    sb.append("    ecsForwarding: ").append(toIndentedString(ecsForwarding)).append("\n");
    sb.append("    ecsPrefixV4: ").append(toIndentedString(ecsPrefixV4)).append("\n");
    sb.append("    ecsPrefixV6: ").append(toIndentedString(ecsPrefixV6)).append("\n");
    sb.append("    ecsZones: ").append(toIndentedString(ecsZones)).append("\n");
    sb.append("    ednsUdpSize: ").append(toIndentedString(ednsUdpSize)).append("\n");
    sb.append("    filterAaaaAcl: ").append(toIndentedString(filterAaaaAcl)).append("\n");
    sb.append("    filterAaaaOnV4: ").append(toIndentedString(filterAaaaOnV4)).append("\n");
    sb.append("    forwarders: ").append(toIndentedString(forwarders)).append("\n");
    sb.append("    forwardersOnly: ").append(toIndentedString(forwardersOnly)).append("\n");
    sb.append("    gssTsigEnabled: ").append(toIndentedString(gssTsigEnabled)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    kerberosKeys: ").append(toIndentedString(kerberosKeys)).append("\n");
    sb.append("    lameTtl: ").append(toIndentedString(lameTtl)).append("\n");
    sb.append("    logQueryResponse: ").append(toIndentedString(logQueryResponse)).append("\n");
    sb.append("    loggingConfiguration: ").append(toIndentedString(loggingConfiguration)).append("\n");
    sb.append("    matchRecursiveOnly: ").append(toIndentedString(matchRecursiveOnly)).append("\n");
    sb.append("    maxCacheTtl: ").append(toIndentedString(maxCacheTtl)).append("\n");
    sb.append("    maxNegativeTtl: ").append(toIndentedString(maxNegativeTtl)).append("\n");
    sb.append("    maxUdpSize: ").append(toIndentedString(maxUdpSize)).append("\n");
    sb.append("    minimalResponses: ").append(toIndentedString(minimalResponses)).append("\n");
    sb.append("    notify: ").append(toIndentedString(notify)).append("\n");
    sb.append("    queryAcl: ").append(toIndentedString(queryAcl)).append("\n");
    sb.append("    queryPort: ").append(toIndentedString(queryPort)).append("\n");
    sb.append("    recursionAcl: ").append(toIndentedString(recursionAcl)).append("\n");
    sb.append("    recursionEnabled: ").append(toIndentedString(recursionEnabled)).append("\n");
    sb.append("    recursiveClients: ").append(toIndentedString(recursiveClients)).append("\n");
    sb.append("    resolverQueryTimeout: ").append(toIndentedString(resolverQueryTimeout)).append("\n");
    sb.append("    secondaryAxfrQueryLimit: ").append(toIndentedString(secondaryAxfrQueryLimit)).append("\n");
    sb.append("    secondarySoaQueryLimit: ").append(toIndentedString(secondarySoaQueryLimit)).append("\n");
    sb.append("    sortList: ").append(toIndentedString(sortList)).append("\n");
    sb.append("    synthesizeAddressRecordsFromHttps: ").append(toIndentedString(synthesizeAddressRecordsFromHttps)).append("\n");
    sb.append("    transferAcl: ").append(toIndentedString(transferAcl)).append("\n");
    sb.append("    updateAcl: ").append(toIndentedString(updateAcl)).append("\n");
    sb.append("    useForwardersForSubzones: ").append(toIndentedString(useForwardersForSubzones)).append("\n");
    sb.append("    useRootForwardersForLocalResolutionWithB1td: ").append(toIndentedString(useRootForwardersForLocalResolutionWithB1td)).append("\n");
    sb.append("    zoneAuthority: ").append(toIndentedString(zoneAuthority)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("active_search_enable");
    openapiFields.add("add_edns_option_in_outgoing_query");
    openapiFields.add("custom_root_ns");
    openapiFields.add("custom_root_ns_enabled");
    openapiFields.add("dnssec_enable_validation");
    openapiFields.add("dnssec_enabled");
    openapiFields.add("dnssec_root_keys");
    openapiFields.add("dnssec_trust_anchors");
    openapiFields.add("dnssec_validate_exceptions");
    openapiFields.add("dnssec_validate_expiry");
    openapiFields.add("dtc_config");
    openapiFields.add("ecs_enabled");
    openapiFields.add("ecs_forwarding");
    openapiFields.add("ecs_prefix_v4");
    openapiFields.add("ecs_prefix_v6");
    openapiFields.add("ecs_zones");
    openapiFields.add("edns_udp_size");
    openapiFields.add("filter_aaaa_acl");
    openapiFields.add("filter_aaaa_on_v4");
    openapiFields.add("forwarders");
    openapiFields.add("forwarders_only");
    openapiFields.add("gss_tsig_enabled");
    openapiFields.add("id");
    openapiFields.add("kerberos_keys");
    openapiFields.add("lame_ttl");
    openapiFields.add("log_query_response");
    openapiFields.add("logging_configuration");
    openapiFields.add("match_recursive_only");
    openapiFields.add("max_cache_ttl");
    openapiFields.add("max_negative_ttl");
    openapiFields.add("max_udp_size");
    openapiFields.add("minimal_responses");
    openapiFields.add("notify");
    openapiFields.add("query_acl");
    openapiFields.add("query_port");
    openapiFields.add("recursion_acl");
    openapiFields.add("recursion_enabled");
    openapiFields.add("recursive_clients");
    openapiFields.add("resolver_query_timeout");
    openapiFields.add("secondary_axfr_query_limit");
    openapiFields.add("secondary_soa_query_limit");
    openapiFields.add("sort_list");
    openapiFields.add("synthesize_address_records_from_https");
    openapiFields.add("transfer_acl");
    openapiFields.add("update_acl");
    openapiFields.add("use_forwarders_for_subzones");
    openapiFields.add("use_root_forwarders_for_local_resolution_with_b1td");
    openapiFields.add("zone_authority");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ConfigGlobal
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ConfigGlobal.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConfigGlobal is not found in the empty JSON string", ConfigGlobal.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ConfigGlobal.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ConfigGlobal` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : ConfigGlobal.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (jsonObj.get("custom_root_ns") != null && !jsonObj.get("custom_root_ns").isJsonNull()) {
        JsonArray jsonArraycustomRootNs = jsonObj.getAsJsonArray("custom_root_ns");
        if (jsonArraycustomRootNs != null) {
          // ensure the json data is an array
          if (!jsonObj.get("custom_root_ns").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `custom_root_ns` to be an array in the JSON string but got `%s`", jsonObj.get("custom_root_ns").toString()));
          }

          // validate the optional field `custom_root_ns` (array)
          for (int i = 0; i < jsonArraycustomRootNs.size(); i++) {
            ConfigRootNS.validateJsonElement(jsonArraycustomRootNs.get(i));
          };
        }
      }
      if (jsonObj.get("dnssec_root_keys") != null && !jsonObj.get("dnssec_root_keys").isJsonNull()) {
        JsonArray jsonArraydnssecRootKeys = jsonObj.getAsJsonArray("dnssec_root_keys");
        if (jsonArraydnssecRootKeys != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dnssec_root_keys").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dnssec_root_keys` to be an array in the JSON string but got `%s`", jsonObj.get("dnssec_root_keys").toString()));
          }

          // validate the optional field `dnssec_root_keys` (array)
          for (int i = 0; i < jsonArraydnssecRootKeys.size(); i++) {
            ConfigTrustAnchor.validateJsonElement(jsonArraydnssecRootKeys.get(i));
          };
        }
      }
      if (jsonObj.get("dnssec_trust_anchors") != null && !jsonObj.get("dnssec_trust_anchors").isJsonNull()) {
        JsonArray jsonArraydnssecTrustAnchors = jsonObj.getAsJsonArray("dnssec_trust_anchors");
        if (jsonArraydnssecTrustAnchors != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dnssec_trust_anchors").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dnssec_trust_anchors` to be an array in the JSON string but got `%s`", jsonObj.get("dnssec_trust_anchors").toString()));
          }

          // validate the optional field `dnssec_trust_anchors` (array)
          for (int i = 0; i < jsonArraydnssecTrustAnchors.size(); i++) {
            ConfigTrustAnchor.validateJsonElement(jsonArraydnssecTrustAnchors.get(i));
          };
        }
      }
      if (jsonObj.get("dnssec_validate_exceptions") != null && !jsonObj.get("dnssec_validate_exceptions").isJsonNull()) {
        JsonArray jsonArraydnssecValidateExceptions = jsonObj.getAsJsonArray("dnssec_validate_exceptions");
        if (jsonArraydnssecValidateExceptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dnssec_validate_exceptions").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dnssec_validate_exceptions` to be an array in the JSON string but got `%s`", jsonObj.get("dnssec_validate_exceptions").toString()));
          }

          // validate the optional field `dnssec_validate_exceptions` (array)
          for (int i = 0; i < jsonArraydnssecValidateExceptions.size(); i++) {
            ConfigDNSSECValidateException.validateJsonElement(jsonArraydnssecValidateExceptions.get(i));
          };
        }
      }
      // validate the optional field `dtc_config`
      if (jsonObj.get("dtc_config") != null && !jsonObj.get("dtc_config").isJsonNull()) {
        ConfigDTCConfig.validateJsonElement(jsonObj.get("dtc_config"));
      }
      if (jsonObj.get("ecs_zones") != null && !jsonObj.get("ecs_zones").isJsonNull()) {
        JsonArray jsonArrayecsZones = jsonObj.getAsJsonArray("ecs_zones");
        if (jsonArrayecsZones != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ecs_zones").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ecs_zones` to be an array in the JSON string but got `%s`", jsonObj.get("ecs_zones").toString()));
          }

          // validate the optional field `ecs_zones` (array)
          for (int i = 0; i < jsonArrayecsZones.size(); i++) {
            ConfigECSZone.validateJsonElement(jsonArrayecsZones.get(i));
          };
        }
      }
      if (jsonObj.get("filter_aaaa_acl") != null && !jsonObj.get("filter_aaaa_acl").isJsonNull()) {
        JsonArray jsonArrayfilterAaaaAcl = jsonObj.getAsJsonArray("filter_aaaa_acl");
        if (jsonArrayfilterAaaaAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("filter_aaaa_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `filter_aaaa_acl` to be an array in the JSON string but got `%s`", jsonObj.get("filter_aaaa_acl").toString()));
          }

          // validate the optional field `filter_aaaa_acl` (array)
          for (int i = 0; i < jsonArrayfilterAaaaAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayfilterAaaaAcl.get(i));
          };
        }
      }
      if ((jsonObj.get("filter_aaaa_on_v4") != null && !jsonObj.get("filter_aaaa_on_v4").isJsonNull()) && !jsonObj.get("filter_aaaa_on_v4").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `filter_aaaa_on_v4` to be a primitive type in the JSON string but got `%s`", jsonObj.get("filter_aaaa_on_v4").toString()));
      }
      if (jsonObj.get("forwarders") != null && !jsonObj.get("forwarders").isJsonNull()) {
        JsonArray jsonArrayforwarders = jsonObj.getAsJsonArray("forwarders");
        if (jsonArrayforwarders != null) {
          // ensure the json data is an array
          if (!jsonObj.get("forwarders").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `forwarders` to be an array in the JSON string but got `%s`", jsonObj.get("forwarders").toString()));
          }

          // validate the optional field `forwarders` (array)
          for (int i = 0; i < jsonArrayforwarders.size(); i++) {
            ConfigForwarder.validateJsonElement(jsonArrayforwarders.get(i));
          };
        }
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (jsonObj.get("kerberos_keys") != null && !jsonObj.get("kerberos_keys").isJsonNull()) {
        JsonArray jsonArraykerberosKeys = jsonObj.getAsJsonArray("kerberos_keys");
        if (jsonArraykerberosKeys != null) {
          // ensure the json data is an array
          if (!jsonObj.get("kerberos_keys").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `kerberos_keys` to be an array in the JSON string but got `%s`", jsonObj.get("kerberos_keys").toString()));
          }

          // validate the optional field `kerberos_keys` (array)
          for (int i = 0; i < jsonArraykerberosKeys.size(); i++) {
            ConfigKerberosKey.validateJsonElement(jsonArraykerberosKeys.get(i));
          };
        }
      }
      // validate the optional field `logging_configuration`
      if (jsonObj.get("logging_configuration") != null && !jsonObj.get("logging_configuration").isJsonNull()) {
        ConfigLoggingConfig.validateJsonElement(jsonObj.get("logging_configuration"));
      }
      if (jsonObj.get("query_acl") != null && !jsonObj.get("query_acl").isJsonNull()) {
        JsonArray jsonArrayqueryAcl = jsonObj.getAsJsonArray("query_acl");
        if (jsonArrayqueryAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("query_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `query_acl` to be an array in the JSON string but got `%s`", jsonObj.get("query_acl").toString()));
          }

          // validate the optional field `query_acl` (array)
          for (int i = 0; i < jsonArrayqueryAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayqueryAcl.get(i));
          };
        }
      }
      if (jsonObj.get("recursion_acl") != null && !jsonObj.get("recursion_acl").isJsonNull()) {
        JsonArray jsonArrayrecursionAcl = jsonObj.getAsJsonArray("recursion_acl");
        if (jsonArrayrecursionAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("recursion_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `recursion_acl` to be an array in the JSON string but got `%s`", jsonObj.get("recursion_acl").toString()));
          }

          // validate the optional field `recursion_acl` (array)
          for (int i = 0; i < jsonArrayrecursionAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayrecursionAcl.get(i));
          };
        }
      }
      if (jsonObj.get("sort_list") != null && !jsonObj.get("sort_list").isJsonNull()) {
        JsonArray jsonArraysortList = jsonObj.getAsJsonArray("sort_list");
        if (jsonArraysortList != null) {
          // ensure the json data is an array
          if (!jsonObj.get("sort_list").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `sort_list` to be an array in the JSON string but got `%s`", jsonObj.get("sort_list").toString()));
          }

          // validate the optional field `sort_list` (array)
          for (int i = 0; i < jsonArraysortList.size(); i++) {
            ConfigSortListItem.validateJsonElement(jsonArraysortList.get(i));
          };
        }
      }
      if (jsonObj.get("transfer_acl") != null && !jsonObj.get("transfer_acl").isJsonNull()) {
        JsonArray jsonArraytransferAcl = jsonObj.getAsJsonArray("transfer_acl");
        if (jsonArraytransferAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("transfer_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `transfer_acl` to be an array in the JSON string but got `%s`", jsonObj.get("transfer_acl").toString()));
          }

          // validate the optional field `transfer_acl` (array)
          for (int i = 0; i < jsonArraytransferAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArraytransferAcl.get(i));
          };
        }
      }
      if (jsonObj.get("update_acl") != null && !jsonObj.get("update_acl").isJsonNull()) {
        JsonArray jsonArrayupdateAcl = jsonObj.getAsJsonArray("update_acl");
        if (jsonArrayupdateAcl != null) {
          // ensure the json data is an array
          if (!jsonObj.get("update_acl").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `update_acl` to be an array in the JSON string but got `%s`", jsonObj.get("update_acl").toString()));
          }

          // validate the optional field `update_acl` (array)
          for (int i = 0; i < jsonArrayupdateAcl.size(); i++) {
            ConfigACLItem.validateJsonElement(jsonArrayupdateAcl.get(i));
          };
        }
      }
      // validate the optional field `zone_authority`
      if (jsonObj.get("zone_authority") != null && !jsonObj.get("zone_authority").isJsonNull()) {
        ConfigZoneAuthority.validateJsonElement(jsonObj.get("zone_authority"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConfigGlobal.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConfigGlobal' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConfigGlobal> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConfigGlobal.class));

       return (TypeAdapter<T>) new TypeAdapter<ConfigGlobal>() {
           @Override
           public void write(JsonWriter out, ConfigGlobal value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ConfigGlobal read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ConfigGlobal given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ConfigGlobal
   * @throws IOException if the JSON string is invalid with respect to ConfigGlobal
   */
  public static ConfigGlobal fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConfigGlobal.class);
  }

  /**
   * Convert an instance of ConfigGlobal to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

