/*
 * DNS Configuration API
 * The DNS application is a BloxOne DDI service that provides cloud-based DNS configuration with on-prem host serving DNS protocol. It is part of the full-featured BloxOne DDI solution that enables customers the ability to deploy large numbers of protocol servers in the delivery of DNS and DHCP throughout their enterprise network.   
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The _dns/cache_flush_ API removes entries from the DNS cache on the on-prem host. The command will be forwarded to the on-prem host and executed asynchronously. The on-prem host must be available and running DNS for this to succeed.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:28.384903+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class ConfigCacheFlush {
  public static final String SERIALIZED_NAME_ENDPOINT_ID = "endpoint_id";
  @SerializedName(SERIALIZED_NAME_ENDPOINT_ID)
  @javax.annotation.Nullable
  private String endpointId;

  public static final String SERIALIZED_NAME_FLUSH_SUBDOMAINS = "flush_subdomains";
  @SerializedName(SERIALIZED_NAME_FLUSH_SUBDOMAINS)
  @javax.annotation.Nullable
  private Boolean flushSubdomains;

  public static final String SERIALIZED_NAME_FQDN = "fqdn";
  @SerializedName(SERIALIZED_NAME_FQDN)
  @javax.annotation.Nullable
  private String fqdn;

  public static final String SERIALIZED_NAME_OPHID = "ophid";
  @SerializedName(SERIALIZED_NAME_OPHID)
  @javax.annotation.Nullable
  private String ophid;

  public static final String SERIALIZED_NAME_SERVICE_ID = "service_id";
  @SerializedName(SERIALIZED_NAME_SERVICE_ID)
  @javax.annotation.Nullable
  private String serviceId;

  public static final String SERIALIZED_NAME_TTL = "ttl";
  @SerializedName(SERIALIZED_NAME_TTL)
  @javax.annotation.Nullable
  private Long ttl;

  public static final String SERIALIZED_NAME_VIEW_NAME = "view_name";
  @SerializedName(SERIALIZED_NAME_VIEW_NAME)
  @javax.annotation.Nullable
  private String viewName;

  public ConfigCacheFlush() {
  }

  public ConfigCacheFlush endpointId(@javax.annotation.Nullable String endpointId) {
    this.endpointId = endpointId;
    return this;
  }

  /**
   * Endpoint Id for universal service. Either _ophid_ or _service_id_ or _endpoint_id_ should be provided.
   * @return endpointId
   */
  @javax.annotation.Nullable
  public String getEndpointId() {
    return endpointId;
  }

  public void setEndpointId(@javax.annotation.Nullable String endpointId) {
    this.endpointId = endpointId;
  }


  public ConfigCacheFlush flushSubdomains(@javax.annotation.Nullable Boolean flushSubdomains) {
    this.flushSubdomains = flushSubdomains;
    return this;
  }

  /**
   * Optional. If _true_, all names below the given FQDN will also be removed from cache.  Defaults to _true_.
   * @return flushSubdomains
   */
  @javax.annotation.Nullable
  public Boolean getFlushSubdomains() {
    return flushSubdomains;
  }

  public void setFlushSubdomains(@javax.annotation.Nullable Boolean flushSubdomains) {
    this.flushSubdomains = flushSubdomains;
  }


  public ConfigCacheFlush fqdn(@javax.annotation.Nullable String fqdn) {
    this.fqdn = fqdn;
    return this;
  }

  /**
   * Optional. The FQDN to remove.  Defaults to &#39;.&#39;
   * @return fqdn
   */
  @javax.annotation.Nullable
  public String getFqdn() {
    return fqdn;
  }

  public void setFqdn(@javax.annotation.Nullable String fqdn) {
    this.fqdn = fqdn;
  }


  public ConfigCacheFlush ophid(@javax.annotation.Nullable String ophid) {
    this.ophid = ophid;
    return this;
  }

  /**
   * The host to alter. Either _ophid_ or _service_id_ or _endpoint_id_ should be provided.
   * @return ophid
   */
  @javax.annotation.Nullable
  public String getOphid() {
    return ophid;
  }

  public void setOphid(@javax.annotation.Nullable String ophid) {
    this.ophid = ophid;
  }


  public ConfigCacheFlush serviceId(@javax.annotation.Nullable String serviceId) {
    this.serviceId = serviceId;
    return this;
  }

  /**
   * Service Id. Either _ophid_ or _service_id_ or _endpoint_id_ should be provided.
   * @return serviceId
   */
  @javax.annotation.Nullable
  public String getServiceId() {
    return serviceId;
  }

  public void setServiceId(@javax.annotation.Nullable String serviceId) {
    this.serviceId = serviceId;
  }


  public ConfigCacheFlush ttl(@javax.annotation.Nullable Long ttl) {
    this.ttl = ttl;
    return this;
  }

  /**
   * Optional. The time in seconds the command is valid for. Command is executed on the onprem host only if it takes less than this time for the command to be transmitted to the host. Otherwise the onprem host discards this command.  Defaults to 120 (2 min).
   * @return ttl
   */
  @javax.annotation.Nullable
  public Long getTtl() {
    return ttl;
  }

  public void setTtl(@javax.annotation.Nullable Long ttl) {
    this.ttl = ttl;
  }


  public ConfigCacheFlush viewName(@javax.annotation.Nullable String viewName) {
    this.viewName = viewName;
    return this;
  }

  /**
   * Optional, If provided, flushes the server&#39;s cache for a view.
   * @return viewName
   */
  @javax.annotation.Nullable
  public String getViewName() {
    return viewName;
  }

  public void setViewName(@javax.annotation.Nullable String viewName) {
    this.viewName = viewName;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConfigCacheFlush configCacheFlush = (ConfigCacheFlush) o;
    return Objects.equals(this.endpointId, configCacheFlush.endpointId) &&
        Objects.equals(this.flushSubdomains, configCacheFlush.flushSubdomains) &&
        Objects.equals(this.fqdn, configCacheFlush.fqdn) &&
        Objects.equals(this.ophid, configCacheFlush.ophid) &&
        Objects.equals(this.serviceId, configCacheFlush.serviceId) &&
        Objects.equals(this.ttl, configCacheFlush.ttl) &&
        Objects.equals(this.viewName, configCacheFlush.viewName);
  }

  @Override
  public int hashCode() {
    return Objects.hash(endpointId, flushSubdomains, fqdn, ophid, serviceId, ttl, viewName);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConfigCacheFlush {\n");
    sb.append("    endpointId: ").append(toIndentedString(endpointId)).append("\n");
    sb.append("    flushSubdomains: ").append(toIndentedString(flushSubdomains)).append("\n");
    sb.append("    fqdn: ").append(toIndentedString(fqdn)).append("\n");
    sb.append("    ophid: ").append(toIndentedString(ophid)).append("\n");
    sb.append("    serviceId: ").append(toIndentedString(serviceId)).append("\n");
    sb.append("    ttl: ").append(toIndentedString(ttl)).append("\n");
    sb.append("    viewName: ").append(toIndentedString(viewName)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("endpoint_id");
    openapiFields.add("flush_subdomains");
    openapiFields.add("fqdn");
    openapiFields.add("ophid");
    openapiFields.add("service_id");
    openapiFields.add("ttl");
    openapiFields.add("view_name");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ConfigCacheFlush
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!ConfigCacheFlush.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ConfigCacheFlush is not found in the empty JSON string", ConfigCacheFlush.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!ConfigCacheFlush.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ConfigCacheFlush` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("endpoint_id") != null && !jsonObj.get("endpoint_id").isJsonNull()) && !jsonObj.get("endpoint_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `endpoint_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("endpoint_id").toString()));
      }
      if ((jsonObj.get("fqdn") != null && !jsonObj.get("fqdn").isJsonNull()) && !jsonObj.get("fqdn").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fqdn` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fqdn").toString()));
      }
      if ((jsonObj.get("ophid") != null && !jsonObj.get("ophid").isJsonNull()) && !jsonObj.get("ophid").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ophid` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ophid").toString()));
      }
      if ((jsonObj.get("service_id") != null && !jsonObj.get("service_id").isJsonNull()) && !jsonObj.get("service_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `service_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("service_id").toString()));
      }
      if ((jsonObj.get("view_name") != null && !jsonObj.get("view_name").isJsonNull()) && !jsonObj.get("view_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `view_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("view_name").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ConfigCacheFlush.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ConfigCacheFlush' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ConfigCacheFlush> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ConfigCacheFlush.class));

       return (TypeAdapter<T>) new TypeAdapter<ConfigCacheFlush>() {
           @Override
           public void write(JsonWriter out, ConfigCacheFlush value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ConfigCacheFlush read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of ConfigCacheFlush given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ConfigCacheFlush
   * @throws IOException if the JSON string is invalid with respect to ConfigCacheFlush
   */
  public static ConfigCacheFlush fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ConfigCacheFlush.class);
  }

  /**
   * Convert an instance of ConfigCacheFlush to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

