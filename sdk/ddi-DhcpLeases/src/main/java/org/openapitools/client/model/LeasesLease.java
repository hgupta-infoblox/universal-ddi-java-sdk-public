/*
 * DHCP Leases API
 * The DHCP Leases application is a BloxOne DDI service that stores information about leases. It is part of the full-featured, DDI cloud solution that enables customers to deploy large numbers of protocol servers to deliver DNS and DHCP throughout their enterprise network. Hosts are authoritative for their lease data. Changes to leases are periodically replicated to the cloud and stored by this service for display purposes. There is no lease history, so only current leases are available. In other words, every _dhcp/lease_ for that matter, represents a lease that is currently active. Note that fixed addresses do not have leases.  
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A __Lease__ object (_dhcp/lease_) represents the DHCP lease on an address and exists only while the address is leased. Hosts are authoritative for their lease data. Lease objects visible in the cloud are read-only delayed replicas and may be inconsistent with the current state of a disconnected host.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:27.506035+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class LeasesLease {
  public static final String SERIALIZED_NAME_ADDRESS = "address";
  @SerializedName(SERIALIZED_NAME_ADDRESS)
  @javax.annotation.Nullable
  private String address;

  public static final String SERIALIZED_NAME_CLIENT_ID = "client_id";
  @SerializedName(SERIALIZED_NAME_CLIENT_ID)
  @javax.annotation.Nullable
  private String clientId;

  public static final String SERIALIZED_NAME_ENDS = "ends";
  @SerializedName(SERIALIZED_NAME_ENDS)
  @javax.annotation.Nullable
  private OffsetDateTime ends;

  public static final String SERIALIZED_NAME_FINGERPRINT = "fingerprint";
  @SerializedName(SERIALIZED_NAME_FINGERPRINT)
  @javax.annotation.Nullable
  private String fingerprint;

  public static final String SERIALIZED_NAME_FINGERPRINT_PROCESSED = "fingerprint_processed";
  @SerializedName(SERIALIZED_NAME_FINGERPRINT_PROCESSED)
  @javax.annotation.Nullable
  private String fingerprintProcessed;

  public static final String SERIALIZED_NAME_HA_GROUP = "ha_group";
  @SerializedName(SERIALIZED_NAME_HA_GROUP)
  @javax.annotation.Nullable
  private String haGroup;

  public static final String SERIALIZED_NAME_HARDWARE = "hardware";
  @SerializedName(SERIALIZED_NAME_HARDWARE)
  @javax.annotation.Nullable
  private String hardware;

  public static final String SERIALIZED_NAME_HOST = "host";
  @SerializedName(SERIALIZED_NAME_HOST)
  @javax.annotation.Nullable
  private String host;

  public static final String SERIALIZED_NAME_HOSTNAME = "hostname";
  @SerializedName(SERIALIZED_NAME_HOSTNAME)
  @javax.annotation.Nullable
  private String hostname;

  public static final String SERIALIZED_NAME_IAID = "iaid";
  @SerializedName(SERIALIZED_NAME_IAID)
  @javax.annotation.Nullable
  private Long iaid;

  public static final String SERIALIZED_NAME_LAST_UPDATED = "last_updated";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATED)
  @javax.annotation.Nullable
  private OffsetDateTime lastUpdated;

  public static final String SERIALIZED_NAME_OPTIONS = "options";
  @SerializedName(SERIALIZED_NAME_OPTIONS)
  @javax.annotation.Nullable
  private String options;

  public static final String SERIALIZED_NAME_PREFERRED_LIFETIME = "preferred_lifetime";
  @SerializedName(SERIALIZED_NAME_PREFERRED_LIFETIME)
  @javax.annotation.Nullable
  private OffsetDateTime preferredLifetime;

  public static final String SERIALIZED_NAME_PROTOCOL = "protocol";
  @SerializedName(SERIALIZED_NAME_PROTOCOL)
  @javax.annotation.Nullable
  private String protocol;

  public static final String SERIALIZED_NAME_SPACE = "space";
  @SerializedName(SERIALIZED_NAME_SPACE)
  @javax.annotation.Nullable
  private String space;

  public static final String SERIALIZED_NAME_STARTS = "starts";
  @SerializedName(SERIALIZED_NAME_STARTS)
  @javax.annotation.Nullable
  private OffsetDateTime starts;

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  @javax.annotation.Nullable
  private String state;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  @javax.annotation.Nullable
  private String type;

  public LeasesLease() {
  }

  public LeasesLease(
     String address, 
     String clientId, 
     OffsetDateTime ends, 
     String fingerprint, 
     String fingerprintProcessed, 
     String hardware, 
     String hostname, 
     Long iaid, 
     OffsetDateTime lastUpdated, 
     String options, 
     OffsetDateTime preferredLifetime, 
     String protocol, 
     OffsetDateTime starts, 
     String state, 
     String type
  ) {
    this();
    this.address = address;
    this.clientId = clientId;
    this.ends = ends;
    this.fingerprint = fingerprint;
    this.fingerprintProcessed = fingerprintProcessed;
    this.hardware = hardware;
    this.hostname = hostname;
    this.iaid = iaid;
    this.lastUpdated = lastUpdated;
    this.options = options;
    this.preferredLifetime = preferredLifetime;
    this.protocol = protocol;
    this.starts = starts;
    this.state = state;
    this.type = type;
  }

  /**
   * The IP address of the DHCP lease in the format \&quot;a.b.c.d\&quot;. This address will be marked as _leased_ in IPAM while the lease exists.
   * @return address
   */
  @javax.annotation.Nullable
  public String getAddress() {
    return address;
  }



  /**
   * The client ID of the DHCP lease. It might be empty.
   * @return clientId
   */
  @javax.annotation.Nullable
  public String getClientId() {
    return clientId;
  }



  /**
   * The time when the DHCP lease will expire.
   * @return ends
   */
  @javax.annotation.Nullable
  public OffsetDateTime getEnds() {
    return ends;
  }



  /**
   * The DHCP fingerprint of the lease.
   * @return fingerprint
   */
  @javax.annotation.Nullable
  public String getFingerprint() {
    return fingerprint;
  }



  /**
   * Indicates if the DHCP lease has been fingerprinted.
   * @return fingerprintProcessed
   */
  @javax.annotation.Nullable
  public String getFingerprintProcessed() {
    return fingerprintProcessed;
  }



  public LeasesLease haGroup(@javax.annotation.Nullable String haGroup) {
    this.haGroup = haGroup;
    return this;
  }

  /**
   * The resource identifier.
   * @return haGroup
   */
  @javax.annotation.Nullable
  public String getHaGroup() {
    return haGroup;
  }

  public void setHaGroup(@javax.annotation.Nullable String haGroup) {
    this.haGroup = haGroup;
  }


  /**
   * The hardware address of the DHCP lease. This specifies the MAC address of the network interface on which the lease will be used. It consists of six groups of two hex digits in lower-case separated by colons. For example, \&quot;aa:bb:cc:dd:ee:ff\&quot;.
   * @return hardware
   */
  @javax.annotation.Nullable
  public String getHardware() {
    return hardware;
  }



  public LeasesLease host(@javax.annotation.Nullable String host) {
    this.host = host;
    return this;
  }

  /**
   * The resource identifier.
   * @return host
   */
  @javax.annotation.Nullable
  public String getHost() {
    return host;
  }

  public void setHost(@javax.annotation.Nullable String host) {
    this.host = host;
  }


  /**
   * The client hostname of the DHCP lease. This specifies the host name that the DHCP client sends to the DHCP server using DHCP option 12. It is a fully qualified domain name, consisting of a series of labels separated by dots. For example, \&quot;www.infoblox.com\&quot;. It might be empty.
   * @return hostname
   */
  @javax.annotation.Nullable
  public String getHostname() {
    return hostname;
  }



  /**
   * Identity Association Identifier (IAID) of the lease. Applicable only for DHCPv6.
   * @return iaid
   */
  @javax.annotation.Nullable
  public Long getIaid() {
    return iaid;
  }



  /**
   * The time when the DHCP lease was last updated.
   * @return lastUpdated
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastUpdated() {
    return lastUpdated;
  }



  /**
   * The DHCP options of the lease in JSON format.
   * @return options
   */
  @javax.annotation.Nullable
  public String getOptions() {
    return options;
  }



  /**
   * The preferred time when the DHCP lease should expire. Applicable only for DHCPv6.
   * @return preferredLifetime
   */
  @javax.annotation.Nullable
  public OffsetDateTime getPreferredLifetime() {
    return preferredLifetime;
  }



  /**
   * Lease protocol type. API only. Valid values: _ip4_, _ip6_.
   * @return protocol
   */
  @javax.annotation.Nullable
  public String getProtocol() {
    return protocol;
  }



  public LeasesLease space(@javax.annotation.Nullable String space) {
    this.space = space;
    return this;
  }

  /**
   * The resource identifier.
   * @return space
   */
  @javax.annotation.Nullable
  public String getSpace() {
    return space;
  }

  public void setSpace(@javax.annotation.Nullable String space) {
    this.space = space;
  }


  /**
   * The time when the DHCP lease was issued.
   * @return starts
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStarts() {
    return starts;
  }



  /**
   * The state of the DHCP lease.  Valid values are: * _used_: The lease was issued by a DHCP server and is used by the client. * _abandoned_: The lease was issued by a DHCP server and then declined by the client.
   * @return state
   */
  @javax.annotation.Nullable
  public String getState() {
    return state;
  }



  /**
   * Lease type.  Valid values are: * _DHCPv6NonTemporaryAddress_: DHCPv6 non-temporary address (NA) * _DHCPv6TemporaryAddress_: DHCPv6 temporary address (TA) * _DHCPv6PrefixDelegation_: DHCPv6 prefix delegation (PD) * _DHCPv4_: DHCPv4 lease
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LeasesLease leasesLease = (LeasesLease) o;
    return Objects.equals(this.address, leasesLease.address) &&
        Objects.equals(this.clientId, leasesLease.clientId) &&
        Objects.equals(this.ends, leasesLease.ends) &&
        Objects.equals(this.fingerprint, leasesLease.fingerprint) &&
        Objects.equals(this.fingerprintProcessed, leasesLease.fingerprintProcessed) &&
        Objects.equals(this.haGroup, leasesLease.haGroup) &&
        Objects.equals(this.hardware, leasesLease.hardware) &&
        Objects.equals(this.host, leasesLease.host) &&
        Objects.equals(this.hostname, leasesLease.hostname) &&
        Objects.equals(this.iaid, leasesLease.iaid) &&
        Objects.equals(this.lastUpdated, leasesLease.lastUpdated) &&
        Objects.equals(this.options, leasesLease.options) &&
        Objects.equals(this.preferredLifetime, leasesLease.preferredLifetime) &&
        Objects.equals(this.protocol, leasesLease.protocol) &&
        Objects.equals(this.space, leasesLease.space) &&
        Objects.equals(this.starts, leasesLease.starts) &&
        Objects.equals(this.state, leasesLease.state) &&
        Objects.equals(this.type, leasesLease.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(address, clientId, ends, fingerprint, fingerprintProcessed, haGroup, hardware, host, hostname, iaid, lastUpdated, options, preferredLifetime, protocol, space, starts, state, type);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LeasesLease {\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    clientId: ").append(toIndentedString(clientId)).append("\n");
    sb.append("    ends: ").append(toIndentedString(ends)).append("\n");
    sb.append("    fingerprint: ").append(toIndentedString(fingerprint)).append("\n");
    sb.append("    fingerprintProcessed: ").append(toIndentedString(fingerprintProcessed)).append("\n");
    sb.append("    haGroup: ").append(toIndentedString(haGroup)).append("\n");
    sb.append("    hardware: ").append(toIndentedString(hardware)).append("\n");
    sb.append("    host: ").append(toIndentedString(host)).append("\n");
    sb.append("    hostname: ").append(toIndentedString(hostname)).append("\n");
    sb.append("    iaid: ").append(toIndentedString(iaid)).append("\n");
    sb.append("    lastUpdated: ").append(toIndentedString(lastUpdated)).append("\n");
    sb.append("    options: ").append(toIndentedString(options)).append("\n");
    sb.append("    preferredLifetime: ").append(toIndentedString(preferredLifetime)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    space: ").append(toIndentedString(space)).append("\n");
    sb.append("    starts: ").append(toIndentedString(starts)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("address");
    openapiFields.add("client_id");
    openapiFields.add("ends");
    openapiFields.add("fingerprint");
    openapiFields.add("fingerprint_processed");
    openapiFields.add("ha_group");
    openapiFields.add("hardware");
    openapiFields.add("host");
    openapiFields.add("hostname");
    openapiFields.add("iaid");
    openapiFields.add("last_updated");
    openapiFields.add("options");
    openapiFields.add("preferred_lifetime");
    openapiFields.add("protocol");
    openapiFields.add("space");
    openapiFields.add("starts");
    openapiFields.add("state");
    openapiFields.add("type");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to LeasesLease
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LeasesLease.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LeasesLease is not found in the empty JSON string", LeasesLease.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LeasesLease.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LeasesLease` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("address") != null && !jsonObj.get("address").isJsonNull()) && !jsonObj.get("address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("address").toString()));
      }
      if ((jsonObj.get("client_id") != null && !jsonObj.get("client_id").isJsonNull()) && !jsonObj.get("client_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `client_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("client_id").toString()));
      }
      if ((jsonObj.get("fingerprint") != null && !jsonObj.get("fingerprint").isJsonNull()) && !jsonObj.get("fingerprint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fingerprint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fingerprint").toString()));
      }
      if ((jsonObj.get("fingerprint_processed") != null && !jsonObj.get("fingerprint_processed").isJsonNull()) && !jsonObj.get("fingerprint_processed").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `fingerprint_processed` to be a primitive type in the JSON string but got `%s`", jsonObj.get("fingerprint_processed").toString()));
      }
      if ((jsonObj.get("ha_group") != null && !jsonObj.get("ha_group").isJsonNull()) && !jsonObj.get("ha_group").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ha_group` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ha_group").toString()));
      }
      if ((jsonObj.get("hardware") != null && !jsonObj.get("hardware").isJsonNull()) && !jsonObj.get("hardware").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hardware` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hardware").toString()));
      }
      if ((jsonObj.get("host") != null && !jsonObj.get("host").isJsonNull()) && !jsonObj.get("host").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `host` to be a primitive type in the JSON string but got `%s`", jsonObj.get("host").toString()));
      }
      if ((jsonObj.get("hostname") != null && !jsonObj.get("hostname").isJsonNull()) && !jsonObj.get("hostname").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname").toString()));
      }
      if ((jsonObj.get("options") != null && !jsonObj.get("options").isJsonNull()) && !jsonObj.get("options").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `options` to be a primitive type in the JSON string but got `%s`", jsonObj.get("options").toString()));
      }
      if ((jsonObj.get("protocol") != null && !jsonObj.get("protocol").isJsonNull()) && !jsonObj.get("protocol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `protocol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("protocol").toString()));
      }
      if ((jsonObj.get("space") != null && !jsonObj.get("space").isJsonNull()) && !jsonObj.get("space").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `space` to be a primitive type in the JSON string but got `%s`", jsonObj.get("space").toString()));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LeasesLease.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LeasesLease' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LeasesLease> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LeasesLease.class));

       return (TypeAdapter<T>) new TypeAdapter<LeasesLease>() {
           @Override
           public void write(JsonWriter out, LeasesLease value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LeasesLease read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of LeasesLease given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of LeasesLease
   * @throws IOException if the JSON string is invalid with respect to LeasesLease
   */
  public static LeasesLease fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LeasesLease.class);
  }

  /**
   * Convert an instance of LeasesLease to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

