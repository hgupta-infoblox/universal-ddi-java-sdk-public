/*
 * DNS Data API
 * The DNS Data is a BloxOne DDI service providing primary authoritative zone support. DNS Data is authoritative for all DNS resource records and is acting as a primary DNS server. It is part of the full-featured, DDI cloud solution that enables customers to deploy large numbers of protocol servers to deliver DNS and DHCP throughout their enterprise network.   
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.DataRecordInheritance;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A __Record__ object (_dns/record_) represents a DNS resource record in an authoritative zone.  For creating a DNS resource record, one of the following pairs of fields is required:&lt;ul&gt;&lt;li&gt;_name_in_zone_ and _zone_: The system creates the DNS resource record object within the specified zone. The value of the view field is automatically retrieved from the zone object.&lt;/li&gt;&lt;li&gt;_absolute_name_spec_ and _view_: The system looks for the appropriate zone in the provided view to create the DNS resource record object. The value of the zone field is automatically computed as part of this process.&lt;/li&gt;&lt;/ul&gt;  The _zone_ and _view_ fields cannot be modified while updating a DNS resource record. The _name_in_zone_ and _absolute_name_spec_ fields can be modified. If both fields are modified in the same update, they need to represent the same change.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:29.679662+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class DataRecord {
  public static final String SERIALIZED_NAME_ABSOLUTE_NAME_SPEC = "absolute_name_spec";
  @SerializedName(SERIALIZED_NAME_ABSOLUTE_NAME_SPEC)
  @javax.annotation.Nullable
  private String absoluteNameSpec;

  public static final String SERIALIZED_NAME_ABSOLUTE_ZONE_NAME = "absolute_zone_name";
  @SerializedName(SERIALIZED_NAME_ABSOLUTE_ZONE_NAME)
  @javax.annotation.Nullable
  private String absoluteZoneName;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  @javax.annotation.Nullable
  private String comment;

  public static final String SERIALIZED_NAME_COMPARTMENT_ID = "compartment_id";
  @SerializedName(SERIALIZED_NAME_COMPARTMENT_ID)
  @javax.annotation.Nullable
  private String compartmentId;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DELEGATION = "delegation";
  @SerializedName(SERIALIZED_NAME_DELEGATION)
  @javax.annotation.Nullable
  private String delegation;

  public static final String SERIALIZED_NAME_DISABLED = "disabled";
  @SerializedName(SERIALIZED_NAME_DISABLED)
  @javax.annotation.Nullable
  private Boolean disabled;

  public static final String SERIALIZED_NAME_DNS_ABSOLUTE_NAME_SPEC = "dns_absolute_name_spec";
  @SerializedName(SERIALIZED_NAME_DNS_ABSOLUTE_NAME_SPEC)
  @javax.annotation.Nullable
  private String dnsAbsoluteNameSpec;

  public static final String SERIALIZED_NAME_DNS_ABSOLUTE_ZONE_NAME = "dns_absolute_zone_name";
  @SerializedName(SERIALIZED_NAME_DNS_ABSOLUTE_ZONE_NAME)
  @javax.annotation.Nullable
  private String dnsAbsoluteZoneName;

  public static final String SERIALIZED_NAME_DNS_NAME_IN_ZONE = "dns_name_in_zone";
  @SerializedName(SERIALIZED_NAME_DNS_NAME_IN_ZONE)
  @javax.annotation.Nullable
  private String dnsNameInZone;

  public static final String SERIALIZED_NAME_DNS_RDATA = "dns_rdata";
  @SerializedName(SERIALIZED_NAME_DNS_RDATA)
  @javax.annotation.Nullable
  private String dnsRdata;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_INHERITANCE_SOURCES = "inheritance_sources";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_SOURCES)
  @javax.annotation.Nullable
  private DataRecordInheritance inheritanceSources;

  public static final String SERIALIZED_NAME_IPAM_HOST = "ipam_host";
  @SerializedName(SERIALIZED_NAME_IPAM_HOST)
  @javax.annotation.Nullable
  private String ipamHost;

  public static final String SERIALIZED_NAME_LAST_QUERIED = "last_queried";
  @SerializedName(SERIALIZED_NAME_LAST_QUERIED)
  @javax.annotation.Nullable
  private OffsetDateTime lastQueried;

  public static final String SERIALIZED_NAME_NAME_IN_ZONE = "name_in_zone";
  @SerializedName(SERIALIZED_NAME_NAME_IN_ZONE)
  @javax.annotation.Nullable
  private String nameInZone;

  public static final String SERIALIZED_NAME_NIOS_METADATA = "nios_metadata";
  @SerializedName(SERIALIZED_NAME_NIOS_METADATA)
  @javax.annotation.Nullable
  private Object niosMetadata;

  public static final String SERIALIZED_NAME_OPTIONS = "options";
  @SerializedName(SERIALIZED_NAME_OPTIONS)
  @javax.annotation.Nullable
  private Object options;

  public static final String SERIALIZED_NAME_PROVIDER_METADATA = "provider_metadata";
  @SerializedName(SERIALIZED_NAME_PROVIDER_METADATA)
  @javax.annotation.Nullable
  private Object providerMetadata;

  public static final String SERIALIZED_NAME_RDATA = "rdata";
  @SerializedName(SERIALIZED_NAME_RDATA)
  @javax.annotation.Nonnull
  private Object rdata;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  @javax.annotation.Nullable
  private List<String> source = new ArrayList<>();

  public static final String SERIALIZED_NAME_SUBTYPE = "subtype";
  @SerializedName(SERIALIZED_NAME_SUBTYPE)
  @javax.annotation.Nullable
  private String subtype;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  @javax.annotation.Nullable
  private Object tags;

  public static final String SERIALIZED_NAME_TTL = "ttl";
  @SerializedName(SERIALIZED_NAME_TTL)
  @javax.annotation.Nullable
  private Long ttl;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  @javax.annotation.Nonnull
  private String type;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_VIEW = "view";
  @SerializedName(SERIALIZED_NAME_VIEW)
  @javax.annotation.Nullable
  private String view;

  public static final String SERIALIZED_NAME_VIEW_NAME = "view_name";
  @SerializedName(SERIALIZED_NAME_VIEW_NAME)
  @javax.annotation.Nullable
  private String viewName;

  public static final String SERIALIZED_NAME_ZONE = "zone";
  @SerializedName(SERIALIZED_NAME_ZONE)
  @javax.annotation.Nullable
  private String zone;

  public DataRecord() {
  }

  public DataRecord(
     String absoluteNameSpec, 
     String absoluteZoneName, 
     String compartmentId, 
     OffsetDateTime createdAt, 
     String dnsAbsoluteNameSpec, 
     String dnsAbsoluteZoneName, 
     String dnsNameInZone, 
     String dnsRdata, 
     String id, 
     List<String> source, 
     String subtype, 
     OffsetDateTime updatedAt, 
     String viewName
  ) {
    this();
    this.absoluteNameSpec = absoluteNameSpec;
    this.absoluteZoneName = absoluteZoneName;
    this.compartmentId = compartmentId;
    this.createdAt = createdAt;
    this.dnsAbsoluteNameSpec = dnsAbsoluteNameSpec;
    this.dnsAbsoluteZoneName = dnsAbsoluteZoneName;
    this.dnsNameInZone = dnsNameInZone;
    this.dnsRdata = dnsRdata;
    this.id = id;
    this.source = source;
    this.subtype = subtype;
    this.updatedAt = updatedAt;
    this.viewName = viewName;
  }

  /**
   * Synthetic field, used to determine _zone_ and/or _name_in_zone_ field for records.
   * @return absoluteNameSpec
   */
  @javax.annotation.Nullable
  public String getAbsoluteNameSpec() {
    return absoluteNameSpec;
  }



  /**
   * The absolute domain name of the zone where this record belongs.
   * @return absoluteZoneName
   */
  @javax.annotation.Nullable
  public String getAbsoluteZoneName() {
    return absoluteZoneName;
  }



  public DataRecord comment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * The description for the DNS resource record. May contain 0 to 1024 characters. Can include UTF-8.
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
  }


  /**
   * The compartment associated with the object. If no compartment is associated with the object, the value defaults to empty.
   * @return compartmentId
   */
  @javax.annotation.Nullable
  public String getCompartmentId() {
    return compartmentId;
  }



  /**
   * The timestamp when the object has been created.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  public DataRecord delegation(@javax.annotation.Nullable String delegation) {
    this.delegation = delegation;
    return this;
  }

  /**
   * The resource identifier.
   * @return delegation
   */
  @javax.annotation.Nullable
  public String getDelegation() {
    return delegation;
  }

  public void setDelegation(@javax.annotation.Nullable String delegation) {
    this.delegation = delegation;
  }


  public DataRecord disabled(@javax.annotation.Nullable Boolean disabled) {
    this.disabled = disabled;
    return this;
  }

  /**
   * Indicates if the DNS resource record is disabled. A disabled object is effectively non-existent when generating configuration.  Defaults to _false_.
   * @return disabled
   */
  @javax.annotation.Nullable
  public Boolean getDisabled() {
    return disabled;
  }

  public void setDisabled(@javax.annotation.Nullable Boolean disabled) {
    this.disabled = disabled;
  }


  /**
   * The DNS protocol textual representation of _absolute_name_spec_.
   * @return dnsAbsoluteNameSpec
   */
  @javax.annotation.Nullable
  public String getDnsAbsoluteNameSpec() {
    return dnsAbsoluteNameSpec;
  }



  /**
   * The DNS protocol textual representation of the absolute domain name of the zone where this record belongs.
   * @return dnsAbsoluteZoneName
   */
  @javax.annotation.Nullable
  public String getDnsAbsoluteZoneName() {
    return dnsAbsoluteZoneName;
  }



  /**
   * The DNS protocol textual representation of the relative owner name for the DNS zone.
   * @return dnsNameInZone
   */
  @javax.annotation.Nullable
  public String getDnsNameInZone() {
    return dnsNameInZone;
  }



  /**
   * The DNS protocol textual representation of the DNS resource record data.
   * @return dnsRdata
   */
  @javax.annotation.Nullable
  public String getDnsRdata() {
    return dnsRdata;
  }



  /**
   * The resource identifier.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public DataRecord inheritanceSources(@javax.annotation.Nullable DataRecordInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
    return this;
  }

  /**
   * Get inheritanceSources
   * @return inheritanceSources
   */
  @javax.annotation.Nullable
  public DataRecordInheritance getInheritanceSources() {
    return inheritanceSources;
  }

  public void setInheritanceSources(@javax.annotation.Nullable DataRecordInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
  }


  public DataRecord ipamHost(@javax.annotation.Nullable String ipamHost) {
    this.ipamHost = ipamHost;
    return this;
  }

  /**
   * The resource identifier.
   * @return ipamHost
   */
  @javax.annotation.Nullable
  public String getIpamHost() {
    return ipamHost;
  }

  public void setIpamHost(@javax.annotation.Nullable String ipamHost) {
    this.ipamHost = ipamHost;
  }


  public DataRecord lastQueried(@javax.annotation.Nullable OffsetDateTime lastQueried) {
    this.lastQueried = lastQueried;
    return this;
  }

  /**
   * The timestamp when the record has been last queried.  The default value is nil. Last queried can only be changed via S2S calls.
   * @return lastQueried
   */
  @javax.annotation.Nullable
  public OffsetDateTime getLastQueried() {
    return lastQueried;
  }

  public void setLastQueried(@javax.annotation.Nullable OffsetDateTime lastQueried) {
    this.lastQueried = lastQueried;
  }


  public DataRecord nameInZone(@javax.annotation.Nullable String nameInZone) {
    this.nameInZone = nameInZone;
    return this;
  }

  /**
   * The relative owner name to the zone origin. Must be specified for creating the DNS resource record and is read only for other operations.
   * @return nameInZone
   */
  @javax.annotation.Nullable
  public String getNameInZone() {
    return nameInZone;
  }

  public void setNameInZone(@javax.annotation.Nullable String nameInZone) {
    this.nameInZone = nameInZone;
  }


  public DataRecord niosMetadata(@javax.annotation.Nullable Object niosMetadata) {
    this.niosMetadata = niosMetadata;
    return this;
  }

  /**
   * NIOS Metadata holds NIOS grid&#39;s data.
   * @return niosMetadata
   */
  @javax.annotation.Nullable
  public Object getNiosMetadata() {
    return niosMetadata;
  }

  public void setNiosMetadata(@javax.annotation.Nullable Object niosMetadata) {
    this.niosMetadata = niosMetadata;
  }


  public DataRecord options(@javax.annotation.Nullable Object options) {
    this.options = options;
    return this;
  }

  /**
   * The DNS resource record type-specific non-protocol options.  Valid value for _A_ (Address) and _AAAA_ (IPv6 Address) records:  Option     | Description -----------|----------------------------------------- create_ptr | A boolean flag which can be set to _true_ for POST operation to automatically create the corresponding PTR record. check_rmz  | A boolean flag which can be set to _true_ for POST operation to check the existence of reverse zone for creating the corresponding PTR record. Only applicable if the _create_ptr_ option is set to _true_.   Valid value for _PTR_ (Pointer) records:  Option     | Description -----------|---------------------------------------- address    | For GET operation it contains the IPv4 or IPv6 address represented by the PTR record.&lt;br&gt;&lt;br&gt;For POST and PATCH operations it can be used to create/update a PTR record based on the IP address it represents. In this case, in addition to the _address_ in the options field, need to specify the _view_ field. |
   * @return options
   */
  @javax.annotation.Nullable
  public Object getOptions() {
    return options;
  }

  public void setOptions(@javax.annotation.Nullable Object options) {
    this.options = options;
  }


  public DataRecord providerMetadata(@javax.annotation.Nullable Object providerMetadata) {
    this.providerMetadata = providerMetadata;
    return this;
  }

  /**
   * external DNS provider metadata.
   * @return providerMetadata
   */
  @javax.annotation.Nullable
  public Object getProviderMetadata() {
    return providerMetadata;
  }

  public void setProviderMetadata(@javax.annotation.Nullable Object providerMetadata) {
    this.providerMetadata = providerMetadata;
  }


  public DataRecord rdata(@javax.annotation.Nonnull Object rdata) {
    this.rdata = rdata;
    return this;
  }

  /**
   * The DNS resource record data in JSON format. Certain DNS resource record-specific subfields are required for creating the DNS resource record.    Subfields for _A_ (Address) record:  Subfield | Description                           |Required ---------|---------------------------------------|-------- address  | The IPv4 address of the host.&lt;br&gt;&lt;br&gt; | Yes  Subfields for _AAAA_ (IPv6 Address) record:  Subfield | Description                           | Required ---------|---------------------------------------|--------- address  | The IPv6 address of the host.&lt;br&gt;&lt;br&gt; | Yes  Subfields for _CAA_ (Certification Authority Authorization) record:  Subfield | Description                           | Required ---------|---------------------------------------|--------- flags    | An unsigned 8-bit integer which specifies the CAA record flags. RFC 6844 defines one (highest) bit in flag octet, remaining bits are deferred for future use. This bit is referenced as _Critical_. When the bit is set (flag value &#x3D;&#x3D; 128), issuers must not issue certificates in case CAA records contain unknown property tags.&lt;br&gt;&lt;br&gt;Defaults to 0.&lt;br&gt;&lt;br&gt; | No tag      | The CAA record property tag string which indicates the type of CAA record. The following property tags are defined by RFC 6844:&lt;ul&gt;&lt;li&gt;_issue_: Used to explicitly authorize CA to issue certificates for the domain in which the property is published.&lt;/li&gt;&lt;li&gt;_issuewild_: Used to explicitly authorize a single CA to issue wildcard certificates for the domain in which the property is published.&lt;/li&gt;&lt;li&gt;_iodef_: Used to specify an email address or URL to report invalid certificate requests or issuers’ certificate policy violations.&lt;/li&gt;&lt;/ul&gt;Note: _issuewild_ type takes precedence over _issue_.&lt;br&gt;&lt;br&gt; | Yes value    | A string which contains the CAA record property value.&lt;br&gt;&lt;br&gt;Specifies the CA who is authorized to issue a certificate for the domain if the CAA record property tag is _issue_ or _issuewild_.&lt;br&gt;&lt;br&gt; Specifies the URL/email address to report CAA policy violation for the domain if the CAA record property tag is _iodef_.&lt;br&gt;&lt;br&gt; | Yes  Subfields for _CNAME_ (Canonical Name) record:  Subfield | Description                           | Required ---------|---------------------------------------|--------- cname    | A domain name which specifies the canonical or primary name for the owner. The owner name is an alias. Can be empty.&lt;br&gt;&lt;br&gt; | Yes  Subfields for _DNAME_ (Delegation Name) record:  Subfield | Description                           | Required ---------|---------------------------------------|--------- target   | The target domain name to which the zone will be mapped. Can be empty.&lt;br&gt;&lt;br&gt; | Yes  Subfields for _DHCID_ (DHCP Identifier) record:  Subfield | Description                           | Required ---------|---------------------------------------|--------- dhcid    | The Base64 encoded string which contains DHCP client information.&lt;br&gt;&lt;br&gt; | Yes  Subfields for _MX_ (Mail Exchanger) record:  Subfield   | Description                       | Required -----------|-----------------------------------|--------- exchange   | A domain name which specifies a host willing to act as a mail exchange for the owner name.&lt;br&gt;&lt;br&gt; | Yes preference | An unsigned 16-bit integer which specifies the preference given to this RR among others at the same owner. Lower values are preferred. The range of the value is 0 to 65535. &lt;br&gt;&lt;br&gt; | Yes  Subfields for _NAPTR_ (Naming Authority Pointer) record:  Subfield    | Description                         | Required ------------|-------------------------------------|--------- flags       | A character string containing flags to control aspects of the rewriting and interpretation of the fields in the DNS resource record. The flags that are currently used are: &lt;ul&gt;&lt;li&gt; __U__: Indicates that the output maps to a URI (Uniform Record Identifier). &lt;/li&gt;&lt;li&gt; __S__: Indicates that the output is a domain name that has at least one SRV record. The DNS client must then send a query for the SRV record of the resulting domain name. &lt;/li&gt;&lt;li&gt; __A__: Indicates that the output is a domain name that has at least one A or AAAA record. The DNS client must then send a query for the A or AAAA record of the resulting domain name. &lt;/li&gt;&lt;li&gt; __P__: Indicates that the protocol specified in the _services_ field defines the next step or phase. &lt;/li&gt;&lt;/ul&gt; | No order       | A 16-bit unsigned integer specifying the order in which the NAPTR records must be processed. Low numbers are processed before high numbers, and once a NAPTR is found whose rule \&quot;matches\&quot; the target, the client must not consider any NAPTRs with a higher value for order (except as noted below for the \&quot;flags\&quot; field. The range of the value is 0 to 65535. &lt;br&gt;&lt;br&gt; | Yes preference  |A 16-bit unsigned integer that specifies the order in which NAPTR records with equal \&quot;order\&quot; values should be processed, low numbers being processed before high numbers. This is similar to the preference field in an MX record, and is used so domain administrators can direct clients towards more capable hosts or lighter weight protocols. A client may look at records with higher preference values if it has a good reason to do so such as not understanding the preferred protocol or service. The range of the value is 0 to 65535.&lt;br&gt;&lt;br&gt; | Yes regexp      | A string containing a substitution expression that is applied to the original string held by the client in order to construct the next domain name to lookup.&lt;br&gt;&lt;br&gt;Defaults to none.&lt;br&gt;&lt;br&gt; | No replacement | The next name to query for NAPTR, SRV, or address records depending on the value of the _flags_ field. This can be an absolute or relative domain name. Can be empty.&lt;br&gt;&lt;br&gt; | Yes services | Specifies the service(s) available down this rewrite path. It may also specify the particular protocol that is used to talk with a service. A protocol must be specified if the flags field states that the NAPTR is terminal. If a protocol is specified, but the flags field does not state that the NAPTR is terminal, the next lookup must be for a NAPTR. The client may choose not to perform the next lookup if the protocol is unknown, but that behavior must not be relied upon.&lt;br&gt;&lt;br&gt;The service field may take any of the values below (using the Augmented BNF of RFC 2234):&lt;br&gt;&lt;br&gt;service_field &#x3D; [ [protocol] *(\&quot;+\&quot; rs)]&lt;br&gt;protocol &#x3D; ALPHA * 31 ALPHANUM&lt;br&gt;rs &#x3D; ALPHA * 31 ALPHANUM&lt;br&gt;&lt;br&gt;The protocol and rs fields are limited to 32 characters and must start with an alphabetic character.&lt;br&gt;&lt;br&gt; For example, an optional protocol specification followed by 0 or more resolution services. Each resolution service is indicated by an initial &#39;+&#39; character.&lt;br&gt;&lt;br&gt; Note that the empty string is also a valid service field.  This will typically be seen at the beginning of a series of rules, when it is impossible to know what services and protocols will be offered by a particular service.&lt;br&gt;&lt;br&gt; The actual format of the service request and response will be determined by the resolution protocol. Protocols need not offer all services. The labels for service requests shall be formed from the set of characters [A-Z0-9]. The case of the alphabetic characters is not significant.&lt;br&gt;&lt;br&gt; | Yes  Subfields for _NS_ (Name Server) record:  Subfield | Description                         | Required ---------|-------------------------------------|--------- dname    | A domain-name which specifies a host which should be authoritative for the specified class and domain. Can be absolute or relative domain name and include UTF-8. &lt;br&gt;&lt;br&gt; | Yes  Subfields for _PTR_ (Pointer) record:  Subfield | Description                         | Required ---------|-------------------------------------|--------- dname    | A domain name which points to some location in the domain name space. Can be absolute or relative domain name and include UTF-8. &lt;br&gt;&lt;br&gt; | Yes  Subfields for _SOA_ (Start of Authority) record:  Subfield     | Description                         | Required ------------ |-------------------------------------|--------- expire       | The time interval in seconds after which zone data will expire and secondary server stops answering requests for the zone.&lt;br&gt;&lt;br&gt; | No mname        | The domain name for the master server for the zone. Can be absolute or relative domain name.&lt;br&gt;&lt;br&gt; | Yes negative_ttl | The time interval in seconds for which name servers can cache negative responses for zone. &lt;br&gt;&lt;br&gt;Defaults to 900 seconds (15 minutes).&lt;br&gt;&lt;br&gt; | No refresh      | The time interval in seconds that specifies how often secondary servers need to send a message to the primary server for a zone to check that their data is current, and retrieve fresh data if it is not.&lt;br&gt;&lt;br&gt;Defaults to 10800 seconds (3 hours).&lt;br&gt;&lt;br&gt; | No retry        | The time interval in seconds for which the secondary server will wait before attempting to recontact the primary server after a connection failure occurs.&lt;br&gt;&lt;br&gt;Defaults to 3600 seconds (1 hour).&lt;br&gt;&lt;br&gt; | No rname        | The domain name which specifies the mailbox of the person responsible for this zone. &lt;br&gt;&lt;br&gt; | No serial       | An unsigned 32-bit integer that specifies the serial number of the zone. Used to indicate that zone data was updated, so the secondary name server can initiate zone transfer. The range of the value is 0 to 4294967295. &lt;br&gt;&lt;br&gt; | No  Subfields for _SRV_ (Service) record:  Subfield | Description                         | Required ---------|-------------------------------------|--------- port     | An unsigned 16-bit integer which specifies the port on this target host of this service. The range of the value is 0 to 65535. This is often as specified in Assigned Numbers but need not be.&lt;br&gt;&lt;br&gt; | Yes priority | An unsigned 16-bit integer which specifies the priority of this target host. The range of the value is 0 to 65535. A client must attempt to contact the target host with the lowest-numbered priority it can reach. Target hosts with the same priority should be tried in an order defined by the _weight_ field.&lt;br&gt;&lt;br&gt;| Yes target   | The domain name of the target host. There must be one or more address records for this name, the name must not be an alias (in the sense of RFC 1034 or RFC 2181).&lt;br&gt;&lt;br&gt;A target of \&quot;.\&quot; means that the service is decidedly not available at this domain. | Yes weight   | An unsigned 16-bit integer which specifies a relative weight for entries with the same priority. The range of the value is 0 to 65535. Larger weights should be given a proportionately higher probability of being selected. Domain administrators should use weight 0 when there isn&#39;t any server selection to do, to make the RR easier to read for humans (less noisy). In the presence of records containing weights greater than 0, records with weight 0 should have a very small chance of being selected.&lt;br&gt;&lt;br&gt;In the absence of a protocol whose specification calls for the use of other weighting information, a client arranges the SRV RRs of the same priority in the order in which target hosts, specified by the SRV RRs, will be contacted.&lt;br&gt;&lt;br&gt;Defaults to 0.&lt;br&gt;&lt;br&gt;| No  Subfields for _TXT_ (Text) record:  Subfield | Description                         | Required ---------|-------------------------------------|--------- text     | The semantics of the text depends on the domain where it is found.&lt;br&gt;&lt;br&gt; | No  Generic record can be used to represent any DNS resource record not listed above.  Subfields for a generic record consist of a list of struct subfields, each having the following sub-subfields: Sub-subfield | Description                        | Required -------------|------------------------------------|--------- type         | Following types are supported:&lt;ul&gt;&lt;li&gt;_8BIT_: Unsigned 8-bit integer. &lt;/li&gt;&lt;li&gt; _16BIT_: Unsigned 16-bit integer. &lt;/li&gt;&lt;li&gt; _32BIT_: Unsigned 32-bit integer. &lt;/li&gt;&lt;li&gt; _IPV6_: IPv6 address. For example, \&quot;abcd:123::abcd\&quot;. &lt;/li&gt;&lt;li&gt; _IPV4_: IPv4 address. For example, \&quot;1.1.1.1\&quot;. &lt;/li&gt;&lt;li&gt; _DomainName_: Domain name (absolute or relative). &lt;/li&gt;&lt;li&gt; _TEXT_: ASCII text. &lt;/li&gt;&lt;li&gt; _BASE64_: Base64 encoded binary data. &lt;/li&gt;&lt;li&gt; _HEX_: Hex encoded binary data. &lt;/li&gt;&lt;li&gt;_PRESENTATION_: Presentation is a standard textual form of record data, as shown in a standard master zone file. &lt;br&gt;&lt;br&gt; For example, an IPSEC RDATA could be specified using the PRESENTATION type field whose value is \&quot;10 1 2 192.0.2.38 AQNRU3mG7TVTO2BkR47usntb102uFJtugbo6BSGvgqt4AQ&#x3D;&#x3D;\&quot;, instead of a sequence of the following subfields: &lt;ul&gt;&lt;li&gt; 8BIT: value&#x3D;10 &lt;/li&gt;&lt;li&gt; 8BIT: value&#x3D;1 &lt;/li&gt;&lt;li&gt; 8BIT: value&#x3D;2 &lt;/li&gt;&lt;li&gt; IPV4: value&#x3D;\&quot;192.0.2.38\&quot; &lt;/li&gt;&lt;li&gt; BASE64 (without _length_kind_ sub-subfield): value&#x3D;\&quot;AQNRU3mG7TVTO2BkR47usntb102uFJtugbo6BSGvgqt4AQ&#x3D;&#x3D;\&quot; &lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;If type is _PRESENTATION_, only one struct subfield can be specified. &lt;br&gt;&lt;br&gt; | Yes length_kind  | A string indicating the size in bits of a sub-subfield that is prepended to the value and encodes the length of the value. Valid values are:&lt;ul&gt;&lt;li&gt;_8_: If _type_ is _ASCII_ or _BASE64_. &lt;/li&gt;&lt;li&gt;_16_: If _type_ is _HEX_.&lt;/li&gt;&lt;/ul&gt;Defaults to none. &lt;br&gt;&lt;br&gt;| Only required for some types. value        | A string representing the value for the sub-subfield | Yes
   * @return rdata
   */
  @javax.annotation.Nonnull
  public Object getRdata() {
    return rdata;
  }

  public void setRdata(@javax.annotation.Nonnull Object rdata) {
    this.rdata = rdata;
  }


  /**
   * Source indicator                    | Description ------------------------------------|-------------------------------- _STATIC_                            |  Record was created manually by API call to _dns/record_. Valid for all record types except _SOA_. _SYSTEM_                            |  Record was created automatically based on name server assignment. Valid for _SOA_, _NS_, _A_, _AAAA_, and _PTR_ record types. _DYNAMIC_                           |  Record was created dynamically by performing dynamic update. Valid for all record types except _SOA_. _DELEGATED_                         |  Record was created automatically based on delegation servers assignment. Always extends the _SYSTEM_ bit. Valid for _NS_, _A_, _AAAA_, and _PTR_ record types. _DTC_                               |  Record was created automatically based on the DTC configuration. Always extends the _SYSTEM_ bit. Valid only for _IBMETA_ record type with _LBDN_ subtype. _STATIC_, _SYSTEM_                  |  Record was created manually by API call but it is obfuscated by record generated based on name server assignment. _DYNAMIC_, _SYSTEM_                 |  Record was created dynamically by DDNS but it is obfuscated by record generated based on name server assignment. _DELEGATED_, _SYSTEM_               |  Record was created automatically based on delegation servers assignment. _SYSTEM_ will always accompany _DELEGATED_. _DTC_, _SYSTEM_                     |  Record was created automatically based on the DTC configuration. _SYSTEM_ will always accompany _DTC_. _STATIC_, _SYSTEM_, _DELEGATED_     |  Record was created manually by API call but it is obfuscated by record generated based on name server assignment as a result of creating a delegation. _DYNAMIC_, _SYSTEM_, _DELEGATED_    |  Record was created dynamically by DDNS but it is obfuscated by record generated based on name server assignment as a result of creating a delegation.
   * @return source
   */
  @javax.annotation.Nullable
  public List<String> getSource() {
    return source;
  }



  /**
   * The DNS resource record subtype specified in the textual mnemonic format. Valid only in case _type_ is _IBMETA_.  Value | Numeric Type | Description ------|--------------|--------------------------------------------- | 0            | Default value LBDN  | 1            | LBDN record
   * @return subtype
   */
  @javax.annotation.Nullable
  public String getSubtype() {
    return subtype;
  }



  public DataRecord tags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
    return this;
  }

  /**
   * The tags for the DNS resource record in JSON format.
   * @return tags
   */
  @javax.annotation.Nullable
  public Object getTags() {
    return tags;
  }

  public void setTags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
  }


  public DataRecord ttl(@javax.annotation.Nullable Long ttl) {
    this.ttl = ttl;
    return this;
  }

  /**
   * The record time to live value in seconds. The range of this value is 0 to 2147483647.  Defaults to TTL value from the SOA record of the zone.
   * @return ttl
   */
  @javax.annotation.Nullable
  public Long getTtl() {
    return ttl;
  }

  public void setTtl(@javax.annotation.Nullable Long ttl) {
    this.ttl = ttl;
  }


  public DataRecord type(@javax.annotation.Nonnull String type) {
    this.type = type;
    return this;
  }

  /**
   * The DNS resource record type specified in the textual mnemonic format or in the \&quot;TYPEnnn\&quot; format where \&quot;nnn\&quot; indicates the numeric type value.  Value  | Numeric Type | Description -------|--------------|--------------------------------------------- A      | 1            | Address record AAAA   | 28           | IPv6 Address record CAA    | 257          | Certification Authority Authorization record CNAME  | 5            | Canonical Name record DNAME  | 39           | Delegation Name record DHCID  | 49           | DHCP Identifier record HTTPS  | 65           | HTTPS Record MX     | 15           | Mail Exchanger record NAPTR  | 35           | Naming Authority Pointer record NS     | 2            | Name Server record PTR    | 12           | Pointer record SOA    | 6            | Start of Authority record SRV    | 33           | Service record SVCB   | 64           | Service Binding Record TXT    | 16           | Text record IBMETA | 65536        | Infoblox meta records, not valid for DNS protocol (read-only)
   * @return type
   */
  @javax.annotation.Nonnull
  public String getType() {
    return type;
  }

  public void setType(@javax.annotation.Nonnull String type) {
    this.type = type;
  }


  /**
   * The timestamp when the object has been updated. Equals to _created_at_ if not updated after creation.
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }



  public DataRecord view(@javax.annotation.Nullable String view) {
    this.view = view;
    return this;
  }

  /**
   * The resource identifier.
   * @return view
   */
  @javax.annotation.Nullable
  public String getView() {
    return view;
  }

  public void setView(@javax.annotation.Nullable String view) {
    this.view = view;
  }


  /**
   * The display name of the DNS view that contains the parent zone of the DNS resource record.
   * @return viewName
   */
  @javax.annotation.Nullable
  public String getViewName() {
    return viewName;
  }



  public DataRecord zone(@javax.annotation.Nullable String zone) {
    this.zone = zone;
    return this;
  }

  /**
   * The resource identifier.
   * @return zone
   */
  @javax.annotation.Nullable
  public String getZone() {
    return zone;
  }

  public void setZone(@javax.annotation.Nullable String zone) {
    this.zone = zone;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DataRecord dataRecord = (DataRecord) o;
    return Objects.equals(this.absoluteNameSpec, dataRecord.absoluteNameSpec) &&
        Objects.equals(this.absoluteZoneName, dataRecord.absoluteZoneName) &&
        Objects.equals(this.comment, dataRecord.comment) &&
        Objects.equals(this.compartmentId, dataRecord.compartmentId) &&
        Objects.equals(this.createdAt, dataRecord.createdAt) &&
        Objects.equals(this.delegation, dataRecord.delegation) &&
        Objects.equals(this.disabled, dataRecord.disabled) &&
        Objects.equals(this.dnsAbsoluteNameSpec, dataRecord.dnsAbsoluteNameSpec) &&
        Objects.equals(this.dnsAbsoluteZoneName, dataRecord.dnsAbsoluteZoneName) &&
        Objects.equals(this.dnsNameInZone, dataRecord.dnsNameInZone) &&
        Objects.equals(this.dnsRdata, dataRecord.dnsRdata) &&
        Objects.equals(this.id, dataRecord.id) &&
        Objects.equals(this.inheritanceSources, dataRecord.inheritanceSources) &&
        Objects.equals(this.ipamHost, dataRecord.ipamHost) &&
        Objects.equals(this.lastQueried, dataRecord.lastQueried) &&
        Objects.equals(this.nameInZone, dataRecord.nameInZone) &&
        Objects.equals(this.niosMetadata, dataRecord.niosMetadata) &&
        Objects.equals(this.options, dataRecord.options) &&
        Objects.equals(this.providerMetadata, dataRecord.providerMetadata) &&
        Objects.equals(this.rdata, dataRecord.rdata) &&
        Objects.equals(this.source, dataRecord.source) &&
        Objects.equals(this.subtype, dataRecord.subtype) &&
        Objects.equals(this.tags, dataRecord.tags) &&
        Objects.equals(this.ttl, dataRecord.ttl) &&
        Objects.equals(this.type, dataRecord.type) &&
        Objects.equals(this.updatedAt, dataRecord.updatedAt) &&
        Objects.equals(this.view, dataRecord.view) &&
        Objects.equals(this.viewName, dataRecord.viewName) &&
        Objects.equals(this.zone, dataRecord.zone);
  }

  @Override
  public int hashCode() {
    return Objects.hash(absoluteNameSpec, absoluteZoneName, comment, compartmentId, createdAt, delegation, disabled, dnsAbsoluteNameSpec, dnsAbsoluteZoneName, dnsNameInZone, dnsRdata, id, inheritanceSources, ipamHost, lastQueried, nameInZone, niosMetadata, options, providerMetadata, rdata, source, subtype, tags, ttl, type, updatedAt, view, viewName, zone);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DataRecord {\n");
    sb.append("    absoluteNameSpec: ").append(toIndentedString(absoluteNameSpec)).append("\n");
    sb.append("    absoluteZoneName: ").append(toIndentedString(absoluteZoneName)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    compartmentId: ").append(toIndentedString(compartmentId)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    delegation: ").append(toIndentedString(delegation)).append("\n");
    sb.append("    disabled: ").append(toIndentedString(disabled)).append("\n");
    sb.append("    dnsAbsoluteNameSpec: ").append(toIndentedString(dnsAbsoluteNameSpec)).append("\n");
    sb.append("    dnsAbsoluteZoneName: ").append(toIndentedString(dnsAbsoluteZoneName)).append("\n");
    sb.append("    dnsNameInZone: ").append(toIndentedString(dnsNameInZone)).append("\n");
    sb.append("    dnsRdata: ").append(toIndentedString(dnsRdata)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    inheritanceSources: ").append(toIndentedString(inheritanceSources)).append("\n");
    sb.append("    ipamHost: ").append(toIndentedString(ipamHost)).append("\n");
    sb.append("    lastQueried: ").append(toIndentedString(lastQueried)).append("\n");
    sb.append("    nameInZone: ").append(toIndentedString(nameInZone)).append("\n");
    sb.append("    niosMetadata: ").append(toIndentedString(niosMetadata)).append("\n");
    sb.append("    options: ").append(toIndentedString(options)).append("\n");
    sb.append("    providerMetadata: ").append(toIndentedString(providerMetadata)).append("\n");
    sb.append("    rdata: ").append(toIndentedString(rdata)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    subtype: ").append(toIndentedString(subtype)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    ttl: ").append(toIndentedString(ttl)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    view: ").append(toIndentedString(view)).append("\n");
    sb.append("    viewName: ").append(toIndentedString(viewName)).append("\n");
    sb.append("    zone: ").append(toIndentedString(zone)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("absolute_name_spec");
    openapiFields.add("absolute_zone_name");
    openapiFields.add("comment");
    openapiFields.add("compartment_id");
    openapiFields.add("created_at");
    openapiFields.add("delegation");
    openapiFields.add("disabled");
    openapiFields.add("dns_absolute_name_spec");
    openapiFields.add("dns_absolute_zone_name");
    openapiFields.add("dns_name_in_zone");
    openapiFields.add("dns_rdata");
    openapiFields.add("id");
    openapiFields.add("inheritance_sources");
    openapiFields.add("ipam_host");
    openapiFields.add("last_queried");
    openapiFields.add("name_in_zone");
    openapiFields.add("nios_metadata");
    openapiFields.add("options");
    openapiFields.add("provider_metadata");
    openapiFields.add("rdata");
    openapiFields.add("source");
    openapiFields.add("subtype");
    openapiFields.add("tags");
    openapiFields.add("ttl");
    openapiFields.add("type");
    openapiFields.add("updated_at");
    openapiFields.add("view");
    openapiFields.add("view_name");
    openapiFields.add("zone");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("rdata");
    openapiRequiredFields.add("type");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to DataRecord
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DataRecord.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DataRecord is not found in the empty JSON string", DataRecord.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DataRecord.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DataRecord` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : DataRecord.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("absolute_name_spec") != null && !jsonObj.get("absolute_name_spec").isJsonNull()) && !jsonObj.get("absolute_name_spec").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `absolute_name_spec` to be a primitive type in the JSON string but got `%s`", jsonObj.get("absolute_name_spec").toString()));
      }
      if ((jsonObj.get("absolute_zone_name") != null && !jsonObj.get("absolute_zone_name").isJsonNull()) && !jsonObj.get("absolute_zone_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `absolute_zone_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("absolute_zone_name").toString()));
      }
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if ((jsonObj.get("compartment_id") != null && !jsonObj.get("compartment_id").isJsonNull()) && !jsonObj.get("compartment_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compartment_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compartment_id").toString()));
      }
      if ((jsonObj.get("delegation") != null && !jsonObj.get("delegation").isJsonNull()) && !jsonObj.get("delegation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `delegation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("delegation").toString()));
      }
      if ((jsonObj.get("dns_absolute_name_spec") != null && !jsonObj.get("dns_absolute_name_spec").isJsonNull()) && !jsonObj.get("dns_absolute_name_spec").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dns_absolute_name_spec` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dns_absolute_name_spec").toString()));
      }
      if ((jsonObj.get("dns_absolute_zone_name") != null && !jsonObj.get("dns_absolute_zone_name").isJsonNull()) && !jsonObj.get("dns_absolute_zone_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dns_absolute_zone_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dns_absolute_zone_name").toString()));
      }
      if ((jsonObj.get("dns_name_in_zone") != null && !jsonObj.get("dns_name_in_zone").isJsonNull()) && !jsonObj.get("dns_name_in_zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dns_name_in_zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dns_name_in_zone").toString()));
      }
      if ((jsonObj.get("dns_rdata") != null && !jsonObj.get("dns_rdata").isJsonNull()) && !jsonObj.get("dns_rdata").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dns_rdata` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dns_rdata").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `inheritance_sources`
      if (jsonObj.get("inheritance_sources") != null && !jsonObj.get("inheritance_sources").isJsonNull()) {
        DataRecordInheritance.validateJsonElement(jsonObj.get("inheritance_sources"));
      }
      if ((jsonObj.get("ipam_host") != null && !jsonObj.get("ipam_host").isJsonNull()) && !jsonObj.get("ipam_host").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ipam_host` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ipam_host").toString()));
      }
      if ((jsonObj.get("name_in_zone") != null && !jsonObj.get("name_in_zone").isJsonNull()) && !jsonObj.get("name_in_zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name_in_zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name_in_zone").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("source") != null && !jsonObj.get("source").isJsonNull() && !jsonObj.get("source").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `source` to be an array in the JSON string but got `%s`", jsonObj.get("source").toString()));
      }
      if ((jsonObj.get("subtype") != null && !jsonObj.get("subtype").isJsonNull()) && !jsonObj.get("subtype").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subtype` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subtype").toString()));
      }
      if (!jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      if ((jsonObj.get("view") != null && !jsonObj.get("view").isJsonNull()) && !jsonObj.get("view").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `view` to be a primitive type in the JSON string but got `%s`", jsonObj.get("view").toString()));
      }
      if ((jsonObj.get("view_name") != null && !jsonObj.get("view_name").isJsonNull()) && !jsonObj.get("view_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `view_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("view_name").toString()));
      }
      if ((jsonObj.get("zone") != null && !jsonObj.get("zone").isJsonNull()) && !jsonObj.get("zone").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zone` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zone").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DataRecord.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DataRecord' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DataRecord> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DataRecord.class));

       return (TypeAdapter<T>) new TypeAdapter<DataRecord>() {
           @Override
           public void write(JsonWriter out, DataRecord value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DataRecord read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of DataRecord given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of DataRecord
   * @throws IOException if the JSON string is invalid with respect to DataRecord
   */
  public static DataRecord fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DataRecord.class);
  }

  /**
   * Convert an instance of DataRecord to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

