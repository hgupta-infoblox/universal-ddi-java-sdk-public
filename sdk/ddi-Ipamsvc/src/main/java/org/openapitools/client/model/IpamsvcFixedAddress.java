/*
 * IP Address Management API
 * The IPAM/DHCP Application is a BloxOne DDI service providing IP address management and DHCP protocol features. The IPAM component provides visibility into and provisioning tools to manage networking spaces, monitoring and reporting of entire IP address infrastructures, and integration with DNS and DHCP protocols. The DHCP component provides DHCP protocol configuration service with on-prem host serving DHCP protocol. It is part of the full-featured, DDI cloud solution that enables customers to deploy large numbers of protocol servers to deliver DNS and DHCP throughout their enterprise network.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.InheritanceAssignedHost;
import org.openapitools.client.model.IpamsvcFixedAddressInheritance;
import org.openapitools.client.model.IpamsvcOptionItem;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A __FixedAddress__ object (_dhcp/fixed_address_) reserves an address for a specific client. It must have a _match_type_ and a valid corresponding _match_value_ so it can match that client.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:31.429972+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class IpamsvcFixedAddress {
  public static final String SERIALIZED_NAME_ADDRESS = "address";
  @SerializedName(SERIALIZED_NAME_ADDRESS)
  @javax.annotation.Nonnull
  private String address;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  @javax.annotation.Nullable
  private String comment;

  public static final String SERIALIZED_NAME_COMPARTMENT_ID = "compartment_id";
  @SerializedName(SERIALIZED_NAME_COMPARTMENT_ID)
  @javax.annotation.Nullable
  private String compartmentId;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DHCP_OPTIONS = "dhcp_options";
  @SerializedName(SERIALIZED_NAME_DHCP_OPTIONS)
  @javax.annotation.Nullable
  private List<IpamsvcOptionItem> dhcpOptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DISABLE_DHCP = "disable_dhcp";
  @SerializedName(SERIALIZED_NAME_DISABLE_DHCP)
  @javax.annotation.Nullable
  private Boolean disableDhcp;

  public static final String SERIALIZED_NAME_HEADER_OPTION_FILENAME = "header_option_filename";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_FILENAME)
  @javax.annotation.Nullable
  private String headerOptionFilename;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS = "header_option_server_address";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS)
  @javax.annotation.Nullable
  private String headerOptionServerAddress;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME = "header_option_server_name";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME)
  @javax.annotation.Nullable
  private String headerOptionServerName;

  public static final String SERIALIZED_NAME_HOSTNAME = "hostname";
  @SerializedName(SERIALIZED_NAME_HOSTNAME)
  @javax.annotation.Nullable
  private String hostname;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_INHERITANCE_ASSIGNED_HOSTS = "inheritance_assigned_hosts";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_ASSIGNED_HOSTS)
  @javax.annotation.Nullable
  private List<InheritanceAssignedHost> inheritanceAssignedHosts = new ArrayList<>();

  public static final String SERIALIZED_NAME_INHERITANCE_PARENT = "inheritance_parent";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_PARENT)
  @javax.annotation.Nullable
  private String inheritanceParent;

  public static final String SERIALIZED_NAME_INHERITANCE_SOURCES = "inheritance_sources";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_SOURCES)
  @javax.annotation.Nullable
  private IpamsvcFixedAddressInheritance inheritanceSources;

  public static final String SERIALIZED_NAME_IP_SPACE = "ip_space";
  @SerializedName(SERIALIZED_NAME_IP_SPACE)
  @javax.annotation.Nullable
  private String ipSpace;

  public static final String SERIALIZED_NAME_MATCH_TYPE = "match_type";
  @SerializedName(SERIALIZED_NAME_MATCH_TYPE)
  @javax.annotation.Nonnull
  private String matchType;

  public static final String SERIALIZED_NAME_MATCH_VALUE = "match_value";
  @SerializedName(SERIALIZED_NAME_MATCH_VALUE)
  @javax.annotation.Nonnull
  private String matchValue;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nullable
  private String name;

  public static final String SERIALIZED_NAME_PARENT = "parent";
  @SerializedName(SERIALIZED_NAME_PARENT)
  @javax.annotation.Nullable
  private String parent;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  @javax.annotation.Nullable
  private Object tags;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime updatedAt;

  public IpamsvcFixedAddress() {
  }

  public IpamsvcFixedAddress(
     String compartmentId, 
     OffsetDateTime createdAt, 
     String id, 
     List<InheritanceAssignedHost> inheritanceAssignedHosts, 
     OffsetDateTime updatedAt
  ) {
    this();
    this.compartmentId = compartmentId;
    this.createdAt = createdAt;
    this.id = id;
    this.inheritanceAssignedHosts = inheritanceAssignedHosts;
    this.updatedAt = updatedAt;
  }

  public IpamsvcFixedAddress address(@javax.annotation.Nonnull String address) {
    this.address = address;
    return this;
  }

  /**
   * The reserved address.
   * @return address
   */
  @javax.annotation.Nonnull
  public String getAddress() {
    return address;
  }

  public void setAddress(@javax.annotation.Nonnull String address) {
    this.address = address;
  }


  public IpamsvcFixedAddress comment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * The description for the fixed address. May contain 0 to 1024 characters. Can include UTF-8.
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
  }


  /**
   * The access view associated with the object. If no access view is associated with the object, the value defaults to empty.
   * @return compartmentId
   */
  @javax.annotation.Nullable
  public String getCompartmentId() {
    return compartmentId;
  }



  /**
   * Time when the object has been created.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  public IpamsvcFixedAddress dhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
    return this;
  }

  public IpamsvcFixedAddress addDhcpOptionsItem(IpamsvcOptionItem dhcpOptionsItem) {
    if (this.dhcpOptions == null) {
      this.dhcpOptions = new ArrayList<>();
    }
    this.dhcpOptions.add(dhcpOptionsItem);
    return this;
  }

  /**
   * The list of DHCP options. May be either a specific option or a group of options.
   * @return dhcpOptions
   */
  @javax.annotation.Nullable
  public List<IpamsvcOptionItem> getDhcpOptions() {
    return dhcpOptions;
  }

  public void setDhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
  }


  public IpamsvcFixedAddress disableDhcp(@javax.annotation.Nullable Boolean disableDhcp) {
    this.disableDhcp = disableDhcp;
    return this;
  }

  /**
   * Optional. _true_ to disable object. The fixed address is converted to an exclusion when generating configuration.  Defaults to _false_.
   * @return disableDhcp
   */
  @javax.annotation.Nullable
  public Boolean getDisableDhcp() {
    return disableDhcp;
  }

  public void setDisableDhcp(@javax.annotation.Nullable Boolean disableDhcp) {
    this.disableDhcp = disableDhcp;
  }


  public IpamsvcFixedAddress headerOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
    return this;
  }

  /**
   * The configuration for header option filename field.
   * @return headerOptionFilename
   */
  @javax.annotation.Nullable
  public String getHeaderOptionFilename() {
    return headerOptionFilename;
  }

  public void setHeaderOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
  }


  public IpamsvcFixedAddress headerOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
    return this;
  }

  /**
   * The configuration for header option server address field.
   * @return headerOptionServerAddress
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerAddress() {
    return headerOptionServerAddress;
  }

  public void setHeaderOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
  }


  public IpamsvcFixedAddress headerOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
    return this;
  }

  /**
   * The configuration for header option server name field.
   * @return headerOptionServerName
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerName() {
    return headerOptionServerName;
  }

  public void setHeaderOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
  }


  public IpamsvcFixedAddress hostname(@javax.annotation.Nullable String hostname) {
    this.hostname = hostname;
    return this;
  }

  /**
   * The DHCP host name associated with this fixed address. It is of FQDN type and it defaults to empty.
   * @return hostname
   */
  @javax.annotation.Nullable
  public String getHostname() {
    return hostname;
  }

  public void setHostname(@javax.annotation.Nullable String hostname) {
    this.hostname = hostname;
  }


  /**
   * The resource identifier.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  /**
   * The list of the inheritance assigned hosts of the object.
   * @return inheritanceAssignedHosts
   */
  @javax.annotation.Nullable
  public List<InheritanceAssignedHost> getInheritanceAssignedHosts() {
    return inheritanceAssignedHosts;
  }



  public IpamsvcFixedAddress inheritanceParent(@javax.annotation.Nullable String inheritanceParent) {
    this.inheritanceParent = inheritanceParent;
    return this;
  }

  /**
   * The resource identifier.
   * @return inheritanceParent
   */
  @javax.annotation.Nullable
  public String getInheritanceParent() {
    return inheritanceParent;
  }

  public void setInheritanceParent(@javax.annotation.Nullable String inheritanceParent) {
    this.inheritanceParent = inheritanceParent;
  }


  public IpamsvcFixedAddress inheritanceSources(@javax.annotation.Nullable IpamsvcFixedAddressInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
    return this;
  }

  /**
   * Get inheritanceSources
   * @return inheritanceSources
   */
  @javax.annotation.Nullable
  public IpamsvcFixedAddressInheritance getInheritanceSources() {
    return inheritanceSources;
  }

  public void setInheritanceSources(@javax.annotation.Nullable IpamsvcFixedAddressInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
  }


  public IpamsvcFixedAddress ipSpace(@javax.annotation.Nullable String ipSpace) {
    this.ipSpace = ipSpace;
    return this;
  }

  /**
   * The resource identifier.
   * @return ipSpace
   */
  @javax.annotation.Nullable
  public String getIpSpace() {
    return ipSpace;
  }

  public void setIpSpace(@javax.annotation.Nullable String ipSpace) {
    this.ipSpace = ipSpace;
  }


  public IpamsvcFixedAddress matchType(@javax.annotation.Nonnull String matchType) {
    this.matchType = matchType;
    return this;
  }

  /**
   * Indicates how to match the client:  * _mac_: match the client MAC address for both IPv4 and IPv6,  * _client_text_ or _client_hex_: match the client identifier for IPv4 only,  * _relay_text_ or _relay_hex_: match the circuit ID or remote ID in the DHCP relay agent option (82) for IPv4 only,  * _duid_: match the DHCP unique identifier, currently match only for IPv6 protocol.
   * @return matchType
   */
  @javax.annotation.Nonnull
  public String getMatchType() {
    return matchType;
  }

  public void setMatchType(@javax.annotation.Nonnull String matchType) {
    this.matchType = matchType;
  }


  public IpamsvcFixedAddress matchValue(@javax.annotation.Nonnull String matchValue) {
    this.matchValue = matchValue;
    return this;
  }

  /**
   * The value to match.
   * @return matchValue
   */
  @javax.annotation.Nonnull
  public String getMatchValue() {
    return matchValue;
  }

  public void setMatchValue(@javax.annotation.Nonnull String matchValue) {
    this.matchValue = matchValue;
  }


  public IpamsvcFixedAddress name(@javax.annotation.Nullable String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the fixed address. May contain 1 to 256 characters. Can include UTF-8.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nullable String name) {
    this.name = name;
  }


  public IpamsvcFixedAddress parent(@javax.annotation.Nullable String parent) {
    this.parent = parent;
    return this;
  }

  /**
   * The resource identifier.
   * @return parent
   */
  @javax.annotation.Nullable
  public String getParent() {
    return parent;
  }

  public void setParent(@javax.annotation.Nullable String parent) {
    this.parent = parent;
  }


  public IpamsvcFixedAddress tags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
    return this;
  }

  /**
   * The tags for the fixed address in JSON format.
   * @return tags
   */
  @javax.annotation.Nullable
  public Object getTags() {
    return tags;
  }

  public void setTags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
  }


  /**
   * Time when the object has been updated. Equals to _created_at_ if not updated after creation.
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IpamsvcFixedAddress ipamsvcFixedAddress = (IpamsvcFixedAddress) o;
    return Objects.equals(this.address, ipamsvcFixedAddress.address) &&
        Objects.equals(this.comment, ipamsvcFixedAddress.comment) &&
        Objects.equals(this.compartmentId, ipamsvcFixedAddress.compartmentId) &&
        Objects.equals(this.createdAt, ipamsvcFixedAddress.createdAt) &&
        Objects.equals(this.dhcpOptions, ipamsvcFixedAddress.dhcpOptions) &&
        Objects.equals(this.disableDhcp, ipamsvcFixedAddress.disableDhcp) &&
        Objects.equals(this.headerOptionFilename, ipamsvcFixedAddress.headerOptionFilename) &&
        Objects.equals(this.headerOptionServerAddress, ipamsvcFixedAddress.headerOptionServerAddress) &&
        Objects.equals(this.headerOptionServerName, ipamsvcFixedAddress.headerOptionServerName) &&
        Objects.equals(this.hostname, ipamsvcFixedAddress.hostname) &&
        Objects.equals(this.id, ipamsvcFixedAddress.id) &&
        Objects.equals(this.inheritanceAssignedHosts, ipamsvcFixedAddress.inheritanceAssignedHosts) &&
        Objects.equals(this.inheritanceParent, ipamsvcFixedAddress.inheritanceParent) &&
        Objects.equals(this.inheritanceSources, ipamsvcFixedAddress.inheritanceSources) &&
        Objects.equals(this.ipSpace, ipamsvcFixedAddress.ipSpace) &&
        Objects.equals(this.matchType, ipamsvcFixedAddress.matchType) &&
        Objects.equals(this.matchValue, ipamsvcFixedAddress.matchValue) &&
        Objects.equals(this.name, ipamsvcFixedAddress.name) &&
        Objects.equals(this.parent, ipamsvcFixedAddress.parent) &&
        Objects.equals(this.tags, ipamsvcFixedAddress.tags) &&
        Objects.equals(this.updatedAt, ipamsvcFixedAddress.updatedAt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(address, comment, compartmentId, createdAt, dhcpOptions, disableDhcp, headerOptionFilename, headerOptionServerAddress, headerOptionServerName, hostname, id, inheritanceAssignedHosts, inheritanceParent, inheritanceSources, ipSpace, matchType, matchValue, name, parent, tags, updatedAt);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IpamsvcFixedAddress {\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    compartmentId: ").append(toIndentedString(compartmentId)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    dhcpOptions: ").append(toIndentedString(dhcpOptions)).append("\n");
    sb.append("    disableDhcp: ").append(toIndentedString(disableDhcp)).append("\n");
    sb.append("    headerOptionFilename: ").append(toIndentedString(headerOptionFilename)).append("\n");
    sb.append("    headerOptionServerAddress: ").append(toIndentedString(headerOptionServerAddress)).append("\n");
    sb.append("    headerOptionServerName: ").append(toIndentedString(headerOptionServerName)).append("\n");
    sb.append("    hostname: ").append(toIndentedString(hostname)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    inheritanceAssignedHosts: ").append(toIndentedString(inheritanceAssignedHosts)).append("\n");
    sb.append("    inheritanceParent: ").append(toIndentedString(inheritanceParent)).append("\n");
    sb.append("    inheritanceSources: ").append(toIndentedString(inheritanceSources)).append("\n");
    sb.append("    ipSpace: ").append(toIndentedString(ipSpace)).append("\n");
    sb.append("    matchType: ").append(toIndentedString(matchType)).append("\n");
    sb.append("    matchValue: ").append(toIndentedString(matchValue)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    parent: ").append(toIndentedString(parent)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("address");
    openapiFields.add("comment");
    openapiFields.add("compartment_id");
    openapiFields.add("created_at");
    openapiFields.add("dhcp_options");
    openapiFields.add("disable_dhcp");
    openapiFields.add("header_option_filename");
    openapiFields.add("header_option_server_address");
    openapiFields.add("header_option_server_name");
    openapiFields.add("hostname");
    openapiFields.add("id");
    openapiFields.add("inheritance_assigned_hosts");
    openapiFields.add("inheritance_parent");
    openapiFields.add("inheritance_sources");
    openapiFields.add("ip_space");
    openapiFields.add("match_type");
    openapiFields.add("match_value");
    openapiFields.add("name");
    openapiFields.add("parent");
    openapiFields.add("tags");
    openapiFields.add("updated_at");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("address");
    openapiRequiredFields.add("match_type");
    openapiRequiredFields.add("match_value");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IpamsvcFixedAddress
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IpamsvcFixedAddress.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IpamsvcFixedAddress is not found in the empty JSON string", IpamsvcFixedAddress.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IpamsvcFixedAddress.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IpamsvcFixedAddress` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : IpamsvcFixedAddress.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("address").toString()));
      }
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if ((jsonObj.get("compartment_id") != null && !jsonObj.get("compartment_id").isJsonNull()) && !jsonObj.get("compartment_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compartment_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compartment_id").toString()));
      }
      if (jsonObj.get("dhcp_options") != null && !jsonObj.get("dhcp_options").isJsonNull()) {
        JsonArray jsonArraydhcpOptions = jsonObj.getAsJsonArray("dhcp_options");
        if (jsonArraydhcpOptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dhcp_options").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dhcp_options` to be an array in the JSON string but got `%s`", jsonObj.get("dhcp_options").toString()));
          }

          // validate the optional field `dhcp_options` (array)
          for (int i = 0; i < jsonArraydhcpOptions.size(); i++) {
            IpamsvcOptionItem.validateJsonElement(jsonArraydhcpOptions.get(i));
          };
        }
      }
      if ((jsonObj.get("header_option_filename") != null && !jsonObj.get("header_option_filename").isJsonNull()) && !jsonObj.get("header_option_filename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_filename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_filename").toString()));
      }
      if ((jsonObj.get("header_option_server_address") != null && !jsonObj.get("header_option_server_address").isJsonNull()) && !jsonObj.get("header_option_server_address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_address").toString()));
      }
      if ((jsonObj.get("header_option_server_name") != null && !jsonObj.get("header_option_server_name").isJsonNull()) && !jsonObj.get("header_option_server_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_name").toString()));
      }
      if ((jsonObj.get("hostname") != null && !jsonObj.get("hostname").isJsonNull()) && !jsonObj.get("hostname").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (jsonObj.get("inheritance_assigned_hosts") != null && !jsonObj.get("inheritance_assigned_hosts").isJsonNull()) {
        JsonArray jsonArrayinheritanceAssignedHosts = jsonObj.getAsJsonArray("inheritance_assigned_hosts");
        if (jsonArrayinheritanceAssignedHosts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("inheritance_assigned_hosts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `inheritance_assigned_hosts` to be an array in the JSON string but got `%s`", jsonObj.get("inheritance_assigned_hosts").toString()));
          }

          // validate the optional field `inheritance_assigned_hosts` (array)
          for (int i = 0; i < jsonArrayinheritanceAssignedHosts.size(); i++) {
            InheritanceAssignedHost.validateJsonElement(jsonArrayinheritanceAssignedHosts.get(i));
          };
        }
      }
      if ((jsonObj.get("inheritance_parent") != null && !jsonObj.get("inheritance_parent").isJsonNull()) && !jsonObj.get("inheritance_parent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inheritance_parent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inheritance_parent").toString()));
      }
      // validate the optional field `inheritance_sources`
      if (jsonObj.get("inheritance_sources") != null && !jsonObj.get("inheritance_sources").isJsonNull()) {
        IpamsvcFixedAddressInheritance.validateJsonElement(jsonObj.get("inheritance_sources"));
      }
      if ((jsonObj.get("ip_space") != null && !jsonObj.get("ip_space").isJsonNull()) && !jsonObj.get("ip_space").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ip_space` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ip_space").toString()));
      }
      if (!jsonObj.get("match_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `match_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("match_type").toString()));
      }
      if (!jsonObj.get("match_value").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `match_value` to be a primitive type in the JSON string but got `%s`", jsonObj.get("match_value").toString()));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("parent") != null && !jsonObj.get("parent").isJsonNull()) && !jsonObj.get("parent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `parent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("parent").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IpamsvcFixedAddress.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IpamsvcFixedAddress' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IpamsvcFixedAddress> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IpamsvcFixedAddress.class));

       return (TypeAdapter<T>) new TypeAdapter<IpamsvcFixedAddress>() {
           @Override
           public void write(JsonWriter out, IpamsvcFixedAddress value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IpamsvcFixedAddress read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IpamsvcFixedAddress given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IpamsvcFixedAddress
   * @throws IOException if the JSON string is invalid with respect to IpamsvcFixedAddress
   */
  public static IpamsvcFixedAddress fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IpamsvcFixedAddress.class);
  }

  /**
   * Convert an instance of IpamsvcFixedAddress to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

