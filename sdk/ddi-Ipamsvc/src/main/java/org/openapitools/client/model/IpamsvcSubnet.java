/*
 * IP Address Management API
 * The IPAM/DHCP Application is a BloxOne DDI service providing IP address management and DHCP protocol features. The IPAM component provides visibility into and provisioning tools to manage networking spaces, monitoring and reporting of entire IP address infrastructures, and integration with DNS and DHCP protocols. The DHCP component provides DHCP protocol configuration service with on-prem host serving DHCP protocol. It is part of the full-featured, DDI cloud solution that enables customers to deploy large numbers of protocol servers to deliver DNS and DHCP throughout their enterprise network.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.InheritanceAssignedHost;
import org.openapitools.client.model.IpamsvcASMConfig;
import org.openapitools.client.model.IpamsvcDHCPConfig;
import org.openapitools.client.model.IpamsvcDHCPInheritance;
import org.openapitools.client.model.IpamsvcDHCPUtilization;
import org.openapitools.client.model.IpamsvcOptionItem;
import org.openapitools.client.model.IpamsvcUtilization;
import org.openapitools.client.model.IpamsvcUtilizationThreshold;
import org.openapitools.client.model.IpamsvcUtilizationV6;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A __Subnet__ object (_ipam/subnet_) is a set of contiguous IP addresses in the same IP space with no gap, expressed as an address and CIDR values. It represents a set of addresses from which addresses are assigned to network equipment interfaces.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:31.429972+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class IpamsvcSubnet {
  public static final String SERIALIZED_NAME_ADDRESS = "address";
  @SerializedName(SERIALIZED_NAME_ADDRESS)
  @javax.annotation.Nonnull
  private String address;

  public static final String SERIALIZED_NAME_ASM_CONFIG = "asm_config";
  @SerializedName(SERIALIZED_NAME_ASM_CONFIG)
  @javax.annotation.Nullable
  private IpamsvcASMConfig asmConfig;

  public static final String SERIALIZED_NAME_ASM_SCOPE_FLAG = "asm_scope_flag";
  @SerializedName(SERIALIZED_NAME_ASM_SCOPE_FLAG)
  @javax.annotation.Nullable
  private Long asmScopeFlag;

  public static final String SERIALIZED_NAME_CIDR = "cidr";
  @SerializedName(SERIALIZED_NAME_CIDR)
  @javax.annotation.Nullable
  private Long cidr;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  @javax.annotation.Nullable
  private String comment;

  public static final String SERIALIZED_NAME_COMPARTMENT_ID = "compartment_id";
  @SerializedName(SERIALIZED_NAME_COMPARTMENT_ID)
  @javax.annotation.Nullable
  private String compartmentId;

  public static final String SERIALIZED_NAME_CONFIG_PROFILES = "config_profiles";
  @SerializedName(SERIALIZED_NAME_CONFIG_PROFILES)
  @javax.annotation.Nullable
  private List<String> configProfiles = new ArrayList<>();

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DDNS_CLIENT_UPDATE = "ddns_client_update";
  @SerializedName(SERIALIZED_NAME_DDNS_CLIENT_UPDATE)
  @javax.annotation.Nullable
  private String ddnsClientUpdate;

  public static final String SERIALIZED_NAME_DDNS_CONFLICT_RESOLUTION_MODE = "ddns_conflict_resolution_mode";
  @SerializedName(SERIALIZED_NAME_DDNS_CONFLICT_RESOLUTION_MODE)
  @javax.annotation.Nullable
  private String ddnsConflictResolutionMode;

  public static final String SERIALIZED_NAME_DDNS_DOMAIN = "ddns_domain";
  @SerializedName(SERIALIZED_NAME_DDNS_DOMAIN)
  @javax.annotation.Nullable
  private String ddnsDomain;

  public static final String SERIALIZED_NAME_DDNS_GENERATE_NAME = "ddns_generate_name";
  @SerializedName(SERIALIZED_NAME_DDNS_GENERATE_NAME)
  @javax.annotation.Nullable
  private Boolean ddnsGenerateName;

  public static final String SERIALIZED_NAME_DDNS_GENERATED_PREFIX = "ddns_generated_prefix";
  @SerializedName(SERIALIZED_NAME_DDNS_GENERATED_PREFIX)
  @javax.annotation.Nullable
  private String ddnsGeneratedPrefix;

  public static final String SERIALIZED_NAME_DDNS_SEND_UPDATES = "ddns_send_updates";
  @SerializedName(SERIALIZED_NAME_DDNS_SEND_UPDATES)
  @javax.annotation.Nullable
  private Boolean ddnsSendUpdates;

  public static final String SERIALIZED_NAME_DDNS_TTL_PERCENT = "ddns_ttl_percent";
  @SerializedName(SERIALIZED_NAME_DDNS_TTL_PERCENT)
  @javax.annotation.Nullable
  private Float ddnsTtlPercent;

  public static final String SERIALIZED_NAME_DDNS_UPDATE_ON_RENEW = "ddns_update_on_renew";
  @SerializedName(SERIALIZED_NAME_DDNS_UPDATE_ON_RENEW)
  @javax.annotation.Nullable
  private Boolean ddnsUpdateOnRenew;

  public static final String SERIALIZED_NAME_DDNS_USE_CONFLICT_RESOLUTION = "ddns_use_conflict_resolution";
  @SerializedName(SERIALIZED_NAME_DDNS_USE_CONFLICT_RESOLUTION)
  @javax.annotation.Nullable
  private Boolean ddnsUseConflictResolution;

  public static final String SERIALIZED_NAME_DELEGATION = "delegation";
  @SerializedName(SERIALIZED_NAME_DELEGATION)
  @javax.annotation.Nullable
  private String delegation;

  public static final String SERIALIZED_NAME_DHCP_CONFIG = "dhcp_config";
  @SerializedName(SERIALIZED_NAME_DHCP_CONFIG)
  @javax.annotation.Nullable
  private IpamsvcDHCPConfig dhcpConfig;

  public static final String SERIALIZED_NAME_DHCP_HOST = "dhcp_host";
  @SerializedName(SERIALIZED_NAME_DHCP_HOST)
  @javax.annotation.Nullable
  private String dhcpHost;

  public static final String SERIALIZED_NAME_DHCP_OPTIONS = "dhcp_options";
  @SerializedName(SERIALIZED_NAME_DHCP_OPTIONS)
  @javax.annotation.Nullable
  private List<IpamsvcOptionItem> dhcpOptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DHCP_UTILIZATION = "dhcp_utilization";
  @SerializedName(SERIALIZED_NAME_DHCP_UTILIZATION)
  @javax.annotation.Nullable
  private IpamsvcDHCPUtilization dhcpUtilization;

  public static final String SERIALIZED_NAME_DISABLE_DHCP = "disable_dhcp";
  @SerializedName(SERIALIZED_NAME_DISABLE_DHCP)
  @javax.annotation.Nullable
  private Boolean disableDhcp;

  public static final String SERIALIZED_NAME_DISCOVERY_ATTRS = "discovery_attrs";
  @SerializedName(SERIALIZED_NAME_DISCOVERY_ATTRS)
  @javax.annotation.Nullable
  private Object discoveryAttrs;

  public static final String SERIALIZED_NAME_DISCOVERY_METADATA = "discovery_metadata";
  @SerializedName(SERIALIZED_NAME_DISCOVERY_METADATA)
  @javax.annotation.Nullable
  private Object discoveryMetadata;

  public static final String SERIALIZED_NAME_EXTERNAL_KEYS = "external_keys";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_KEYS)
  @javax.annotation.Nullable
  private Object externalKeys;

  public static final String SERIALIZED_NAME_FEDERATED_REALMS = "federated_realms";
  @SerializedName(SERIALIZED_NAME_FEDERATED_REALMS)
  @javax.annotation.Nullable
  private List<String> federatedRealms = new ArrayList<>();

  public static final String SERIALIZED_NAME_HEADER_OPTION_FILENAME = "header_option_filename";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_FILENAME)
  @javax.annotation.Nullable
  private String headerOptionFilename;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS = "header_option_server_address";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS)
  @javax.annotation.Nullable
  private String headerOptionServerAddress;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME = "header_option_server_name";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME)
  @javax.annotation.Nullable
  private String headerOptionServerName;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_CHAR = "hostname_rewrite_char";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_CHAR)
  @javax.annotation.Nullable
  private String hostnameRewriteChar;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_ENABLED = "hostname_rewrite_enabled";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_ENABLED)
  @javax.annotation.Nullable
  private Boolean hostnameRewriteEnabled;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_REGEX = "hostname_rewrite_regex";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_REGEX)
  @javax.annotation.Nullable
  private String hostnameRewriteRegex;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_INHERITANCE_ASSIGNED_HOSTS = "inheritance_assigned_hosts";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_ASSIGNED_HOSTS)
  @javax.annotation.Nullable
  private List<InheritanceAssignedHost> inheritanceAssignedHosts = new ArrayList<>();

  public static final String SERIALIZED_NAME_INHERITANCE_PARENT = "inheritance_parent";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_PARENT)
  @javax.annotation.Nullable
  private String inheritanceParent;

  public static final String SERIALIZED_NAME_INHERITANCE_SOURCES = "inheritance_sources";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_SOURCES)
  @javax.annotation.Nullable
  private IpamsvcDHCPInheritance inheritanceSources;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nullable
  private String name;

  public static final String SERIALIZED_NAME_NIOS_DHCP_HOSTS = "nios_dhcp_hosts";
  @SerializedName(SERIALIZED_NAME_NIOS_DHCP_HOSTS)
  @javax.annotation.Nullable
  private List<String> niosDhcpHosts = new ArrayList<>();

  public static final String SERIALIZED_NAME_PARENT = "parent";
  @SerializedName(SERIALIZED_NAME_PARENT)
  @javax.annotation.Nullable
  private String parent;

  public static final String SERIALIZED_NAME_PROTOCOL = "protocol";
  @SerializedName(SERIALIZED_NAME_PROTOCOL)
  @javax.annotation.Nullable
  private String protocol;

  public static final String SERIALIZED_NAME_REBIND_TIME = "rebind_time";
  @SerializedName(SERIALIZED_NAME_REBIND_TIME)
  @javax.annotation.Nullable
  private Long rebindTime;

  public static final String SERIALIZED_NAME_RENEW_TIME = "renew_time";
  @SerializedName(SERIALIZED_NAME_RENEW_TIME)
  @javax.annotation.Nullable
  private Long renewTime;

  public static final String SERIALIZED_NAME_SPACE = "space";
  @SerializedName(SERIALIZED_NAME_SPACE)
  @javax.annotation.Nonnull
  private String space;

  public static final String SERIALIZED_NAME_SUBNET_ID = "subnet_id";
  @SerializedName(SERIALIZED_NAME_SUBNET_ID)
  @javax.annotation.Nullable
  private Long subnetId;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  @javax.annotation.Nullable
  private Object tags;

  public static final String SERIALIZED_NAME_THRESHOLD = "threshold";
  @SerializedName(SERIALIZED_NAME_THRESHOLD)
  @javax.annotation.Nullable
  private IpamsvcUtilizationThreshold threshold;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_USAGE = "usage";
  @SerializedName(SERIALIZED_NAME_USAGE)
  @javax.annotation.Nullable
  private List<String> usage = new ArrayList<>();

  public static final String SERIALIZED_NAME_UTILIZATION = "utilization";
  @SerializedName(SERIALIZED_NAME_UTILIZATION)
  @javax.annotation.Nullable
  private IpamsvcUtilization utilization;

  public static final String SERIALIZED_NAME_UTILIZATION_V6 = "utilization_v6";
  @SerializedName(SERIALIZED_NAME_UTILIZATION_V6)
  @javax.annotation.Nullable
  private IpamsvcUtilizationV6 utilizationV6;

  public IpamsvcSubnet() {
  }

  public IpamsvcSubnet(
     Long asmScopeFlag, 
     String compartmentId, 
     OffsetDateTime createdAt, 
     String delegation, 
     String id, 
     List<InheritanceAssignedHost> inheritanceAssignedHosts, 
     String protocol, 
     Long subnetId, 
     OffsetDateTime updatedAt, 
     List<String> usage
  ) {
    this();
    this.asmScopeFlag = asmScopeFlag;
    this.compartmentId = compartmentId;
    this.createdAt = createdAt;
    this.delegation = delegation;
    this.id = id;
    this.inheritanceAssignedHosts = inheritanceAssignedHosts;
    this.protocol = protocol;
    this.subnetId = subnetId;
    this.updatedAt = updatedAt;
    this.usage = usage;
  }

  public IpamsvcSubnet address(@javax.annotation.Nonnull String address) {
    this.address = address;
    return this;
  }

  /**
   * The address of the subnet in the form “a.b.c.d/n” where the “/n” may be omitted. In this case, the CIDR value must be defined in the _cidr_ field. When reading, the _address_ field is always in the form “a.b.c.d”.
   * @return address
   */
  @javax.annotation.Nonnull
  public String getAddress() {
    return address;
  }

  public void setAddress(@javax.annotation.Nonnull String address) {
    this.address = address;
  }


  public IpamsvcSubnet asmConfig(@javax.annotation.Nullable IpamsvcASMConfig asmConfig) {
    this.asmConfig = asmConfig;
    return this;
  }

  /**
   * Get asmConfig
   * @return asmConfig
   */
  @javax.annotation.Nullable
  public IpamsvcASMConfig getAsmConfig() {
    return asmConfig;
  }

  public void setAsmConfig(@javax.annotation.Nullable IpamsvcASMConfig asmConfig) {
    this.asmConfig = asmConfig;
  }


  /**
   * Set to 1 to indicate that the subnet may run out of addresses.
   * @return asmScopeFlag
   */
  @javax.annotation.Nullable
  public Long getAsmScopeFlag() {
    return asmScopeFlag;
  }



  public IpamsvcSubnet cidr(@javax.annotation.Nullable Long cidr) {
    this.cidr = cidr;
    return this;
  }

  /**
   * The CIDR of the subnet. This is required if _address_ does not include CIDR.
   * minimum: 1
   * maximum: 128
   * @return cidr
   */
  @javax.annotation.Nullable
  public Long getCidr() {
    return cidr;
  }

  public void setCidr(@javax.annotation.Nullable Long cidr) {
    this.cidr = cidr;
  }


  public IpamsvcSubnet comment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * The description for the subnet. May contain 0 to 1024 characters. Can include UTF-8.
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
  }


  /**
   * The access view associated with the object. If no access view is associated with the object, the value defaults to empty.
   * @return compartmentId
   */
  @javax.annotation.Nullable
  public String getCompartmentId() {
    return compartmentId;
  }



  public IpamsvcSubnet configProfiles(@javax.annotation.Nullable List<String> configProfiles) {
    this.configProfiles = configProfiles;
    return this;
  }

  public IpamsvcSubnet addConfigProfilesItem(String configProfilesItem) {
    if (this.configProfiles == null) {
      this.configProfiles = new ArrayList<>();
    }
    this.configProfiles.add(configProfilesItem);
    return this;
  }

  /**
   * The resource identifier.
   * @return configProfiles
   */
  @javax.annotation.Nullable
  public List<String> getConfigProfiles() {
    return configProfiles;
  }

  public void setConfigProfiles(@javax.annotation.Nullable List<String> configProfiles) {
    this.configProfiles = configProfiles;
  }


  /**
   * Time when the object has been created.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  public IpamsvcSubnet ddnsClientUpdate(@javax.annotation.Nullable String ddnsClientUpdate) {
    this.ddnsClientUpdate = ddnsClientUpdate;
    return this;
  }

  /**
   * Controls who does the DDNS updates.  Valid values are: * _client_: DHCP server updates DNS if requested by client. * _server_: DHCP server always updates DNS, overriding an update request from the client, unless the client requests no updates. * _ignore_: DHCP server always updates DNS, even if the client says not to. * _over_client_update_: Same as _server_. DHCP server always updates DNS, overriding an update request from the client, unless the client requests no updates. * _over_no_update_: DHCP server updates DNS even if the client requests that no updates be done. If the client requests to do the update, DHCP server allows it.  Defaults to _client_.
   * @return ddnsClientUpdate
   */
  @javax.annotation.Nullable
  public String getDdnsClientUpdate() {
    return ddnsClientUpdate;
  }

  public void setDdnsClientUpdate(@javax.annotation.Nullable String ddnsClientUpdate) {
    this.ddnsClientUpdate = ddnsClientUpdate;
  }


  public IpamsvcSubnet ddnsConflictResolutionMode(@javax.annotation.Nullable String ddnsConflictResolutionMode) {
    this.ddnsConflictResolutionMode = ddnsConflictResolutionMode;
    return this;
  }

  /**
   * The mode used for resolving conflicts while performing DDNS updates.  Valid values are: * _check_with_dhcid_: It includes adding a DHCID record and checking that record via conflict detection as per RFC 4703. * _no_check_with_dhcid_: This will ignore conflict detection but add a DHCID record when creating/updating an entry. * _check_exists_with_dhcid_: This will check if there is an existing DHCID record but does not verify the value of the record matches the update. This will also update the DHCID record for the entry. * _no_check_without_dhcid_: This ignores conflict detection and will not add a DHCID record when creating/updating a DDNS entry.  Defaults to _check_with_dhcid_.
   * @return ddnsConflictResolutionMode
   */
  @javax.annotation.Nullable
  public String getDdnsConflictResolutionMode() {
    return ddnsConflictResolutionMode;
  }

  public void setDdnsConflictResolutionMode(@javax.annotation.Nullable String ddnsConflictResolutionMode) {
    this.ddnsConflictResolutionMode = ddnsConflictResolutionMode;
  }


  public IpamsvcSubnet ddnsDomain(@javax.annotation.Nullable String ddnsDomain) {
    this.ddnsDomain = ddnsDomain;
    return this;
  }

  /**
   * The domain suffix for DDNS updates. FQDN, may be empty.  Defaults to empty.
   * @return ddnsDomain
   */
  @javax.annotation.Nullable
  public String getDdnsDomain() {
    return ddnsDomain;
  }

  public void setDdnsDomain(@javax.annotation.Nullable String ddnsDomain) {
    this.ddnsDomain = ddnsDomain;
  }


  public IpamsvcSubnet ddnsGenerateName(@javax.annotation.Nullable Boolean ddnsGenerateName) {
    this.ddnsGenerateName = ddnsGenerateName;
    return this;
  }

  /**
   * Indicates if DDNS needs to generate a hostname when not supplied by the client.  Defaults to _false_.
   * @return ddnsGenerateName
   */
  @javax.annotation.Nullable
  public Boolean getDdnsGenerateName() {
    return ddnsGenerateName;
  }

  public void setDdnsGenerateName(@javax.annotation.Nullable Boolean ddnsGenerateName) {
    this.ddnsGenerateName = ddnsGenerateName;
  }


  public IpamsvcSubnet ddnsGeneratedPrefix(@javax.annotation.Nullable String ddnsGeneratedPrefix) {
    this.ddnsGeneratedPrefix = ddnsGeneratedPrefix;
    return this;
  }

  /**
   * The prefix used in the generation of an FQDN.  When generating a name, DHCP server will construct the name in the format: [ddns-generated-prefix]-[address-text].[ddns-qualifying-suffix]. where address-text is simply the lease IP address converted to a hyphenated string.  Defaults to \&quot;myhost\&quot;.
   * @return ddnsGeneratedPrefix
   */
  @javax.annotation.Nullable
  public String getDdnsGeneratedPrefix() {
    return ddnsGeneratedPrefix;
  }

  public void setDdnsGeneratedPrefix(@javax.annotation.Nullable String ddnsGeneratedPrefix) {
    this.ddnsGeneratedPrefix = ddnsGeneratedPrefix;
  }


  public IpamsvcSubnet ddnsSendUpdates(@javax.annotation.Nullable Boolean ddnsSendUpdates) {
    this.ddnsSendUpdates = ddnsSendUpdates;
    return this;
  }

  /**
   * Determines if DDNS updates are enabled at the subnet level. Defaults to _true_.
   * @return ddnsSendUpdates
   */
  @javax.annotation.Nullable
  public Boolean getDdnsSendUpdates() {
    return ddnsSendUpdates;
  }

  public void setDdnsSendUpdates(@javax.annotation.Nullable Boolean ddnsSendUpdates) {
    this.ddnsSendUpdates = ddnsSendUpdates;
  }


  public IpamsvcSubnet ddnsTtlPercent(@javax.annotation.Nullable Float ddnsTtlPercent) {
    this.ddnsTtlPercent = ddnsTtlPercent;
    return this;
  }

  /**
   * DDNS TTL value - to be calculated as a simple percentage of the lease&#39;s lifetime, using the parameter&#39;s value as the percentage. It is specified as a percentage (e.g. 25, 75). Defaults to unspecified.
   * @return ddnsTtlPercent
   */
  @javax.annotation.Nullable
  public Float getDdnsTtlPercent() {
    return ddnsTtlPercent;
  }

  public void setDdnsTtlPercent(@javax.annotation.Nullable Float ddnsTtlPercent) {
    this.ddnsTtlPercent = ddnsTtlPercent;
  }


  public IpamsvcSubnet ddnsUpdateOnRenew(@javax.annotation.Nullable Boolean ddnsUpdateOnRenew) {
    this.ddnsUpdateOnRenew = ddnsUpdateOnRenew;
    return this;
  }

  /**
   * Instructs the DHCP server to always update the DNS information when a lease is renewed even if its DNS information has not changed.  Defaults to _false_.
   * @return ddnsUpdateOnRenew
   */
  @javax.annotation.Nullable
  public Boolean getDdnsUpdateOnRenew() {
    return ddnsUpdateOnRenew;
  }

  public void setDdnsUpdateOnRenew(@javax.annotation.Nullable Boolean ddnsUpdateOnRenew) {
    this.ddnsUpdateOnRenew = ddnsUpdateOnRenew;
  }


  public IpamsvcSubnet ddnsUseConflictResolution(@javax.annotation.Nullable Boolean ddnsUseConflictResolution) {
    this.ddnsUseConflictResolution = ddnsUseConflictResolution;
    return this;
  }

  /**
   * When true, DHCP server will apply conflict resolution, as described in RFC 4703, when attempting to fulfill the update request.  When false, DHCP server will simply attempt to update the DNS entries per the request, regardless of whether or not they conflict with existing entries owned by other DHCP4 clients.  Defaults to _true_.
   * @return ddnsUseConflictResolution
   */
  @javax.annotation.Nullable
  public Boolean getDdnsUseConflictResolution() {
    return ddnsUseConflictResolution;
  }

  public void setDdnsUseConflictResolution(@javax.annotation.Nullable Boolean ddnsUseConflictResolution) {
    this.ddnsUseConflictResolution = ddnsUseConflictResolution;
  }


  /**
   * The ID of the delegation associated with the subnet.
   * @return delegation
   */
  @javax.annotation.Nullable
  public String getDelegation() {
    return delegation;
  }



  public IpamsvcSubnet dhcpConfig(@javax.annotation.Nullable IpamsvcDHCPConfig dhcpConfig) {
    this.dhcpConfig = dhcpConfig;
    return this;
  }

  /**
   * Get dhcpConfig
   * @return dhcpConfig
   */
  @javax.annotation.Nullable
  public IpamsvcDHCPConfig getDhcpConfig() {
    return dhcpConfig;
  }

  public void setDhcpConfig(@javax.annotation.Nullable IpamsvcDHCPConfig dhcpConfig) {
    this.dhcpConfig = dhcpConfig;
  }


  public IpamsvcSubnet dhcpHost(@javax.annotation.Nullable String dhcpHost) {
    this.dhcpHost = dhcpHost;
    return this;
  }

  /**
   * The resource identifier.
   * @return dhcpHost
   */
  @javax.annotation.Nullable
  public String getDhcpHost() {
    return dhcpHost;
  }

  public void setDhcpHost(@javax.annotation.Nullable String dhcpHost) {
    this.dhcpHost = dhcpHost;
  }


  public IpamsvcSubnet dhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
    return this;
  }

  public IpamsvcSubnet addDhcpOptionsItem(IpamsvcOptionItem dhcpOptionsItem) {
    if (this.dhcpOptions == null) {
      this.dhcpOptions = new ArrayList<>();
    }
    this.dhcpOptions.add(dhcpOptionsItem);
    return this;
  }

  /**
   * The DHCP options of the subnet. This can either be a specific option or a group of options.
   * @return dhcpOptions
   */
  @javax.annotation.Nullable
  public List<IpamsvcOptionItem> getDhcpOptions() {
    return dhcpOptions;
  }

  public void setDhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
  }


  public IpamsvcSubnet dhcpUtilization(@javax.annotation.Nullable IpamsvcDHCPUtilization dhcpUtilization) {
    this.dhcpUtilization = dhcpUtilization;
    return this;
  }

  /**
   * Get dhcpUtilization
   * @return dhcpUtilization
   */
  @javax.annotation.Nullable
  public IpamsvcDHCPUtilization getDhcpUtilization() {
    return dhcpUtilization;
  }

  public void setDhcpUtilization(@javax.annotation.Nullable IpamsvcDHCPUtilization dhcpUtilization) {
    this.dhcpUtilization = dhcpUtilization;
  }


  public IpamsvcSubnet disableDhcp(@javax.annotation.Nullable Boolean disableDhcp) {
    this.disableDhcp = disableDhcp;
    return this;
  }

  /**
   * Optional. _true_ to disable object. A disabled object is effectively non-existent when generating configuration.  Defaults to _false_.
   * @return disableDhcp
   */
  @javax.annotation.Nullable
  public Boolean getDisableDhcp() {
    return disableDhcp;
  }

  public void setDisableDhcp(@javax.annotation.Nullable Boolean disableDhcp) {
    this.disableDhcp = disableDhcp;
  }


  public IpamsvcSubnet discoveryAttrs(@javax.annotation.Nullable Object discoveryAttrs) {
    this.discoveryAttrs = discoveryAttrs;
    return this;
  }

  /**
   * The discovery attributes for this subnet in JSON format.
   * @return discoveryAttrs
   */
  @javax.annotation.Nullable
  public Object getDiscoveryAttrs() {
    return discoveryAttrs;
  }

  public void setDiscoveryAttrs(@javax.annotation.Nullable Object discoveryAttrs) {
    this.discoveryAttrs = discoveryAttrs;
  }


  public IpamsvcSubnet discoveryMetadata(@javax.annotation.Nullable Object discoveryMetadata) {
    this.discoveryMetadata = discoveryMetadata;
    return this;
  }

  /**
   * The discovery metadata for this subnet in JSON format.
   * @return discoveryMetadata
   */
  @javax.annotation.Nullable
  public Object getDiscoveryMetadata() {
    return discoveryMetadata;
  }

  public void setDiscoveryMetadata(@javax.annotation.Nullable Object discoveryMetadata) {
    this.discoveryMetadata = discoveryMetadata;
  }


  public IpamsvcSubnet externalKeys(@javax.annotation.Nullable Object externalKeys) {
    this.externalKeys = externalKeys;
    return this;
  }

  /**
   * The external keys (source key) for this subnet in JSON format.
   * @return externalKeys
   */
  @javax.annotation.Nullable
  public Object getExternalKeys() {
    return externalKeys;
  }

  public void setExternalKeys(@javax.annotation.Nullable Object externalKeys) {
    this.externalKeys = externalKeys;
  }


  public IpamsvcSubnet federatedRealms(@javax.annotation.Nullable List<String> federatedRealms) {
    this.federatedRealms = federatedRealms;
    return this;
  }

  public IpamsvcSubnet addFederatedRealmsItem(String federatedRealmsItem) {
    if (this.federatedRealms == null) {
      this.federatedRealms = new ArrayList<>();
    }
    this.federatedRealms.add(federatedRealmsItem);
    return this;
  }

  /**
   * The IDs of the federated realms in which the subnet participates.
   * @return federatedRealms
   */
  @javax.annotation.Nullable
  public List<String> getFederatedRealms() {
    return federatedRealms;
  }

  public void setFederatedRealms(@javax.annotation.Nullable List<String> federatedRealms) {
    this.federatedRealms = federatedRealms;
  }


  public IpamsvcSubnet headerOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
    return this;
  }

  /**
   * The configuration for header option filename field.
   * @return headerOptionFilename
   */
  @javax.annotation.Nullable
  public String getHeaderOptionFilename() {
    return headerOptionFilename;
  }

  public void setHeaderOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
  }


  public IpamsvcSubnet headerOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
    return this;
  }

  /**
   * The configuration for header option server address field.
   * @return headerOptionServerAddress
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerAddress() {
    return headerOptionServerAddress;
  }

  public void setHeaderOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
  }


  public IpamsvcSubnet headerOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
    return this;
  }

  /**
   * The configuration for header option server name field.
   * @return headerOptionServerName
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerName() {
    return headerOptionServerName;
  }

  public void setHeaderOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
  }


  public IpamsvcSubnet hostnameRewriteChar(@javax.annotation.Nullable String hostnameRewriteChar) {
    this.hostnameRewriteChar = hostnameRewriteChar;
    return this;
  }

  /**
   * The character to replace non-matching characters with, when hostname rewrite is enabled.  Any single ASCII character or no character if the invalid characters should be removed without replacement.  Defaults to \&quot;-\&quot;.
   * @return hostnameRewriteChar
   */
  @javax.annotation.Nullable
  public String getHostnameRewriteChar() {
    return hostnameRewriteChar;
  }

  public void setHostnameRewriteChar(@javax.annotation.Nullable String hostnameRewriteChar) {
    this.hostnameRewriteChar = hostnameRewriteChar;
  }


  public IpamsvcSubnet hostnameRewriteEnabled(@javax.annotation.Nullable Boolean hostnameRewriteEnabled) {
    this.hostnameRewriteEnabled = hostnameRewriteEnabled;
    return this;
  }

  /**
   * Indicates if client supplied hostnames will be rewritten prior to DDNS update by replacing every character that does not match _hostname_rewrite_regex_ by _hostname_rewrite_char_.  Defaults to _false_.
   * @return hostnameRewriteEnabled
   */
  @javax.annotation.Nullable
  public Boolean getHostnameRewriteEnabled() {
    return hostnameRewriteEnabled;
  }

  public void setHostnameRewriteEnabled(@javax.annotation.Nullable Boolean hostnameRewriteEnabled) {
    this.hostnameRewriteEnabled = hostnameRewriteEnabled;
  }


  public IpamsvcSubnet hostnameRewriteRegex(@javax.annotation.Nullable String hostnameRewriteRegex) {
    this.hostnameRewriteRegex = hostnameRewriteRegex;
    return this;
  }

  /**
   * The regex bracket expression to match valid characters.  Must begin with \&quot;[\&quot; and end with \&quot;]\&quot; and be a compilable POSIX regex.  Defaults to \&quot;[^a-zA-Z0-9_.]\&quot;.
   * @return hostnameRewriteRegex
   */
  @javax.annotation.Nullable
  public String getHostnameRewriteRegex() {
    return hostnameRewriteRegex;
  }

  public void setHostnameRewriteRegex(@javax.annotation.Nullable String hostnameRewriteRegex) {
    this.hostnameRewriteRegex = hostnameRewriteRegex;
  }


  /**
   * The resource identifier.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  /**
   * The list of the inheritance assigned hosts of the object.
   * @return inheritanceAssignedHosts
   */
  @javax.annotation.Nullable
  public List<InheritanceAssignedHost> getInheritanceAssignedHosts() {
    return inheritanceAssignedHosts;
  }



  public IpamsvcSubnet inheritanceParent(@javax.annotation.Nullable String inheritanceParent) {
    this.inheritanceParent = inheritanceParent;
    return this;
  }

  /**
   * The resource identifier.
   * @return inheritanceParent
   */
  @javax.annotation.Nullable
  public String getInheritanceParent() {
    return inheritanceParent;
  }

  public void setInheritanceParent(@javax.annotation.Nullable String inheritanceParent) {
    this.inheritanceParent = inheritanceParent;
  }


  public IpamsvcSubnet inheritanceSources(@javax.annotation.Nullable IpamsvcDHCPInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
    return this;
  }

  /**
   * Get inheritanceSources
   * @return inheritanceSources
   */
  @javax.annotation.Nullable
  public IpamsvcDHCPInheritance getInheritanceSources() {
    return inheritanceSources;
  }

  public void setInheritanceSources(@javax.annotation.Nullable IpamsvcDHCPInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
  }


  public IpamsvcSubnet name(@javax.annotation.Nullable String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the subnet. May contain 1 to 256 characters. Can include UTF-8.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nullable String name) {
    this.name = name;
  }


  public IpamsvcSubnet niosDhcpHosts(@javax.annotation.Nullable List<String> niosDhcpHosts) {
    this.niosDhcpHosts = niosDhcpHosts;
    return this;
  }

  public IpamsvcSubnet addNiosDhcpHostsItem(String niosDhcpHostsItem) {
    if (this.niosDhcpHosts == null) {
      this.niosDhcpHosts = new ArrayList<>();
    }
    this.niosDhcpHosts.add(niosDhcpHostsItem);
    return this;
  }

  /**
   * The resource identifier.
   * @return niosDhcpHosts
   */
  @javax.annotation.Nullable
  public List<String> getNiosDhcpHosts() {
    return niosDhcpHosts;
  }

  public void setNiosDhcpHosts(@javax.annotation.Nullable List<String> niosDhcpHosts) {
    this.niosDhcpHosts = niosDhcpHosts;
  }


  public IpamsvcSubnet parent(@javax.annotation.Nullable String parent) {
    this.parent = parent;
    return this;
  }

  /**
   * The resource identifier.
   * @return parent
   */
  @javax.annotation.Nullable
  public String getParent() {
    return parent;
  }

  public void setParent(@javax.annotation.Nullable String parent) {
    this.parent = parent;
  }


  /**
   * The type of protocol of the subnet (_ip4_ or _ip6_).
   * @return protocol
   */
  @javax.annotation.Nullable
  public String getProtocol() {
    return protocol;
  }



  public IpamsvcSubnet rebindTime(@javax.annotation.Nullable Long rebindTime) {
    this.rebindTime = rebindTime;
    return this;
  }

  /**
   * The lease rebind time (T2) in seconds.
   * @return rebindTime
   */
  @javax.annotation.Nullable
  public Long getRebindTime() {
    return rebindTime;
  }

  public void setRebindTime(@javax.annotation.Nullable Long rebindTime) {
    this.rebindTime = rebindTime;
  }


  public IpamsvcSubnet renewTime(@javax.annotation.Nullable Long renewTime) {
    this.renewTime = renewTime;
    return this;
  }

  /**
   * The lease renew time (T1) in seconds.
   * @return renewTime
   */
  @javax.annotation.Nullable
  public Long getRenewTime() {
    return renewTime;
  }

  public void setRenewTime(@javax.annotation.Nullable Long renewTime) {
    this.renewTime = renewTime;
  }


  public IpamsvcSubnet space(@javax.annotation.Nonnull String space) {
    this.space = space;
    return this;
  }

  /**
   * The resource identifier.
   * @return space
   */
  @javax.annotation.Nonnull
  public String getSpace() {
    return space;
  }

  public void setSpace(@javax.annotation.Nonnull String space) {
    this.space = space;
  }


  /**
   * The Subnet ID value used in Kea configuration. 0 if no ID is assigned.
   * @return subnetId
   */
  @javax.annotation.Nullable
  public Long getSubnetId() {
    return subnetId;
  }



  public IpamsvcSubnet tags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
    return this;
  }

  /**
   * The tags for the subnet in JSON format.
   * @return tags
   */
  @javax.annotation.Nullable
  public Object getTags() {
    return tags;
  }

  public void setTags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
  }


  public IpamsvcSubnet threshold(@javax.annotation.Nullable IpamsvcUtilizationThreshold threshold) {
    this.threshold = threshold;
    return this;
  }

  /**
   * Get threshold
   * @return threshold
   */
  @javax.annotation.Nullable
  public IpamsvcUtilizationThreshold getThreshold() {
    return threshold;
  }

  public void setThreshold(@javax.annotation.Nullable IpamsvcUtilizationThreshold threshold) {
    this.threshold = threshold;
  }


  /**
   * Time when the object has been updated. Equals to _created_at_ if not updated after creation.
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }



  /**
   * The usage is a combination of indicators, each tracking a specific associated use. Listed below are usage indicators with their meaning:  usage indicator        | description  ---------------------- | --------------------------------  _IPAM_                 |  Subnet is managed in BloxOne DDI.  _DHCP_                 |  Subnet is served by a DHCP Host.  _DISCOVERED_           |  Subnet is discovered by some network discovery probe like Network Insight or NetMRI in NIOS.
   * @return usage
   */
  @javax.annotation.Nullable
  public List<String> getUsage() {
    return usage;
  }



  public IpamsvcSubnet utilization(@javax.annotation.Nullable IpamsvcUtilization utilization) {
    this.utilization = utilization;
    return this;
  }

  /**
   * Get utilization
   * @return utilization
   */
  @javax.annotation.Nullable
  public IpamsvcUtilization getUtilization() {
    return utilization;
  }

  public void setUtilization(@javax.annotation.Nullable IpamsvcUtilization utilization) {
    this.utilization = utilization;
  }


  public IpamsvcSubnet utilizationV6(@javax.annotation.Nullable IpamsvcUtilizationV6 utilizationV6) {
    this.utilizationV6 = utilizationV6;
    return this;
  }

  /**
   * Get utilizationV6
   * @return utilizationV6
   */
  @javax.annotation.Nullable
  public IpamsvcUtilizationV6 getUtilizationV6() {
    return utilizationV6;
  }

  public void setUtilizationV6(@javax.annotation.Nullable IpamsvcUtilizationV6 utilizationV6) {
    this.utilizationV6 = utilizationV6;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IpamsvcSubnet ipamsvcSubnet = (IpamsvcSubnet) o;
    return Objects.equals(this.address, ipamsvcSubnet.address) &&
        Objects.equals(this.asmConfig, ipamsvcSubnet.asmConfig) &&
        Objects.equals(this.asmScopeFlag, ipamsvcSubnet.asmScopeFlag) &&
        Objects.equals(this.cidr, ipamsvcSubnet.cidr) &&
        Objects.equals(this.comment, ipamsvcSubnet.comment) &&
        Objects.equals(this.compartmentId, ipamsvcSubnet.compartmentId) &&
        Objects.equals(this.configProfiles, ipamsvcSubnet.configProfiles) &&
        Objects.equals(this.createdAt, ipamsvcSubnet.createdAt) &&
        Objects.equals(this.ddnsClientUpdate, ipamsvcSubnet.ddnsClientUpdate) &&
        Objects.equals(this.ddnsConflictResolutionMode, ipamsvcSubnet.ddnsConflictResolutionMode) &&
        Objects.equals(this.ddnsDomain, ipamsvcSubnet.ddnsDomain) &&
        Objects.equals(this.ddnsGenerateName, ipamsvcSubnet.ddnsGenerateName) &&
        Objects.equals(this.ddnsGeneratedPrefix, ipamsvcSubnet.ddnsGeneratedPrefix) &&
        Objects.equals(this.ddnsSendUpdates, ipamsvcSubnet.ddnsSendUpdates) &&
        Objects.equals(this.ddnsTtlPercent, ipamsvcSubnet.ddnsTtlPercent) &&
        Objects.equals(this.ddnsUpdateOnRenew, ipamsvcSubnet.ddnsUpdateOnRenew) &&
        Objects.equals(this.ddnsUseConflictResolution, ipamsvcSubnet.ddnsUseConflictResolution) &&
        Objects.equals(this.delegation, ipamsvcSubnet.delegation) &&
        Objects.equals(this.dhcpConfig, ipamsvcSubnet.dhcpConfig) &&
        Objects.equals(this.dhcpHost, ipamsvcSubnet.dhcpHost) &&
        Objects.equals(this.dhcpOptions, ipamsvcSubnet.dhcpOptions) &&
        Objects.equals(this.dhcpUtilization, ipamsvcSubnet.dhcpUtilization) &&
        Objects.equals(this.disableDhcp, ipamsvcSubnet.disableDhcp) &&
        Objects.equals(this.discoveryAttrs, ipamsvcSubnet.discoveryAttrs) &&
        Objects.equals(this.discoveryMetadata, ipamsvcSubnet.discoveryMetadata) &&
        Objects.equals(this.externalKeys, ipamsvcSubnet.externalKeys) &&
        Objects.equals(this.federatedRealms, ipamsvcSubnet.federatedRealms) &&
        Objects.equals(this.headerOptionFilename, ipamsvcSubnet.headerOptionFilename) &&
        Objects.equals(this.headerOptionServerAddress, ipamsvcSubnet.headerOptionServerAddress) &&
        Objects.equals(this.headerOptionServerName, ipamsvcSubnet.headerOptionServerName) &&
        Objects.equals(this.hostnameRewriteChar, ipamsvcSubnet.hostnameRewriteChar) &&
        Objects.equals(this.hostnameRewriteEnabled, ipamsvcSubnet.hostnameRewriteEnabled) &&
        Objects.equals(this.hostnameRewriteRegex, ipamsvcSubnet.hostnameRewriteRegex) &&
        Objects.equals(this.id, ipamsvcSubnet.id) &&
        Objects.equals(this.inheritanceAssignedHosts, ipamsvcSubnet.inheritanceAssignedHosts) &&
        Objects.equals(this.inheritanceParent, ipamsvcSubnet.inheritanceParent) &&
        Objects.equals(this.inheritanceSources, ipamsvcSubnet.inheritanceSources) &&
        Objects.equals(this.name, ipamsvcSubnet.name) &&
        Objects.equals(this.niosDhcpHosts, ipamsvcSubnet.niosDhcpHosts) &&
        Objects.equals(this.parent, ipamsvcSubnet.parent) &&
        Objects.equals(this.protocol, ipamsvcSubnet.protocol) &&
        Objects.equals(this.rebindTime, ipamsvcSubnet.rebindTime) &&
        Objects.equals(this.renewTime, ipamsvcSubnet.renewTime) &&
        Objects.equals(this.space, ipamsvcSubnet.space) &&
        Objects.equals(this.subnetId, ipamsvcSubnet.subnetId) &&
        Objects.equals(this.tags, ipamsvcSubnet.tags) &&
        Objects.equals(this.threshold, ipamsvcSubnet.threshold) &&
        Objects.equals(this.updatedAt, ipamsvcSubnet.updatedAt) &&
        Objects.equals(this.usage, ipamsvcSubnet.usage) &&
        Objects.equals(this.utilization, ipamsvcSubnet.utilization) &&
        Objects.equals(this.utilizationV6, ipamsvcSubnet.utilizationV6);
  }

  @Override
  public int hashCode() {
    return Objects.hash(address, asmConfig, asmScopeFlag, cidr, comment, compartmentId, configProfiles, createdAt, ddnsClientUpdate, ddnsConflictResolutionMode, ddnsDomain, ddnsGenerateName, ddnsGeneratedPrefix, ddnsSendUpdates, ddnsTtlPercent, ddnsUpdateOnRenew, ddnsUseConflictResolution, delegation, dhcpConfig, dhcpHost, dhcpOptions, dhcpUtilization, disableDhcp, discoveryAttrs, discoveryMetadata, externalKeys, federatedRealms, headerOptionFilename, headerOptionServerAddress, headerOptionServerName, hostnameRewriteChar, hostnameRewriteEnabled, hostnameRewriteRegex, id, inheritanceAssignedHosts, inheritanceParent, inheritanceSources, name, niosDhcpHosts, parent, protocol, rebindTime, renewTime, space, subnetId, tags, threshold, updatedAt, usage, utilization, utilizationV6);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IpamsvcSubnet {\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    asmConfig: ").append(toIndentedString(asmConfig)).append("\n");
    sb.append("    asmScopeFlag: ").append(toIndentedString(asmScopeFlag)).append("\n");
    sb.append("    cidr: ").append(toIndentedString(cidr)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    compartmentId: ").append(toIndentedString(compartmentId)).append("\n");
    sb.append("    configProfiles: ").append(toIndentedString(configProfiles)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    ddnsClientUpdate: ").append(toIndentedString(ddnsClientUpdate)).append("\n");
    sb.append("    ddnsConflictResolutionMode: ").append(toIndentedString(ddnsConflictResolutionMode)).append("\n");
    sb.append("    ddnsDomain: ").append(toIndentedString(ddnsDomain)).append("\n");
    sb.append("    ddnsGenerateName: ").append(toIndentedString(ddnsGenerateName)).append("\n");
    sb.append("    ddnsGeneratedPrefix: ").append(toIndentedString(ddnsGeneratedPrefix)).append("\n");
    sb.append("    ddnsSendUpdates: ").append(toIndentedString(ddnsSendUpdates)).append("\n");
    sb.append("    ddnsTtlPercent: ").append(toIndentedString(ddnsTtlPercent)).append("\n");
    sb.append("    ddnsUpdateOnRenew: ").append(toIndentedString(ddnsUpdateOnRenew)).append("\n");
    sb.append("    ddnsUseConflictResolution: ").append(toIndentedString(ddnsUseConflictResolution)).append("\n");
    sb.append("    delegation: ").append(toIndentedString(delegation)).append("\n");
    sb.append("    dhcpConfig: ").append(toIndentedString(dhcpConfig)).append("\n");
    sb.append("    dhcpHost: ").append(toIndentedString(dhcpHost)).append("\n");
    sb.append("    dhcpOptions: ").append(toIndentedString(dhcpOptions)).append("\n");
    sb.append("    dhcpUtilization: ").append(toIndentedString(dhcpUtilization)).append("\n");
    sb.append("    disableDhcp: ").append(toIndentedString(disableDhcp)).append("\n");
    sb.append("    discoveryAttrs: ").append(toIndentedString(discoveryAttrs)).append("\n");
    sb.append("    discoveryMetadata: ").append(toIndentedString(discoveryMetadata)).append("\n");
    sb.append("    externalKeys: ").append(toIndentedString(externalKeys)).append("\n");
    sb.append("    federatedRealms: ").append(toIndentedString(federatedRealms)).append("\n");
    sb.append("    headerOptionFilename: ").append(toIndentedString(headerOptionFilename)).append("\n");
    sb.append("    headerOptionServerAddress: ").append(toIndentedString(headerOptionServerAddress)).append("\n");
    sb.append("    headerOptionServerName: ").append(toIndentedString(headerOptionServerName)).append("\n");
    sb.append("    hostnameRewriteChar: ").append(toIndentedString(hostnameRewriteChar)).append("\n");
    sb.append("    hostnameRewriteEnabled: ").append(toIndentedString(hostnameRewriteEnabled)).append("\n");
    sb.append("    hostnameRewriteRegex: ").append(toIndentedString(hostnameRewriteRegex)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    inheritanceAssignedHosts: ").append(toIndentedString(inheritanceAssignedHosts)).append("\n");
    sb.append("    inheritanceParent: ").append(toIndentedString(inheritanceParent)).append("\n");
    sb.append("    inheritanceSources: ").append(toIndentedString(inheritanceSources)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    niosDhcpHosts: ").append(toIndentedString(niosDhcpHosts)).append("\n");
    sb.append("    parent: ").append(toIndentedString(parent)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    rebindTime: ").append(toIndentedString(rebindTime)).append("\n");
    sb.append("    renewTime: ").append(toIndentedString(renewTime)).append("\n");
    sb.append("    space: ").append(toIndentedString(space)).append("\n");
    sb.append("    subnetId: ").append(toIndentedString(subnetId)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    threshold: ").append(toIndentedString(threshold)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    usage: ").append(toIndentedString(usage)).append("\n");
    sb.append("    utilization: ").append(toIndentedString(utilization)).append("\n");
    sb.append("    utilizationV6: ").append(toIndentedString(utilizationV6)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("address");
    openapiFields.add("asm_config");
    openapiFields.add("asm_scope_flag");
    openapiFields.add("cidr");
    openapiFields.add("comment");
    openapiFields.add("compartment_id");
    openapiFields.add("config_profiles");
    openapiFields.add("created_at");
    openapiFields.add("ddns_client_update");
    openapiFields.add("ddns_conflict_resolution_mode");
    openapiFields.add("ddns_domain");
    openapiFields.add("ddns_generate_name");
    openapiFields.add("ddns_generated_prefix");
    openapiFields.add("ddns_send_updates");
    openapiFields.add("ddns_ttl_percent");
    openapiFields.add("ddns_update_on_renew");
    openapiFields.add("ddns_use_conflict_resolution");
    openapiFields.add("delegation");
    openapiFields.add("dhcp_config");
    openapiFields.add("dhcp_host");
    openapiFields.add("dhcp_options");
    openapiFields.add("dhcp_utilization");
    openapiFields.add("disable_dhcp");
    openapiFields.add("discovery_attrs");
    openapiFields.add("discovery_metadata");
    openapiFields.add("external_keys");
    openapiFields.add("federated_realms");
    openapiFields.add("header_option_filename");
    openapiFields.add("header_option_server_address");
    openapiFields.add("header_option_server_name");
    openapiFields.add("hostname_rewrite_char");
    openapiFields.add("hostname_rewrite_enabled");
    openapiFields.add("hostname_rewrite_regex");
    openapiFields.add("id");
    openapiFields.add("inheritance_assigned_hosts");
    openapiFields.add("inheritance_parent");
    openapiFields.add("inheritance_sources");
    openapiFields.add("name");
    openapiFields.add("nios_dhcp_hosts");
    openapiFields.add("parent");
    openapiFields.add("protocol");
    openapiFields.add("rebind_time");
    openapiFields.add("renew_time");
    openapiFields.add("space");
    openapiFields.add("subnet_id");
    openapiFields.add("tags");
    openapiFields.add("threshold");
    openapiFields.add("updated_at");
    openapiFields.add("usage");
    openapiFields.add("utilization");
    openapiFields.add("utilization_v6");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("address");
    openapiRequiredFields.add("space");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IpamsvcSubnet
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IpamsvcSubnet.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IpamsvcSubnet is not found in the empty JSON string", IpamsvcSubnet.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IpamsvcSubnet.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IpamsvcSubnet` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : IpamsvcSubnet.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("address").toString()));
      }
      // validate the optional field `asm_config`
      if (jsonObj.get("asm_config") != null && !jsonObj.get("asm_config").isJsonNull()) {
        IpamsvcASMConfig.validateJsonElement(jsonObj.get("asm_config"));
      }
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if ((jsonObj.get("compartment_id") != null && !jsonObj.get("compartment_id").isJsonNull()) && !jsonObj.get("compartment_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compartment_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compartment_id").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("config_profiles") != null && !jsonObj.get("config_profiles").isJsonNull() && !jsonObj.get("config_profiles").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `config_profiles` to be an array in the JSON string but got `%s`", jsonObj.get("config_profiles").toString()));
      }
      if ((jsonObj.get("ddns_client_update") != null && !jsonObj.get("ddns_client_update").isJsonNull()) && !jsonObj.get("ddns_client_update").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_client_update` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_client_update").toString()));
      }
      if ((jsonObj.get("ddns_conflict_resolution_mode") != null && !jsonObj.get("ddns_conflict_resolution_mode").isJsonNull()) && !jsonObj.get("ddns_conflict_resolution_mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_conflict_resolution_mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_conflict_resolution_mode").toString()));
      }
      if ((jsonObj.get("ddns_domain") != null && !jsonObj.get("ddns_domain").isJsonNull()) && !jsonObj.get("ddns_domain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_domain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_domain").toString()));
      }
      if ((jsonObj.get("ddns_generated_prefix") != null && !jsonObj.get("ddns_generated_prefix").isJsonNull()) && !jsonObj.get("ddns_generated_prefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_generated_prefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_generated_prefix").toString()));
      }
      if ((jsonObj.get("delegation") != null && !jsonObj.get("delegation").isJsonNull()) && !jsonObj.get("delegation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `delegation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("delegation").toString()));
      }
      // validate the optional field `dhcp_config`
      if (jsonObj.get("dhcp_config") != null && !jsonObj.get("dhcp_config").isJsonNull()) {
        IpamsvcDHCPConfig.validateJsonElement(jsonObj.get("dhcp_config"));
      }
      if ((jsonObj.get("dhcp_host") != null && !jsonObj.get("dhcp_host").isJsonNull()) && !jsonObj.get("dhcp_host").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `dhcp_host` to be a primitive type in the JSON string but got `%s`", jsonObj.get("dhcp_host").toString()));
      }
      if (jsonObj.get("dhcp_options") != null && !jsonObj.get("dhcp_options").isJsonNull()) {
        JsonArray jsonArraydhcpOptions = jsonObj.getAsJsonArray("dhcp_options");
        if (jsonArraydhcpOptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dhcp_options").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dhcp_options` to be an array in the JSON string but got `%s`", jsonObj.get("dhcp_options").toString()));
          }

          // validate the optional field `dhcp_options` (array)
          for (int i = 0; i < jsonArraydhcpOptions.size(); i++) {
            IpamsvcOptionItem.validateJsonElement(jsonArraydhcpOptions.get(i));
          };
        }
      }
      // validate the optional field `dhcp_utilization`
      if (jsonObj.get("dhcp_utilization") != null && !jsonObj.get("dhcp_utilization").isJsonNull()) {
        IpamsvcDHCPUtilization.validateJsonElement(jsonObj.get("dhcp_utilization"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("federated_realms") != null && !jsonObj.get("federated_realms").isJsonNull() && !jsonObj.get("federated_realms").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `federated_realms` to be an array in the JSON string but got `%s`", jsonObj.get("federated_realms").toString()));
      }
      if ((jsonObj.get("header_option_filename") != null && !jsonObj.get("header_option_filename").isJsonNull()) && !jsonObj.get("header_option_filename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_filename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_filename").toString()));
      }
      if ((jsonObj.get("header_option_server_address") != null && !jsonObj.get("header_option_server_address").isJsonNull()) && !jsonObj.get("header_option_server_address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_address").toString()));
      }
      if ((jsonObj.get("header_option_server_name") != null && !jsonObj.get("header_option_server_name").isJsonNull()) && !jsonObj.get("header_option_server_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_name").toString()));
      }
      if ((jsonObj.get("hostname_rewrite_char") != null && !jsonObj.get("hostname_rewrite_char").isJsonNull()) && !jsonObj.get("hostname_rewrite_char").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname_rewrite_char` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname_rewrite_char").toString()));
      }
      if ((jsonObj.get("hostname_rewrite_regex") != null && !jsonObj.get("hostname_rewrite_regex").isJsonNull()) && !jsonObj.get("hostname_rewrite_regex").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname_rewrite_regex` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname_rewrite_regex").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (jsonObj.get("inheritance_assigned_hosts") != null && !jsonObj.get("inheritance_assigned_hosts").isJsonNull()) {
        JsonArray jsonArrayinheritanceAssignedHosts = jsonObj.getAsJsonArray("inheritance_assigned_hosts");
        if (jsonArrayinheritanceAssignedHosts != null) {
          // ensure the json data is an array
          if (!jsonObj.get("inheritance_assigned_hosts").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `inheritance_assigned_hosts` to be an array in the JSON string but got `%s`", jsonObj.get("inheritance_assigned_hosts").toString()));
          }

          // validate the optional field `inheritance_assigned_hosts` (array)
          for (int i = 0; i < jsonArrayinheritanceAssignedHosts.size(); i++) {
            InheritanceAssignedHost.validateJsonElement(jsonArrayinheritanceAssignedHosts.get(i));
          };
        }
      }
      if ((jsonObj.get("inheritance_parent") != null && !jsonObj.get("inheritance_parent").isJsonNull()) && !jsonObj.get("inheritance_parent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inheritance_parent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inheritance_parent").toString()));
      }
      // validate the optional field `inheritance_sources`
      if (jsonObj.get("inheritance_sources") != null && !jsonObj.get("inheritance_sources").isJsonNull()) {
        IpamsvcDHCPInheritance.validateJsonElement(jsonObj.get("inheritance_sources"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("nios_dhcp_hosts") != null && !jsonObj.get("nios_dhcp_hosts").isJsonNull() && !jsonObj.get("nios_dhcp_hosts").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `nios_dhcp_hosts` to be an array in the JSON string but got `%s`", jsonObj.get("nios_dhcp_hosts").toString()));
      }
      if ((jsonObj.get("parent") != null && !jsonObj.get("parent").isJsonNull()) && !jsonObj.get("parent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `parent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("parent").toString()));
      }
      if ((jsonObj.get("protocol") != null && !jsonObj.get("protocol").isJsonNull()) && !jsonObj.get("protocol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `protocol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("protocol").toString()));
      }
      if (!jsonObj.get("space").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `space` to be a primitive type in the JSON string but got `%s`", jsonObj.get("space").toString()));
      }
      // validate the optional field `threshold`
      if (jsonObj.get("threshold") != null && !jsonObj.get("threshold").isJsonNull()) {
        IpamsvcUtilizationThreshold.validateJsonElement(jsonObj.get("threshold"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("usage") != null && !jsonObj.get("usage").isJsonNull() && !jsonObj.get("usage").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `usage` to be an array in the JSON string but got `%s`", jsonObj.get("usage").toString()));
      }
      // validate the optional field `utilization`
      if (jsonObj.get("utilization") != null && !jsonObj.get("utilization").isJsonNull()) {
        IpamsvcUtilization.validateJsonElement(jsonObj.get("utilization"));
      }
      // validate the optional field `utilization_v6`
      if (jsonObj.get("utilization_v6") != null && !jsonObj.get("utilization_v6").isJsonNull()) {
        IpamsvcUtilizationV6.validateJsonElement(jsonObj.get("utilization_v6"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IpamsvcSubnet.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IpamsvcSubnet' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IpamsvcSubnet> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IpamsvcSubnet.class));

       return (TypeAdapter<T>) new TypeAdapter<IpamsvcSubnet>() {
           @Override
           public void write(JsonWriter out, IpamsvcSubnet value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IpamsvcSubnet read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IpamsvcSubnet given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IpamsvcSubnet
   * @throws IOException if the JSON string is invalid with respect to IpamsvcSubnet
   */
  public static IpamsvcSubnet fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IpamsvcSubnet.class);
  }

  /**
   * Convert an instance of IpamsvcSubnet to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

