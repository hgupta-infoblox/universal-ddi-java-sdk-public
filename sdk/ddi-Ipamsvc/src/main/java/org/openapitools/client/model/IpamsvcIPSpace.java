/*
 * IP Address Management API
 * The IPAM/DHCP Application is a BloxOne DDI service providing IP address management and DHCP protocol features. The IPAM component provides visibility into and provisioning tools to manage networking spaces, monitoring and reporting of entire IP address infrastructures, and integration with DNS and DHCP protocols. The DHCP component provides DHCP protocol configuration service with on-prem host serving DHCP protocol. It is part of the full-featured, DDI cloud solution that enables customers to deploy large numbers of protocol servers to deliver DNS and DHCP throughout their enterprise network.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.IpamsvcASMConfig;
import org.openapitools.client.model.IpamsvcDHCPConfig;
import org.openapitools.client.model.IpamsvcIPSpaceInheritance;
import org.openapitools.client.model.IpamsvcOptionItem;
import org.openapitools.client.model.IpamsvcUtilization;
import org.openapitools.client.model.IpamsvcUtilizationThreshold;
import org.openapitools.client.model.IpamsvcUtilizationV6;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An __IPSpace__ object (_ipam/ip_space_) allows customers to represent their entire managed address space with no collision. A collision arises when two or more block of addresses overlap partially or fully.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:31.429972+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class IpamsvcIPSpace {
  public static final String SERIALIZED_NAME_ASM_CONFIG = "asm_config";
  @SerializedName(SERIALIZED_NAME_ASM_CONFIG)
  @javax.annotation.Nullable
  private IpamsvcASMConfig asmConfig;

  public static final String SERIALIZED_NAME_ASM_SCOPE_FLAG = "asm_scope_flag";
  @SerializedName(SERIALIZED_NAME_ASM_SCOPE_FLAG)
  @javax.annotation.Nullable
  private Long asmScopeFlag;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  @javax.annotation.Nullable
  private String comment;

  public static final String SERIALIZED_NAME_COMPARTMENT_ID = "compartment_id";
  @SerializedName(SERIALIZED_NAME_COMPARTMENT_ID)
  @javax.annotation.Nullable
  private String compartmentId;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DDNS_CLIENT_UPDATE = "ddns_client_update";
  @SerializedName(SERIALIZED_NAME_DDNS_CLIENT_UPDATE)
  @javax.annotation.Nullable
  private String ddnsClientUpdate;

  public static final String SERIALIZED_NAME_DDNS_CONFLICT_RESOLUTION_MODE = "ddns_conflict_resolution_mode";
  @SerializedName(SERIALIZED_NAME_DDNS_CONFLICT_RESOLUTION_MODE)
  @javax.annotation.Nullable
  private String ddnsConflictResolutionMode;

  public static final String SERIALIZED_NAME_DDNS_DOMAIN = "ddns_domain";
  @SerializedName(SERIALIZED_NAME_DDNS_DOMAIN)
  @javax.annotation.Nullable
  private String ddnsDomain;

  public static final String SERIALIZED_NAME_DDNS_GENERATE_NAME = "ddns_generate_name";
  @SerializedName(SERIALIZED_NAME_DDNS_GENERATE_NAME)
  @javax.annotation.Nullable
  private Boolean ddnsGenerateName;

  public static final String SERIALIZED_NAME_DDNS_GENERATED_PREFIX = "ddns_generated_prefix";
  @SerializedName(SERIALIZED_NAME_DDNS_GENERATED_PREFIX)
  @javax.annotation.Nullable
  private String ddnsGeneratedPrefix;

  public static final String SERIALIZED_NAME_DDNS_SEND_UPDATES = "ddns_send_updates";
  @SerializedName(SERIALIZED_NAME_DDNS_SEND_UPDATES)
  @javax.annotation.Nullable
  private Boolean ddnsSendUpdates;

  public static final String SERIALIZED_NAME_DDNS_TTL_PERCENT = "ddns_ttl_percent";
  @SerializedName(SERIALIZED_NAME_DDNS_TTL_PERCENT)
  @javax.annotation.Nullable
  private Float ddnsTtlPercent;

  public static final String SERIALIZED_NAME_DDNS_UPDATE_ON_RENEW = "ddns_update_on_renew";
  @SerializedName(SERIALIZED_NAME_DDNS_UPDATE_ON_RENEW)
  @javax.annotation.Nullable
  private Boolean ddnsUpdateOnRenew;

  public static final String SERIALIZED_NAME_DDNS_USE_CONFLICT_RESOLUTION = "ddns_use_conflict_resolution";
  @SerializedName(SERIALIZED_NAME_DDNS_USE_CONFLICT_RESOLUTION)
  @javax.annotation.Nullable
  private Boolean ddnsUseConflictResolution;

  public static final String SERIALIZED_NAME_DEFAULT_REALMS = "default_realms";
  @SerializedName(SERIALIZED_NAME_DEFAULT_REALMS)
  @javax.annotation.Nullable
  private List<String> defaultRealms = new ArrayList<>();

  public static final String SERIALIZED_NAME_DHCP_CONFIG = "dhcp_config";
  @SerializedName(SERIALIZED_NAME_DHCP_CONFIG)
  @javax.annotation.Nullable
  private IpamsvcDHCPConfig dhcpConfig;

  public static final String SERIALIZED_NAME_DHCP_OPTIONS = "dhcp_options";
  @SerializedName(SERIALIZED_NAME_DHCP_OPTIONS)
  @javax.annotation.Nullable
  private List<IpamsvcOptionItem> dhcpOptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DHCP_OPTIONS_V6 = "dhcp_options_v6";
  @SerializedName(SERIALIZED_NAME_DHCP_OPTIONS_V6)
  @javax.annotation.Nullable
  private List<IpamsvcOptionItem> dhcpOptionsV6 = new ArrayList<>();

  public static final String SERIALIZED_NAME_HEADER_OPTION_FILENAME = "header_option_filename";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_FILENAME)
  @javax.annotation.Nullable
  private String headerOptionFilename;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS = "header_option_server_address";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS)
  @javax.annotation.Nullable
  private String headerOptionServerAddress;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME = "header_option_server_name";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME)
  @javax.annotation.Nullable
  private String headerOptionServerName;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_CHAR = "hostname_rewrite_char";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_CHAR)
  @javax.annotation.Nullable
  private String hostnameRewriteChar;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_ENABLED = "hostname_rewrite_enabled";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_ENABLED)
  @javax.annotation.Nullable
  private Boolean hostnameRewriteEnabled;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_REGEX = "hostname_rewrite_regex";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_REGEX)
  @javax.annotation.Nullable
  private String hostnameRewriteRegex;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_INHERITANCE_SOURCES = "inheritance_sources";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_SOURCES)
  @javax.annotation.Nullable
  private IpamsvcIPSpaceInheritance inheritanceSources;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nonnull
  private String name;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  @javax.annotation.Nullable
  private Object tags;

  public static final String SERIALIZED_NAME_THRESHOLD = "threshold";
  @SerializedName(SERIALIZED_NAME_THRESHOLD)
  @javax.annotation.Nullable
  private IpamsvcUtilizationThreshold threshold;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_UTILIZATION = "utilization";
  @SerializedName(SERIALIZED_NAME_UTILIZATION)
  @javax.annotation.Nullable
  private IpamsvcUtilization utilization;

  public static final String SERIALIZED_NAME_UTILIZATION_V6 = "utilization_v6";
  @SerializedName(SERIALIZED_NAME_UTILIZATION_V6)
  @javax.annotation.Nullable
  private IpamsvcUtilizationV6 utilizationV6;

  public static final String SERIALIZED_NAME_VENDOR_SPECIFIC_OPTION_OPTION_SPACE = "vendor_specific_option_option_space";
  @SerializedName(SERIALIZED_NAME_VENDOR_SPECIFIC_OPTION_OPTION_SPACE)
  @javax.annotation.Nullable
  private String vendorSpecificOptionOptionSpace;

  public IpamsvcIPSpace() {
  }

  public IpamsvcIPSpace(
     Long asmScopeFlag, 
     OffsetDateTime createdAt, 
     String id, 
     OffsetDateTime updatedAt
  ) {
    this();
    this.asmScopeFlag = asmScopeFlag;
    this.createdAt = createdAt;
    this.id = id;
    this.updatedAt = updatedAt;
  }

  public IpamsvcIPSpace asmConfig(@javax.annotation.Nullable IpamsvcASMConfig asmConfig) {
    this.asmConfig = asmConfig;
    return this;
  }

  /**
   * Get asmConfig
   * @return asmConfig
   */
  @javax.annotation.Nullable
  public IpamsvcASMConfig getAsmConfig() {
    return asmConfig;
  }

  public void setAsmConfig(@javax.annotation.Nullable IpamsvcASMConfig asmConfig) {
    this.asmConfig = asmConfig;
  }


  /**
   * The number of times the automated scope management usage limits have been exceeded for any of the subnets in this IP space.
   * @return asmScopeFlag
   */
  @javax.annotation.Nullable
  public Long getAsmScopeFlag() {
    return asmScopeFlag;
  }



  public IpamsvcIPSpace comment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * The description for the IP space. May contain 0 to 1024 characters. Can include UTF-8.
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
  }


  public IpamsvcIPSpace compartmentId(@javax.annotation.Nullable String compartmentId) {
    this.compartmentId = compartmentId;
    return this;
  }

  /**
   * The access view associated with the object. If no access view is associated with the object, the value defaults to empty.
   * @return compartmentId
   */
  @javax.annotation.Nullable
  public String getCompartmentId() {
    return compartmentId;
  }

  public void setCompartmentId(@javax.annotation.Nullable String compartmentId) {
    this.compartmentId = compartmentId;
  }


  /**
   * Time when the object has been created.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  public IpamsvcIPSpace ddnsClientUpdate(@javax.annotation.Nullable String ddnsClientUpdate) {
    this.ddnsClientUpdate = ddnsClientUpdate;
    return this;
  }

  /**
   * Controls who does the DDNS updates.  Valid values are: * _client_: DHCP server updates DNS if requested by client. * _server_: DHCP server always updates DNS, overriding an update request from the client, unless the client requests no updates. * _ignore_: DHCP server always updates DNS, even if the client says not to. * _over_client_update_: Same as _server_. DHCP server always updates DNS, overriding an update request from the client, unless the client requests no updates. * _over_no_update_: DHCP server updates DNS even if the client requests that no updates be done. If the client requests to do the update, DHCP server allows it.  Defaults to _client_.
   * @return ddnsClientUpdate
   */
  @javax.annotation.Nullable
  public String getDdnsClientUpdate() {
    return ddnsClientUpdate;
  }

  public void setDdnsClientUpdate(@javax.annotation.Nullable String ddnsClientUpdate) {
    this.ddnsClientUpdate = ddnsClientUpdate;
  }


  public IpamsvcIPSpace ddnsConflictResolutionMode(@javax.annotation.Nullable String ddnsConflictResolutionMode) {
    this.ddnsConflictResolutionMode = ddnsConflictResolutionMode;
    return this;
  }

  /**
   * The mode used for resolving conflicts while performing DDNS updates.  Valid values are: * _check_with_dhcid_: It includes adding a DHCID record and checking that record via conflict detection as per RFC 4703. * _no_check_with_dhcid_: This will ignore conflict detection but add a DHCID record when creating/updating an entry. * _check_exists_with_dhcid_: This will check if there is an existing DHCID record but does not verify the value of the record matches the update. This will also update the DHCID record for the entry. * _no_check_without_dhcid_: This ignores conflict detection and will not add a DHCID record when creating/updating a DDNS entry.  Defaults to _check_with_dhcid_.
   * @return ddnsConflictResolutionMode
   */
  @javax.annotation.Nullable
  public String getDdnsConflictResolutionMode() {
    return ddnsConflictResolutionMode;
  }

  public void setDdnsConflictResolutionMode(@javax.annotation.Nullable String ddnsConflictResolutionMode) {
    this.ddnsConflictResolutionMode = ddnsConflictResolutionMode;
  }


  public IpamsvcIPSpace ddnsDomain(@javax.annotation.Nullable String ddnsDomain) {
    this.ddnsDomain = ddnsDomain;
    return this;
  }

  /**
   * The domain suffix for DDNS updates. FQDN, may be empty.  Defaults to empty.
   * @return ddnsDomain
   */
  @javax.annotation.Nullable
  public String getDdnsDomain() {
    return ddnsDomain;
  }

  public void setDdnsDomain(@javax.annotation.Nullable String ddnsDomain) {
    this.ddnsDomain = ddnsDomain;
  }


  public IpamsvcIPSpace ddnsGenerateName(@javax.annotation.Nullable Boolean ddnsGenerateName) {
    this.ddnsGenerateName = ddnsGenerateName;
    return this;
  }

  /**
   * Indicates if DDNS needs to generate a hostname when not supplied by the client.  Defaults to _false_.
   * @return ddnsGenerateName
   */
  @javax.annotation.Nullable
  public Boolean getDdnsGenerateName() {
    return ddnsGenerateName;
  }

  public void setDdnsGenerateName(@javax.annotation.Nullable Boolean ddnsGenerateName) {
    this.ddnsGenerateName = ddnsGenerateName;
  }


  public IpamsvcIPSpace ddnsGeneratedPrefix(@javax.annotation.Nullable String ddnsGeneratedPrefix) {
    this.ddnsGeneratedPrefix = ddnsGeneratedPrefix;
    return this;
  }

  /**
   * The prefix used in the generation of an FQDN.  When generating a name, DHCP server will construct the name in the format: [ddns-generated-prefix]-[address-text].[ddns-qualifying-suffix]. where address-text is simply the lease IP address converted to a hyphenated string.  Defaults to \&quot;myhost\&quot;.
   * @return ddnsGeneratedPrefix
   */
  @javax.annotation.Nullable
  public String getDdnsGeneratedPrefix() {
    return ddnsGeneratedPrefix;
  }

  public void setDdnsGeneratedPrefix(@javax.annotation.Nullable String ddnsGeneratedPrefix) {
    this.ddnsGeneratedPrefix = ddnsGeneratedPrefix;
  }


  public IpamsvcIPSpace ddnsSendUpdates(@javax.annotation.Nullable Boolean ddnsSendUpdates) {
    this.ddnsSendUpdates = ddnsSendUpdates;
    return this;
  }

  /**
   * Determines if DDNS updates are enabled at the IP space level. Defaults to _true_.
   * @return ddnsSendUpdates
   */
  @javax.annotation.Nullable
  public Boolean getDdnsSendUpdates() {
    return ddnsSendUpdates;
  }

  public void setDdnsSendUpdates(@javax.annotation.Nullable Boolean ddnsSendUpdates) {
    this.ddnsSendUpdates = ddnsSendUpdates;
  }


  public IpamsvcIPSpace ddnsTtlPercent(@javax.annotation.Nullable Float ddnsTtlPercent) {
    this.ddnsTtlPercent = ddnsTtlPercent;
    return this;
  }

  /**
   * DDNS TTL value - to be calculated as a simple percentage of the lease&#39;s lifetime, using the parameter&#39;s value as the percentage. It is specified as a percentage (e.g. 25, 75). Defaults to unspecified.
   * @return ddnsTtlPercent
   */
  @javax.annotation.Nullable
  public Float getDdnsTtlPercent() {
    return ddnsTtlPercent;
  }

  public void setDdnsTtlPercent(@javax.annotation.Nullable Float ddnsTtlPercent) {
    this.ddnsTtlPercent = ddnsTtlPercent;
  }


  public IpamsvcIPSpace ddnsUpdateOnRenew(@javax.annotation.Nullable Boolean ddnsUpdateOnRenew) {
    this.ddnsUpdateOnRenew = ddnsUpdateOnRenew;
    return this;
  }

  /**
   * Instructs the DHCP server to always update the DNS information when a lease is renewed even if its DNS information has not changed.  Defaults to _false_.
   * @return ddnsUpdateOnRenew
   */
  @javax.annotation.Nullable
  public Boolean getDdnsUpdateOnRenew() {
    return ddnsUpdateOnRenew;
  }

  public void setDdnsUpdateOnRenew(@javax.annotation.Nullable Boolean ddnsUpdateOnRenew) {
    this.ddnsUpdateOnRenew = ddnsUpdateOnRenew;
  }


  public IpamsvcIPSpace ddnsUseConflictResolution(@javax.annotation.Nullable Boolean ddnsUseConflictResolution) {
    this.ddnsUseConflictResolution = ddnsUseConflictResolution;
    return this;
  }

  /**
   * When true, DHCP server will apply conflict resolution, as described in RFC 4703, when attempting to fulfill the update request.  When false, DHCP server will simply attempt to update the DNS entries per the request, regardless of whether or not they conflict with existing entries owned by other DHCP4 clients.  Defaults to _true_.
   * @return ddnsUseConflictResolution
   */
  @javax.annotation.Nullable
  public Boolean getDdnsUseConflictResolution() {
    return ddnsUseConflictResolution;
  }

  public void setDdnsUseConflictResolution(@javax.annotation.Nullable Boolean ddnsUseConflictResolution) {
    this.ddnsUseConflictResolution = ddnsUseConflictResolution;
  }


  public IpamsvcIPSpace defaultRealms(@javax.annotation.Nullable List<String> defaultRealms) {
    this.defaultRealms = defaultRealms;
    return this;
  }

  public IpamsvcIPSpace addDefaultRealmsItem(String defaultRealmsItem) {
    if (this.defaultRealms == null) {
      this.defaultRealms = new ArrayList<>();
    }
    this.defaultRealms.add(defaultRealmsItem);
    return this;
  }

  /**
   * Reserved for future use.
   * @return defaultRealms
   */
  @javax.annotation.Nullable
  public List<String> getDefaultRealms() {
    return defaultRealms;
  }

  public void setDefaultRealms(@javax.annotation.Nullable List<String> defaultRealms) {
    this.defaultRealms = defaultRealms;
  }


  public IpamsvcIPSpace dhcpConfig(@javax.annotation.Nullable IpamsvcDHCPConfig dhcpConfig) {
    this.dhcpConfig = dhcpConfig;
    return this;
  }

  /**
   * Get dhcpConfig
   * @return dhcpConfig
   */
  @javax.annotation.Nullable
  public IpamsvcDHCPConfig getDhcpConfig() {
    return dhcpConfig;
  }

  public void setDhcpConfig(@javax.annotation.Nullable IpamsvcDHCPConfig dhcpConfig) {
    this.dhcpConfig = dhcpConfig;
  }


  public IpamsvcIPSpace dhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
    return this;
  }

  public IpamsvcIPSpace addDhcpOptionsItem(IpamsvcOptionItem dhcpOptionsItem) {
    if (this.dhcpOptions == null) {
      this.dhcpOptions = new ArrayList<>();
    }
    this.dhcpOptions.add(dhcpOptionsItem);
    return this;
  }

  /**
   * The list of IPv4 DHCP options for IP space. May be either a specific option or a group of options.
   * @return dhcpOptions
   */
  @javax.annotation.Nullable
  public List<IpamsvcOptionItem> getDhcpOptions() {
    return dhcpOptions;
  }

  public void setDhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
  }


  public IpamsvcIPSpace dhcpOptionsV6(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptionsV6) {
    this.dhcpOptionsV6 = dhcpOptionsV6;
    return this;
  }

  public IpamsvcIPSpace addDhcpOptionsV6Item(IpamsvcOptionItem dhcpOptionsV6Item) {
    if (this.dhcpOptionsV6 == null) {
      this.dhcpOptionsV6 = new ArrayList<>();
    }
    this.dhcpOptionsV6.add(dhcpOptionsV6Item);
    return this;
  }

  /**
   * The list of IPv6 DHCP options for IP space. May be either a specific option or a group of options.
   * @return dhcpOptionsV6
   */
  @javax.annotation.Nullable
  public List<IpamsvcOptionItem> getDhcpOptionsV6() {
    return dhcpOptionsV6;
  }

  public void setDhcpOptionsV6(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptionsV6) {
    this.dhcpOptionsV6 = dhcpOptionsV6;
  }


  public IpamsvcIPSpace headerOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
    return this;
  }

  /**
   * The configuration for header option filename field.
   * @return headerOptionFilename
   */
  @javax.annotation.Nullable
  public String getHeaderOptionFilename() {
    return headerOptionFilename;
  }

  public void setHeaderOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
  }


  public IpamsvcIPSpace headerOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
    return this;
  }

  /**
   * The configuration for header option server address field.
   * @return headerOptionServerAddress
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerAddress() {
    return headerOptionServerAddress;
  }

  public void setHeaderOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
  }


  public IpamsvcIPSpace headerOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
    return this;
  }

  /**
   * The configuration for header option server name field.
   * @return headerOptionServerName
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerName() {
    return headerOptionServerName;
  }

  public void setHeaderOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
  }


  public IpamsvcIPSpace hostnameRewriteChar(@javax.annotation.Nullable String hostnameRewriteChar) {
    this.hostnameRewriteChar = hostnameRewriteChar;
    return this;
  }

  /**
   * The character to replace non-matching characters with, when hostname rewrite is enabled.  Any single ASCII character or no character if the invalid characters should be removed without replacement.  Defaults to \&quot;-\&quot;.
   * @return hostnameRewriteChar
   */
  @javax.annotation.Nullable
  public String getHostnameRewriteChar() {
    return hostnameRewriteChar;
  }

  public void setHostnameRewriteChar(@javax.annotation.Nullable String hostnameRewriteChar) {
    this.hostnameRewriteChar = hostnameRewriteChar;
  }


  public IpamsvcIPSpace hostnameRewriteEnabled(@javax.annotation.Nullable Boolean hostnameRewriteEnabled) {
    this.hostnameRewriteEnabled = hostnameRewriteEnabled;
    return this;
  }

  /**
   * Indicates if client supplied hostnames will be rewritten prior to DDNS update by replacing every character that does not match _hostname_rewrite_regex_ by _hostname_rewrite_char_.  Defaults to _false_.
   * @return hostnameRewriteEnabled
   */
  @javax.annotation.Nullable
  public Boolean getHostnameRewriteEnabled() {
    return hostnameRewriteEnabled;
  }

  public void setHostnameRewriteEnabled(@javax.annotation.Nullable Boolean hostnameRewriteEnabled) {
    this.hostnameRewriteEnabled = hostnameRewriteEnabled;
  }


  public IpamsvcIPSpace hostnameRewriteRegex(@javax.annotation.Nullable String hostnameRewriteRegex) {
    this.hostnameRewriteRegex = hostnameRewriteRegex;
    return this;
  }

  /**
   * The regex bracket expression to match valid characters.  Must begin with \&quot;[\&quot; and end with \&quot;]\&quot; and be a compilable POSIX regex.  Defaults to \&quot;[^a-zA-Z0-9_.]\&quot;.
   * @return hostnameRewriteRegex
   */
  @javax.annotation.Nullable
  public String getHostnameRewriteRegex() {
    return hostnameRewriteRegex;
  }

  public void setHostnameRewriteRegex(@javax.annotation.Nullable String hostnameRewriteRegex) {
    this.hostnameRewriteRegex = hostnameRewriteRegex;
  }


  /**
   * The resource identifier.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public IpamsvcIPSpace inheritanceSources(@javax.annotation.Nullable IpamsvcIPSpaceInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
    return this;
  }

  /**
   * Get inheritanceSources
   * @return inheritanceSources
   */
  @javax.annotation.Nullable
  public IpamsvcIPSpaceInheritance getInheritanceSources() {
    return inheritanceSources;
  }

  public void setInheritanceSources(@javax.annotation.Nullable IpamsvcIPSpaceInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
  }


  public IpamsvcIPSpace name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the IP space. Must contain 1 to 256 characters. Can include UTF-8.
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public IpamsvcIPSpace tags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
    return this;
  }

  /**
   * The tags for the IP space in JSON format.
   * @return tags
   */
  @javax.annotation.Nullable
  public Object getTags() {
    return tags;
  }

  public void setTags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
  }


  public IpamsvcIPSpace threshold(@javax.annotation.Nullable IpamsvcUtilizationThreshold threshold) {
    this.threshold = threshold;
    return this;
  }

  /**
   * Get threshold
   * @return threshold
   */
  @javax.annotation.Nullable
  public IpamsvcUtilizationThreshold getThreshold() {
    return threshold;
  }

  public void setThreshold(@javax.annotation.Nullable IpamsvcUtilizationThreshold threshold) {
    this.threshold = threshold;
  }


  /**
   * Time when the object has been updated. Equals to _created_at_ if not updated after creation.
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }



  public IpamsvcIPSpace utilization(@javax.annotation.Nullable IpamsvcUtilization utilization) {
    this.utilization = utilization;
    return this;
  }

  /**
   * Get utilization
   * @return utilization
   */
  @javax.annotation.Nullable
  public IpamsvcUtilization getUtilization() {
    return utilization;
  }

  public void setUtilization(@javax.annotation.Nullable IpamsvcUtilization utilization) {
    this.utilization = utilization;
  }


  public IpamsvcIPSpace utilizationV6(@javax.annotation.Nullable IpamsvcUtilizationV6 utilizationV6) {
    this.utilizationV6 = utilizationV6;
    return this;
  }

  /**
   * Get utilizationV6
   * @return utilizationV6
   */
  @javax.annotation.Nullable
  public IpamsvcUtilizationV6 getUtilizationV6() {
    return utilizationV6;
  }

  public void setUtilizationV6(@javax.annotation.Nullable IpamsvcUtilizationV6 utilizationV6) {
    this.utilizationV6 = utilizationV6;
  }


  public IpamsvcIPSpace vendorSpecificOptionOptionSpace(@javax.annotation.Nullable String vendorSpecificOptionOptionSpace) {
    this.vendorSpecificOptionOptionSpace = vendorSpecificOptionOptionSpace;
    return this;
  }

  /**
   * The resource identifier.
   * @return vendorSpecificOptionOptionSpace
   */
  @javax.annotation.Nullable
  public String getVendorSpecificOptionOptionSpace() {
    return vendorSpecificOptionOptionSpace;
  }

  public void setVendorSpecificOptionOptionSpace(@javax.annotation.Nullable String vendorSpecificOptionOptionSpace) {
    this.vendorSpecificOptionOptionSpace = vendorSpecificOptionOptionSpace;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IpamsvcIPSpace ipamsvcIPSpace = (IpamsvcIPSpace) o;
    return Objects.equals(this.asmConfig, ipamsvcIPSpace.asmConfig) &&
        Objects.equals(this.asmScopeFlag, ipamsvcIPSpace.asmScopeFlag) &&
        Objects.equals(this.comment, ipamsvcIPSpace.comment) &&
        Objects.equals(this.compartmentId, ipamsvcIPSpace.compartmentId) &&
        Objects.equals(this.createdAt, ipamsvcIPSpace.createdAt) &&
        Objects.equals(this.ddnsClientUpdate, ipamsvcIPSpace.ddnsClientUpdate) &&
        Objects.equals(this.ddnsConflictResolutionMode, ipamsvcIPSpace.ddnsConflictResolutionMode) &&
        Objects.equals(this.ddnsDomain, ipamsvcIPSpace.ddnsDomain) &&
        Objects.equals(this.ddnsGenerateName, ipamsvcIPSpace.ddnsGenerateName) &&
        Objects.equals(this.ddnsGeneratedPrefix, ipamsvcIPSpace.ddnsGeneratedPrefix) &&
        Objects.equals(this.ddnsSendUpdates, ipamsvcIPSpace.ddnsSendUpdates) &&
        Objects.equals(this.ddnsTtlPercent, ipamsvcIPSpace.ddnsTtlPercent) &&
        Objects.equals(this.ddnsUpdateOnRenew, ipamsvcIPSpace.ddnsUpdateOnRenew) &&
        Objects.equals(this.ddnsUseConflictResolution, ipamsvcIPSpace.ddnsUseConflictResolution) &&
        Objects.equals(this.defaultRealms, ipamsvcIPSpace.defaultRealms) &&
        Objects.equals(this.dhcpConfig, ipamsvcIPSpace.dhcpConfig) &&
        Objects.equals(this.dhcpOptions, ipamsvcIPSpace.dhcpOptions) &&
        Objects.equals(this.dhcpOptionsV6, ipamsvcIPSpace.dhcpOptionsV6) &&
        Objects.equals(this.headerOptionFilename, ipamsvcIPSpace.headerOptionFilename) &&
        Objects.equals(this.headerOptionServerAddress, ipamsvcIPSpace.headerOptionServerAddress) &&
        Objects.equals(this.headerOptionServerName, ipamsvcIPSpace.headerOptionServerName) &&
        Objects.equals(this.hostnameRewriteChar, ipamsvcIPSpace.hostnameRewriteChar) &&
        Objects.equals(this.hostnameRewriteEnabled, ipamsvcIPSpace.hostnameRewriteEnabled) &&
        Objects.equals(this.hostnameRewriteRegex, ipamsvcIPSpace.hostnameRewriteRegex) &&
        Objects.equals(this.id, ipamsvcIPSpace.id) &&
        Objects.equals(this.inheritanceSources, ipamsvcIPSpace.inheritanceSources) &&
        Objects.equals(this.name, ipamsvcIPSpace.name) &&
        Objects.equals(this.tags, ipamsvcIPSpace.tags) &&
        Objects.equals(this.threshold, ipamsvcIPSpace.threshold) &&
        Objects.equals(this.updatedAt, ipamsvcIPSpace.updatedAt) &&
        Objects.equals(this.utilization, ipamsvcIPSpace.utilization) &&
        Objects.equals(this.utilizationV6, ipamsvcIPSpace.utilizationV6) &&
        Objects.equals(this.vendorSpecificOptionOptionSpace, ipamsvcIPSpace.vendorSpecificOptionOptionSpace);
  }

  @Override
  public int hashCode() {
    return Objects.hash(asmConfig, asmScopeFlag, comment, compartmentId, createdAt, ddnsClientUpdate, ddnsConflictResolutionMode, ddnsDomain, ddnsGenerateName, ddnsGeneratedPrefix, ddnsSendUpdates, ddnsTtlPercent, ddnsUpdateOnRenew, ddnsUseConflictResolution, defaultRealms, dhcpConfig, dhcpOptions, dhcpOptionsV6, headerOptionFilename, headerOptionServerAddress, headerOptionServerName, hostnameRewriteChar, hostnameRewriteEnabled, hostnameRewriteRegex, id, inheritanceSources, name, tags, threshold, updatedAt, utilization, utilizationV6, vendorSpecificOptionOptionSpace);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IpamsvcIPSpace {\n");
    sb.append("    asmConfig: ").append(toIndentedString(asmConfig)).append("\n");
    sb.append("    asmScopeFlag: ").append(toIndentedString(asmScopeFlag)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    compartmentId: ").append(toIndentedString(compartmentId)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    ddnsClientUpdate: ").append(toIndentedString(ddnsClientUpdate)).append("\n");
    sb.append("    ddnsConflictResolutionMode: ").append(toIndentedString(ddnsConflictResolutionMode)).append("\n");
    sb.append("    ddnsDomain: ").append(toIndentedString(ddnsDomain)).append("\n");
    sb.append("    ddnsGenerateName: ").append(toIndentedString(ddnsGenerateName)).append("\n");
    sb.append("    ddnsGeneratedPrefix: ").append(toIndentedString(ddnsGeneratedPrefix)).append("\n");
    sb.append("    ddnsSendUpdates: ").append(toIndentedString(ddnsSendUpdates)).append("\n");
    sb.append("    ddnsTtlPercent: ").append(toIndentedString(ddnsTtlPercent)).append("\n");
    sb.append("    ddnsUpdateOnRenew: ").append(toIndentedString(ddnsUpdateOnRenew)).append("\n");
    sb.append("    ddnsUseConflictResolution: ").append(toIndentedString(ddnsUseConflictResolution)).append("\n");
    sb.append("    defaultRealms: ").append(toIndentedString(defaultRealms)).append("\n");
    sb.append("    dhcpConfig: ").append(toIndentedString(dhcpConfig)).append("\n");
    sb.append("    dhcpOptions: ").append(toIndentedString(dhcpOptions)).append("\n");
    sb.append("    dhcpOptionsV6: ").append(toIndentedString(dhcpOptionsV6)).append("\n");
    sb.append("    headerOptionFilename: ").append(toIndentedString(headerOptionFilename)).append("\n");
    sb.append("    headerOptionServerAddress: ").append(toIndentedString(headerOptionServerAddress)).append("\n");
    sb.append("    headerOptionServerName: ").append(toIndentedString(headerOptionServerName)).append("\n");
    sb.append("    hostnameRewriteChar: ").append(toIndentedString(hostnameRewriteChar)).append("\n");
    sb.append("    hostnameRewriteEnabled: ").append(toIndentedString(hostnameRewriteEnabled)).append("\n");
    sb.append("    hostnameRewriteRegex: ").append(toIndentedString(hostnameRewriteRegex)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    inheritanceSources: ").append(toIndentedString(inheritanceSources)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    threshold: ").append(toIndentedString(threshold)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    utilization: ").append(toIndentedString(utilization)).append("\n");
    sb.append("    utilizationV6: ").append(toIndentedString(utilizationV6)).append("\n");
    sb.append("    vendorSpecificOptionOptionSpace: ").append(toIndentedString(vendorSpecificOptionOptionSpace)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("asm_config");
    openapiFields.add("asm_scope_flag");
    openapiFields.add("comment");
    openapiFields.add("compartment_id");
    openapiFields.add("created_at");
    openapiFields.add("ddns_client_update");
    openapiFields.add("ddns_conflict_resolution_mode");
    openapiFields.add("ddns_domain");
    openapiFields.add("ddns_generate_name");
    openapiFields.add("ddns_generated_prefix");
    openapiFields.add("ddns_send_updates");
    openapiFields.add("ddns_ttl_percent");
    openapiFields.add("ddns_update_on_renew");
    openapiFields.add("ddns_use_conflict_resolution");
    openapiFields.add("default_realms");
    openapiFields.add("dhcp_config");
    openapiFields.add("dhcp_options");
    openapiFields.add("dhcp_options_v6");
    openapiFields.add("header_option_filename");
    openapiFields.add("header_option_server_address");
    openapiFields.add("header_option_server_name");
    openapiFields.add("hostname_rewrite_char");
    openapiFields.add("hostname_rewrite_enabled");
    openapiFields.add("hostname_rewrite_regex");
    openapiFields.add("id");
    openapiFields.add("inheritance_sources");
    openapiFields.add("name");
    openapiFields.add("tags");
    openapiFields.add("threshold");
    openapiFields.add("updated_at");
    openapiFields.add("utilization");
    openapiFields.add("utilization_v6");
    openapiFields.add("vendor_specific_option_option_space");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IpamsvcIPSpace
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IpamsvcIPSpace.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IpamsvcIPSpace is not found in the empty JSON string", IpamsvcIPSpace.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IpamsvcIPSpace.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IpamsvcIPSpace` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : IpamsvcIPSpace.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `asm_config`
      if (jsonObj.get("asm_config") != null && !jsonObj.get("asm_config").isJsonNull()) {
        IpamsvcASMConfig.validateJsonElement(jsonObj.get("asm_config"));
      }
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if ((jsonObj.get("compartment_id") != null && !jsonObj.get("compartment_id").isJsonNull()) && !jsonObj.get("compartment_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compartment_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compartment_id").toString()));
      }
      if ((jsonObj.get("ddns_client_update") != null && !jsonObj.get("ddns_client_update").isJsonNull()) && !jsonObj.get("ddns_client_update").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_client_update` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_client_update").toString()));
      }
      if ((jsonObj.get("ddns_conflict_resolution_mode") != null && !jsonObj.get("ddns_conflict_resolution_mode").isJsonNull()) && !jsonObj.get("ddns_conflict_resolution_mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_conflict_resolution_mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_conflict_resolution_mode").toString()));
      }
      if ((jsonObj.get("ddns_domain") != null && !jsonObj.get("ddns_domain").isJsonNull()) && !jsonObj.get("ddns_domain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_domain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_domain").toString()));
      }
      if ((jsonObj.get("ddns_generated_prefix") != null && !jsonObj.get("ddns_generated_prefix").isJsonNull()) && !jsonObj.get("ddns_generated_prefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_generated_prefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_generated_prefix").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("default_realms") != null && !jsonObj.get("default_realms").isJsonNull() && !jsonObj.get("default_realms").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `default_realms` to be an array in the JSON string but got `%s`", jsonObj.get("default_realms").toString()));
      }
      // validate the optional field `dhcp_config`
      if (jsonObj.get("dhcp_config") != null && !jsonObj.get("dhcp_config").isJsonNull()) {
        IpamsvcDHCPConfig.validateJsonElement(jsonObj.get("dhcp_config"));
      }
      if (jsonObj.get("dhcp_options") != null && !jsonObj.get("dhcp_options").isJsonNull()) {
        JsonArray jsonArraydhcpOptions = jsonObj.getAsJsonArray("dhcp_options");
        if (jsonArraydhcpOptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dhcp_options").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dhcp_options` to be an array in the JSON string but got `%s`", jsonObj.get("dhcp_options").toString()));
          }

          // validate the optional field `dhcp_options` (array)
          for (int i = 0; i < jsonArraydhcpOptions.size(); i++) {
            IpamsvcOptionItem.validateJsonElement(jsonArraydhcpOptions.get(i));
          };
        }
      }
      if (jsonObj.get("dhcp_options_v6") != null && !jsonObj.get("dhcp_options_v6").isJsonNull()) {
        JsonArray jsonArraydhcpOptionsV6 = jsonObj.getAsJsonArray("dhcp_options_v6");
        if (jsonArraydhcpOptionsV6 != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dhcp_options_v6").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dhcp_options_v6` to be an array in the JSON string but got `%s`", jsonObj.get("dhcp_options_v6").toString()));
          }

          // validate the optional field `dhcp_options_v6` (array)
          for (int i = 0; i < jsonArraydhcpOptionsV6.size(); i++) {
            IpamsvcOptionItem.validateJsonElement(jsonArraydhcpOptionsV6.get(i));
          };
        }
      }
      if ((jsonObj.get("header_option_filename") != null && !jsonObj.get("header_option_filename").isJsonNull()) && !jsonObj.get("header_option_filename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_filename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_filename").toString()));
      }
      if ((jsonObj.get("header_option_server_address") != null && !jsonObj.get("header_option_server_address").isJsonNull()) && !jsonObj.get("header_option_server_address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_address").toString()));
      }
      if ((jsonObj.get("header_option_server_name") != null && !jsonObj.get("header_option_server_name").isJsonNull()) && !jsonObj.get("header_option_server_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_name").toString()));
      }
      if ((jsonObj.get("hostname_rewrite_char") != null && !jsonObj.get("hostname_rewrite_char").isJsonNull()) && !jsonObj.get("hostname_rewrite_char").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname_rewrite_char` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname_rewrite_char").toString()));
      }
      if ((jsonObj.get("hostname_rewrite_regex") != null && !jsonObj.get("hostname_rewrite_regex").isJsonNull()) && !jsonObj.get("hostname_rewrite_regex").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname_rewrite_regex` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname_rewrite_regex").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `inheritance_sources`
      if (jsonObj.get("inheritance_sources") != null && !jsonObj.get("inheritance_sources").isJsonNull()) {
        IpamsvcIPSpaceInheritance.validateJsonElement(jsonObj.get("inheritance_sources"));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `threshold`
      if (jsonObj.get("threshold") != null && !jsonObj.get("threshold").isJsonNull()) {
        IpamsvcUtilizationThreshold.validateJsonElement(jsonObj.get("threshold"));
      }
      // validate the optional field `utilization`
      if (jsonObj.get("utilization") != null && !jsonObj.get("utilization").isJsonNull()) {
        IpamsvcUtilization.validateJsonElement(jsonObj.get("utilization"));
      }
      // validate the optional field `utilization_v6`
      if (jsonObj.get("utilization_v6") != null && !jsonObj.get("utilization_v6").isJsonNull()) {
        IpamsvcUtilizationV6.validateJsonElement(jsonObj.get("utilization_v6"));
      }
      if ((jsonObj.get("vendor_specific_option_option_space") != null && !jsonObj.get("vendor_specific_option_option_space").isJsonNull()) && !jsonObj.get("vendor_specific_option_option_space").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vendor_specific_option_option_space` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vendor_specific_option_option_space").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IpamsvcIPSpace.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IpamsvcIPSpace' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IpamsvcIPSpace> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IpamsvcIPSpace.class));

       return (TypeAdapter<T>) new TypeAdapter<IpamsvcIPSpace>() {
           @Override
           public void write(JsonWriter out, IpamsvcIPSpace value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IpamsvcIPSpace read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IpamsvcIPSpace given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IpamsvcIPSpace
   * @throws IOException if the JSON string is invalid with respect to IpamsvcIPSpace
   */
  public static IpamsvcIPSpace fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IpamsvcIPSpace.class);
  }

  /**
   * Convert an instance of IpamsvcIPSpace to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

