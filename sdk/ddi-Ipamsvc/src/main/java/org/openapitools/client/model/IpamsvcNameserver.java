/*
 * IP Address Management API
 * The IPAM/DHCP Application is a BloxOne DDI service providing IP address management and DHCP protocol features. The IPAM component provides visibility into and provisioning tools to manage networking spaces, monitoring and reporting of entire IP address infrastructures, and integration with DNS and DHCP protocols. The DHCP component provides DHCP protocol configuration service with on-prem host serving DHCP protocol. It is part of the full-featured, DDI cloud solution that enables customers to deploy large numbers of protocol servers to deliver DNS and DHCP throughout their enterprise network.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * IpamsvcNameserver
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:31.429972+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class IpamsvcNameserver {
  public static final String SERIALIZED_NAME_CLIENT_PRINCIPAL = "client_principal";
  @SerializedName(SERIALIZED_NAME_CLIENT_PRINCIPAL)
  @javax.annotation.Nullable
  private String clientPrincipal;

  public static final String SERIALIZED_NAME_GSS_TSIG_FALLBACK = "gss_tsig_fallback";
  @SerializedName(SERIALIZED_NAME_GSS_TSIG_FALLBACK)
  @javax.annotation.Nullable
  private Boolean gssTsigFallback;

  public static final String SERIALIZED_NAME_KERBEROS_REKEY_INTERVAL = "kerberos_rekey_interval";
  @SerializedName(SERIALIZED_NAME_KERBEROS_REKEY_INTERVAL)
  @javax.annotation.Nullable
  private Long kerberosRekeyInterval;

  public static final String SERIALIZED_NAME_KERBEROS_RETRY_INTERVAL = "kerberos_retry_interval";
  @SerializedName(SERIALIZED_NAME_KERBEROS_RETRY_INTERVAL)
  @javax.annotation.Nullable
  private Long kerberosRetryInterval;

  public static final String SERIALIZED_NAME_KERBEROS_TKEY_LIFETIME = "kerberos_tkey_lifetime";
  @SerializedName(SERIALIZED_NAME_KERBEROS_TKEY_LIFETIME)
  @javax.annotation.Nullable
  private Long kerberosTkeyLifetime;

  public static final String SERIALIZED_NAME_KERBEROS_TKEY_PROTOCOL = "kerberos_tkey_protocol";
  @SerializedName(SERIALIZED_NAME_KERBEROS_TKEY_PROTOCOL)
  @javax.annotation.Nullable
  private String kerberosTkeyProtocol;

  public static final String SERIALIZED_NAME_NAMESERVER = "nameserver";
  @SerializedName(SERIALIZED_NAME_NAMESERVER)
  @javax.annotation.Nullable
  private String nameserver;

  public static final String SERIALIZED_NAME_SERVER_PRINCIPAL = "server_principal";
  @SerializedName(SERIALIZED_NAME_SERVER_PRINCIPAL)
  @javax.annotation.Nullable
  private String serverPrincipal;

  public IpamsvcNameserver() {
  }

  public IpamsvcNameserver clientPrincipal(@javax.annotation.Nullable String clientPrincipal) {
    this.clientPrincipal = clientPrincipal;
    return this;
  }

  /**
   * The Kerberos principal name. It uses the typical Kerberos notation: &lt;SERVICE-NAME&gt;/&lt;server-domain-name&gt;@&lt;REALM&gt;.  Defaults to empty.
   * @return clientPrincipal
   */
  @javax.annotation.Nullable
  public String getClientPrincipal() {
    return clientPrincipal;
  }

  public void setClientPrincipal(@javax.annotation.Nullable String clientPrincipal) {
    this.clientPrincipal = clientPrincipal;
  }


  public IpamsvcNameserver gssTsigFallback(@javax.annotation.Nullable Boolean gssTsigFallback) {
    this.gssTsigFallback = gssTsigFallback;
    return this;
  }

  /**
   * The behavior when GSS-TSIG should be used (a matching external DNS server is configured) but no GSS-TSIG key is available. If configured to _false_ (the default) this DNS server is skipped, if configured to _true_ the DNS server is ignored and the DNS update is sent with the configured DHCP-DDNS protection e.g. TSIG key or without any protection when none was configured.  Defaults to _false_.
   * @return gssTsigFallback
   */
  @javax.annotation.Nullable
  public Boolean getGssTsigFallback() {
    return gssTsigFallback;
  }

  public void setGssTsigFallback(@javax.annotation.Nullable Boolean gssTsigFallback) {
    this.gssTsigFallback = gssTsigFallback;
  }


  public IpamsvcNameserver kerberosRekeyInterval(@javax.annotation.Nullable Long kerberosRekeyInterval) {
    this.kerberosRekeyInterval = kerberosRekeyInterval;
    return this;
  }

  /**
   * Time interval (in seconds) the keys for each configured external DNS server are checked for rekeying, i.e. a new key is created to replace the current usable one when its age is greater than the _kerberos_rekey_interval_ value.  Defaults to 120 seconds.
   * @return kerberosRekeyInterval
   */
  @javax.annotation.Nullable
  public Long getKerberosRekeyInterval() {
    return kerberosRekeyInterval;
  }

  public void setKerberosRekeyInterval(@javax.annotation.Nullable Long kerberosRekeyInterval) {
    this.kerberosRekeyInterval = kerberosRekeyInterval;
  }


  public IpamsvcNameserver kerberosRetryInterval(@javax.annotation.Nullable Long kerberosRetryInterval) {
    this.kerberosRetryInterval = kerberosRetryInterval;
    return this;
  }

  /**
   * Time interval (in seconds) to retry to create a key if any error occurred previously for any configured external DNS server.  Defaults to 30 seconds.
   * @return kerberosRetryInterval
   */
  @javax.annotation.Nullable
  public Long getKerberosRetryInterval() {
    return kerberosRetryInterval;
  }

  public void setKerberosRetryInterval(@javax.annotation.Nullable Long kerberosRetryInterval) {
    this.kerberosRetryInterval = kerberosRetryInterval;
  }


  public IpamsvcNameserver kerberosTkeyLifetime(@javax.annotation.Nullable Long kerberosTkeyLifetime) {
    this.kerberosTkeyLifetime = kerberosTkeyLifetime;
    return this;
  }

  /**
   * Lifetime (in seconds) of GSS-TSIG keys in the TKEY protocol.  Defaults to 160 seconds.
   * @return kerberosTkeyLifetime
   */
  @javax.annotation.Nullable
  public Long getKerberosTkeyLifetime() {
    return kerberosTkeyLifetime;
  }

  public void setKerberosTkeyLifetime(@javax.annotation.Nullable Long kerberosTkeyLifetime) {
    this.kerberosTkeyLifetime = kerberosTkeyLifetime;
  }


  public IpamsvcNameserver kerberosTkeyProtocol(@javax.annotation.Nullable String kerberosTkeyProtocol) {
    this.kerberosTkeyProtocol = kerberosTkeyProtocol;
    return this;
  }

  /**
   * Determines which protocol is used to establish the security context with the external DNS servers, TCP or UDP.  Defaults to _tcp_.
   * @return kerberosTkeyProtocol
   */
  @javax.annotation.Nullable
  public String getKerberosTkeyProtocol() {
    return kerberosTkeyProtocol;
  }

  public void setKerberosTkeyProtocol(@javax.annotation.Nullable String kerberosTkeyProtocol) {
    this.kerberosTkeyProtocol = kerberosTkeyProtocol;
  }


  public IpamsvcNameserver nameserver(@javax.annotation.Nullable String nameserver) {
    this.nameserver = nameserver;
    return this;
  }

  /**
   * Get nameserver
   * @return nameserver
   */
  @javax.annotation.Nullable
  public String getNameserver() {
    return nameserver;
  }

  public void setNameserver(@javax.annotation.Nullable String nameserver) {
    this.nameserver = nameserver;
  }


  public IpamsvcNameserver serverPrincipal(@javax.annotation.Nullable String serverPrincipal) {
    this.serverPrincipal = serverPrincipal;
    return this;
  }

  /**
   * The Kerberos principal name of this DNS server that will receive updates.  Defaults to empty.
   * @return serverPrincipal
   */
  @javax.annotation.Nullable
  public String getServerPrincipal() {
    return serverPrincipal;
  }

  public void setServerPrincipal(@javax.annotation.Nullable String serverPrincipal) {
    this.serverPrincipal = serverPrincipal;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IpamsvcNameserver ipamsvcNameserver = (IpamsvcNameserver) o;
    return Objects.equals(this.clientPrincipal, ipamsvcNameserver.clientPrincipal) &&
        Objects.equals(this.gssTsigFallback, ipamsvcNameserver.gssTsigFallback) &&
        Objects.equals(this.kerberosRekeyInterval, ipamsvcNameserver.kerberosRekeyInterval) &&
        Objects.equals(this.kerberosRetryInterval, ipamsvcNameserver.kerberosRetryInterval) &&
        Objects.equals(this.kerberosTkeyLifetime, ipamsvcNameserver.kerberosTkeyLifetime) &&
        Objects.equals(this.kerberosTkeyProtocol, ipamsvcNameserver.kerberosTkeyProtocol) &&
        Objects.equals(this.nameserver, ipamsvcNameserver.nameserver) &&
        Objects.equals(this.serverPrincipal, ipamsvcNameserver.serverPrincipal);
  }

  @Override
  public int hashCode() {
    return Objects.hash(clientPrincipal, gssTsigFallback, kerberosRekeyInterval, kerberosRetryInterval, kerberosTkeyLifetime, kerberosTkeyProtocol, nameserver, serverPrincipal);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IpamsvcNameserver {\n");
    sb.append("    clientPrincipal: ").append(toIndentedString(clientPrincipal)).append("\n");
    sb.append("    gssTsigFallback: ").append(toIndentedString(gssTsigFallback)).append("\n");
    sb.append("    kerberosRekeyInterval: ").append(toIndentedString(kerberosRekeyInterval)).append("\n");
    sb.append("    kerberosRetryInterval: ").append(toIndentedString(kerberosRetryInterval)).append("\n");
    sb.append("    kerberosTkeyLifetime: ").append(toIndentedString(kerberosTkeyLifetime)).append("\n");
    sb.append("    kerberosTkeyProtocol: ").append(toIndentedString(kerberosTkeyProtocol)).append("\n");
    sb.append("    nameserver: ").append(toIndentedString(nameserver)).append("\n");
    sb.append("    serverPrincipal: ").append(toIndentedString(serverPrincipal)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("client_principal");
    openapiFields.add("gss_tsig_fallback");
    openapiFields.add("kerberos_rekey_interval");
    openapiFields.add("kerberos_retry_interval");
    openapiFields.add("kerberos_tkey_lifetime");
    openapiFields.add("kerberos_tkey_protocol");
    openapiFields.add("nameserver");
    openapiFields.add("server_principal");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IpamsvcNameserver
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IpamsvcNameserver.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IpamsvcNameserver is not found in the empty JSON string", IpamsvcNameserver.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IpamsvcNameserver.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IpamsvcNameserver` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("client_principal") != null && !jsonObj.get("client_principal").isJsonNull()) && !jsonObj.get("client_principal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `client_principal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("client_principal").toString()));
      }
      if ((jsonObj.get("kerberos_tkey_protocol") != null && !jsonObj.get("kerberos_tkey_protocol").isJsonNull()) && !jsonObj.get("kerberos_tkey_protocol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kerberos_tkey_protocol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kerberos_tkey_protocol").toString()));
      }
      if ((jsonObj.get("nameserver") != null && !jsonObj.get("nameserver").isJsonNull()) && !jsonObj.get("nameserver").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `nameserver` to be a primitive type in the JSON string but got `%s`", jsonObj.get("nameserver").toString()));
      }
      if ((jsonObj.get("server_principal") != null && !jsonObj.get("server_principal").isJsonNull()) && !jsonObj.get("server_principal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `server_principal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("server_principal").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IpamsvcNameserver.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IpamsvcNameserver' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IpamsvcNameserver> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IpamsvcNameserver.class));

       return (TypeAdapter<T>) new TypeAdapter<IpamsvcNameserver>() {
           @Override
           public void write(JsonWriter out, IpamsvcNameserver value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IpamsvcNameserver read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IpamsvcNameserver given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IpamsvcNameserver
   * @throws IOException if the JSON string is invalid with respect to IpamsvcNameserver
   */
  public static IpamsvcNameserver fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IpamsvcNameserver.class);
  }

  /**
   * Convert an instance of IpamsvcNameserver to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

