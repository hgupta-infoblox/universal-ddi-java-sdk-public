/*
 * IP Address Management API
 * The IPAM/DHCP Application is a BloxOne DDI service providing IP address management and DHCP protocol features. The IPAM component provides visibility into and provisioning tools to manage networking spaces, monitoring and reporting of entire IP address infrastructures, and integration with DNS and DHCP protocols. The DHCP component provides DHCP protocol configuration service with on-prem host serving DHCP protocol. It is part of the full-featured, DDI cloud solution that enables customers to deploy large numbers of protocol servers to deliver DNS and DHCP throughout their enterprise network.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.IpamsvcASMConfig;
import org.openapitools.client.model.IpamsvcDHCPConfig;
import org.openapitools.client.model.IpamsvcDHCPInheritance;
import org.openapitools.client.model.IpamsvcDHCPUtilization;
import org.openapitools.client.model.IpamsvcOptionItem;
import org.openapitools.client.model.IpamsvcUtilization;
import org.openapitools.client.model.IpamsvcUtilizationThreshold;
import org.openapitools.client.model.IpamsvcUtilizationV6;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * An __AddressBlock__ object (_ipam/address_block_) is a set of contiguous IP addresses in the same IP space with no gap, expressed as a CIDR block. Address blocks are hierarchical and may be parented to other address blocks as long as the parent block fully contains the child and no sibling overlaps. Top level address blocks are parented to an IP space.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:31.429972+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class IpamsvcAddressBlock {
  public static final String SERIALIZED_NAME_ADDRESS = "address";
  @SerializedName(SERIALIZED_NAME_ADDRESS)
  @javax.annotation.Nonnull
  private String address;

  public static final String SERIALIZED_NAME_ASM_CONFIG = "asm_config";
  @SerializedName(SERIALIZED_NAME_ASM_CONFIG)
  @javax.annotation.Nullable
  private IpamsvcASMConfig asmConfig;

  public static final String SERIALIZED_NAME_ASM_SCOPE_FLAG = "asm_scope_flag";
  @SerializedName(SERIALIZED_NAME_ASM_SCOPE_FLAG)
  @javax.annotation.Nullable
  private Long asmScopeFlag;

  public static final String SERIALIZED_NAME_CIDR = "cidr";
  @SerializedName(SERIALIZED_NAME_CIDR)
  @javax.annotation.Nullable
  private Long cidr;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  @javax.annotation.Nullable
  private String comment;

  public static final String SERIALIZED_NAME_COMPARTMENT_ID = "compartment_id";
  @SerializedName(SERIALIZED_NAME_COMPARTMENT_ID)
  @javax.annotation.Nullable
  private String compartmentId;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DDNS_CLIENT_UPDATE = "ddns_client_update";
  @SerializedName(SERIALIZED_NAME_DDNS_CLIENT_UPDATE)
  @javax.annotation.Nullable
  private String ddnsClientUpdate;

  public static final String SERIALIZED_NAME_DDNS_CONFLICT_RESOLUTION_MODE = "ddns_conflict_resolution_mode";
  @SerializedName(SERIALIZED_NAME_DDNS_CONFLICT_RESOLUTION_MODE)
  @javax.annotation.Nullable
  private String ddnsConflictResolutionMode;

  public static final String SERIALIZED_NAME_DDNS_DOMAIN = "ddns_domain";
  @SerializedName(SERIALIZED_NAME_DDNS_DOMAIN)
  @javax.annotation.Nullable
  private String ddnsDomain;

  public static final String SERIALIZED_NAME_DDNS_GENERATE_NAME = "ddns_generate_name";
  @SerializedName(SERIALIZED_NAME_DDNS_GENERATE_NAME)
  @javax.annotation.Nullable
  private Boolean ddnsGenerateName;

  public static final String SERIALIZED_NAME_DDNS_GENERATED_PREFIX = "ddns_generated_prefix";
  @SerializedName(SERIALIZED_NAME_DDNS_GENERATED_PREFIX)
  @javax.annotation.Nullable
  private String ddnsGeneratedPrefix;

  public static final String SERIALIZED_NAME_DDNS_SEND_UPDATES = "ddns_send_updates";
  @SerializedName(SERIALIZED_NAME_DDNS_SEND_UPDATES)
  @javax.annotation.Nullable
  private Boolean ddnsSendUpdates;

  public static final String SERIALIZED_NAME_DDNS_TTL_PERCENT = "ddns_ttl_percent";
  @SerializedName(SERIALIZED_NAME_DDNS_TTL_PERCENT)
  @javax.annotation.Nullable
  private Float ddnsTtlPercent;

  public static final String SERIALIZED_NAME_DDNS_UPDATE_ON_RENEW = "ddns_update_on_renew";
  @SerializedName(SERIALIZED_NAME_DDNS_UPDATE_ON_RENEW)
  @javax.annotation.Nullable
  private Boolean ddnsUpdateOnRenew;

  public static final String SERIALIZED_NAME_DDNS_USE_CONFLICT_RESOLUTION = "ddns_use_conflict_resolution";
  @SerializedName(SERIALIZED_NAME_DDNS_USE_CONFLICT_RESOLUTION)
  @javax.annotation.Nullable
  private Boolean ddnsUseConflictResolution;

  public static final String SERIALIZED_NAME_DELEGATION = "delegation";
  @SerializedName(SERIALIZED_NAME_DELEGATION)
  @javax.annotation.Nullable
  private String delegation;

  public static final String SERIALIZED_NAME_DHCP_CONFIG = "dhcp_config";
  @SerializedName(SERIALIZED_NAME_DHCP_CONFIG)
  @javax.annotation.Nullable
  private IpamsvcDHCPConfig dhcpConfig;

  public static final String SERIALIZED_NAME_DHCP_OPTIONS = "dhcp_options";
  @SerializedName(SERIALIZED_NAME_DHCP_OPTIONS)
  @javax.annotation.Nullable
  private List<IpamsvcOptionItem> dhcpOptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DHCP_UTILIZATION = "dhcp_utilization";
  @SerializedName(SERIALIZED_NAME_DHCP_UTILIZATION)
  @javax.annotation.Nullable
  private IpamsvcDHCPUtilization dhcpUtilization;

  public static final String SERIALIZED_NAME_DISCOVERY_ATTRS = "discovery_attrs";
  @SerializedName(SERIALIZED_NAME_DISCOVERY_ATTRS)
  @javax.annotation.Nullable
  private Object discoveryAttrs;

  public static final String SERIALIZED_NAME_DISCOVERY_METADATA = "discovery_metadata";
  @SerializedName(SERIALIZED_NAME_DISCOVERY_METADATA)
  @javax.annotation.Nullable
  private Object discoveryMetadata;

  public static final String SERIALIZED_NAME_EXTERNAL_KEYS = "external_keys";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_KEYS)
  @javax.annotation.Nullable
  private Object externalKeys;

  public static final String SERIALIZED_NAME_FEDERATED_REALMS = "federated_realms";
  @SerializedName(SERIALIZED_NAME_FEDERATED_REALMS)
  @javax.annotation.Nullable
  private List<String> federatedRealms = new ArrayList<>();

  public static final String SERIALIZED_NAME_HEADER_OPTION_FILENAME = "header_option_filename";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_FILENAME)
  @javax.annotation.Nullable
  private String headerOptionFilename;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS = "header_option_server_address";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS)
  @javax.annotation.Nullable
  private String headerOptionServerAddress;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME = "header_option_server_name";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME)
  @javax.annotation.Nullable
  private String headerOptionServerName;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_CHAR = "hostname_rewrite_char";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_CHAR)
  @javax.annotation.Nullable
  private String hostnameRewriteChar;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_ENABLED = "hostname_rewrite_enabled";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_ENABLED)
  @javax.annotation.Nullable
  private Boolean hostnameRewriteEnabled;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_REGEX = "hostname_rewrite_regex";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_REGEX)
  @javax.annotation.Nullable
  private String hostnameRewriteRegex;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_INHERITANCE_PARENT = "inheritance_parent";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_PARENT)
  @javax.annotation.Nullable
  private String inheritanceParent;

  public static final String SERIALIZED_NAME_INHERITANCE_SOURCES = "inheritance_sources";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_SOURCES)
  @javax.annotation.Nullable
  private IpamsvcDHCPInheritance inheritanceSources;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nullable
  private String name;

  public static final String SERIALIZED_NAME_PARENT = "parent";
  @SerializedName(SERIALIZED_NAME_PARENT)
  @javax.annotation.Nullable
  private String parent;

  public static final String SERIALIZED_NAME_PROTOCOL = "protocol";
  @SerializedName(SERIALIZED_NAME_PROTOCOL)
  @javax.annotation.Nullable
  private String protocol;

  public static final String SERIALIZED_NAME_SPACE = "space";
  @SerializedName(SERIALIZED_NAME_SPACE)
  @javax.annotation.Nonnull
  private String space;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  @javax.annotation.Nullable
  private Object tags;

  public static final String SERIALIZED_NAME_THRESHOLD = "threshold";
  @SerializedName(SERIALIZED_NAME_THRESHOLD)
  @javax.annotation.Nullable
  private IpamsvcUtilizationThreshold threshold;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_USAGE = "usage";
  @SerializedName(SERIALIZED_NAME_USAGE)
  @javax.annotation.Nullable
  private List<String> usage = new ArrayList<>();

  public static final String SERIALIZED_NAME_UTILIZATION = "utilization";
  @SerializedName(SERIALIZED_NAME_UTILIZATION)
  @javax.annotation.Nullable
  private IpamsvcUtilization utilization;

  public static final String SERIALIZED_NAME_UTILIZATION_V6 = "utilization_v6";
  @SerializedName(SERIALIZED_NAME_UTILIZATION_V6)
  @javax.annotation.Nullable
  private IpamsvcUtilizationV6 utilizationV6;

  public IpamsvcAddressBlock() {
  }

  public IpamsvcAddressBlock(
     Long asmScopeFlag, 
     OffsetDateTime createdAt, 
     String delegation, 
     String id, 
     String protocol, 
     OffsetDateTime updatedAt, 
     List<String> usage
  ) {
    this();
    this.asmScopeFlag = asmScopeFlag;
    this.createdAt = createdAt;
    this.delegation = delegation;
    this.id = id;
    this.protocol = protocol;
    this.updatedAt = updatedAt;
    this.usage = usage;
  }

  public IpamsvcAddressBlock address(@javax.annotation.Nonnull String address) {
    this.address = address;
    return this;
  }

  /**
   * The address field in form “a.b.c.d/n” where the “/n” may be omitted. In this case, the CIDR value must be defined in the _cidr_ field. When reading, the _address_ field is always in the form “a.b.c.d”.
   * @return address
   */
  @javax.annotation.Nonnull
  public String getAddress() {
    return address;
  }

  public void setAddress(@javax.annotation.Nonnull String address) {
    this.address = address;
  }


  public IpamsvcAddressBlock asmConfig(@javax.annotation.Nullable IpamsvcASMConfig asmConfig) {
    this.asmConfig = asmConfig;
    return this;
  }

  /**
   * Get asmConfig
   * @return asmConfig
   */
  @javax.annotation.Nullable
  public IpamsvcASMConfig getAsmConfig() {
    return asmConfig;
  }

  public void setAsmConfig(@javax.annotation.Nullable IpamsvcASMConfig asmConfig) {
    this.asmConfig = asmConfig;
  }


  /**
   * Incremented by 1 if the IP address usage limits for automated scope management are exceeded for any subnets in the address block.
   * @return asmScopeFlag
   */
  @javax.annotation.Nullable
  public Long getAsmScopeFlag() {
    return asmScopeFlag;
  }



  public IpamsvcAddressBlock cidr(@javax.annotation.Nullable Long cidr) {
    this.cidr = cidr;
    return this;
  }

  /**
   * The CIDR of the address block. This is required, if _address_ does not specify it in its input.
   * minimum: 1
   * maximum: 128
   * @return cidr
   */
  @javax.annotation.Nullable
  public Long getCidr() {
    return cidr;
  }

  public void setCidr(@javax.annotation.Nullable Long cidr) {
    this.cidr = cidr;
  }


  public IpamsvcAddressBlock comment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * The description for the address block. May contain 0 to 1024 characters. Can include UTF-8.
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
  }


  public IpamsvcAddressBlock compartmentId(@javax.annotation.Nullable String compartmentId) {
    this.compartmentId = compartmentId;
    return this;
  }

  /**
   * The access view associated with the object. If no access view is associated with the object, the value defaults to empty.
   * @return compartmentId
   */
  @javax.annotation.Nullable
  public String getCompartmentId() {
    return compartmentId;
  }

  public void setCompartmentId(@javax.annotation.Nullable String compartmentId) {
    this.compartmentId = compartmentId;
  }


  /**
   * Time when the object has been created.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  public IpamsvcAddressBlock ddnsClientUpdate(@javax.annotation.Nullable String ddnsClientUpdate) {
    this.ddnsClientUpdate = ddnsClientUpdate;
    return this;
  }

  /**
   * Controls who does the DDNS updates.  Valid values are: * _client_: DHCP server updates DNS if requested by client. * _server_: DHCP server always updates DNS, overriding an update request from the client, unless the client requests no updates. * _ignore_: DHCP server always updates DNS, even if the client says not to. * _over_client_update_: Same as _server_. DHCP server always updates DNS, overriding an update request from the client, unless the client requests no updates. * _over_no_update_: DHCP server updates DNS even if the client requests that no updates be done. If the client requests to do the update, DHCP server allows it.  Defaults to _client_.
   * @return ddnsClientUpdate
   */
  @javax.annotation.Nullable
  public String getDdnsClientUpdate() {
    return ddnsClientUpdate;
  }

  public void setDdnsClientUpdate(@javax.annotation.Nullable String ddnsClientUpdate) {
    this.ddnsClientUpdate = ddnsClientUpdate;
  }


  public IpamsvcAddressBlock ddnsConflictResolutionMode(@javax.annotation.Nullable String ddnsConflictResolutionMode) {
    this.ddnsConflictResolutionMode = ddnsConflictResolutionMode;
    return this;
  }

  /**
   * The mode used for resolving conflicts while performing DDNS updates.  Valid values are: * _check_with_dhcid_: It includes adding a DHCID record and checking that record via conflict detection as per RFC 4703. * _no_check_with_dhcid_: This will ignore conflict detection but add a DHCID record when creating/updating an entry. * _check_exists_with_dhcid_: This will check if there is an existing DHCID record but does not verify the value of the record matches the update. This will also update the DHCID record for the entry. * _no_check_without_dhcid_: This ignores conflict detection and will not add a DHCID record when creating/updating a DDNS entry.  Defaults to _check_with_dhcid_.
   * @return ddnsConflictResolutionMode
   */
  @javax.annotation.Nullable
  public String getDdnsConflictResolutionMode() {
    return ddnsConflictResolutionMode;
  }

  public void setDdnsConflictResolutionMode(@javax.annotation.Nullable String ddnsConflictResolutionMode) {
    this.ddnsConflictResolutionMode = ddnsConflictResolutionMode;
  }


  public IpamsvcAddressBlock ddnsDomain(@javax.annotation.Nullable String ddnsDomain) {
    this.ddnsDomain = ddnsDomain;
    return this;
  }

  /**
   * The domain suffix for DDNS updates. FQDN, may be empty.  Defaults to empty.
   * @return ddnsDomain
   */
  @javax.annotation.Nullable
  public String getDdnsDomain() {
    return ddnsDomain;
  }

  public void setDdnsDomain(@javax.annotation.Nullable String ddnsDomain) {
    this.ddnsDomain = ddnsDomain;
  }


  public IpamsvcAddressBlock ddnsGenerateName(@javax.annotation.Nullable Boolean ddnsGenerateName) {
    this.ddnsGenerateName = ddnsGenerateName;
    return this;
  }

  /**
   * Indicates if DDNS needs to generate a hostname when not supplied by the client.  Defaults to _false_.
   * @return ddnsGenerateName
   */
  @javax.annotation.Nullable
  public Boolean getDdnsGenerateName() {
    return ddnsGenerateName;
  }

  public void setDdnsGenerateName(@javax.annotation.Nullable Boolean ddnsGenerateName) {
    this.ddnsGenerateName = ddnsGenerateName;
  }


  public IpamsvcAddressBlock ddnsGeneratedPrefix(@javax.annotation.Nullable String ddnsGeneratedPrefix) {
    this.ddnsGeneratedPrefix = ddnsGeneratedPrefix;
    return this;
  }

  /**
   * The prefix used in the generation of an FQDN.  When generating a name, DHCP server will construct the name in the format: [ddns-generated-prefix]-[address-text].[ddns-qualifying-suffix]. where address-text is simply the lease IP address converted to a hyphenated string.  Defaults to \&quot;myhost\&quot;.
   * @return ddnsGeneratedPrefix
   */
  @javax.annotation.Nullable
  public String getDdnsGeneratedPrefix() {
    return ddnsGeneratedPrefix;
  }

  public void setDdnsGeneratedPrefix(@javax.annotation.Nullable String ddnsGeneratedPrefix) {
    this.ddnsGeneratedPrefix = ddnsGeneratedPrefix;
  }


  public IpamsvcAddressBlock ddnsSendUpdates(@javax.annotation.Nullable Boolean ddnsSendUpdates) {
    this.ddnsSendUpdates = ddnsSendUpdates;
    return this;
  }

  /**
   * Determines if DDNS updates are enabled at the address block level. Defaults to _true_.
   * @return ddnsSendUpdates
   */
  @javax.annotation.Nullable
  public Boolean getDdnsSendUpdates() {
    return ddnsSendUpdates;
  }

  public void setDdnsSendUpdates(@javax.annotation.Nullable Boolean ddnsSendUpdates) {
    this.ddnsSendUpdates = ddnsSendUpdates;
  }


  public IpamsvcAddressBlock ddnsTtlPercent(@javax.annotation.Nullable Float ddnsTtlPercent) {
    this.ddnsTtlPercent = ddnsTtlPercent;
    return this;
  }

  /**
   * DDNS TTL value - to be calculated as a simple percentage of the lease&#39;s lifetime, using the parameter&#39;s value as the percentage. It is specified as a percentage (e.g. 25, 75). Defaults to unspecified.
   * @return ddnsTtlPercent
   */
  @javax.annotation.Nullable
  public Float getDdnsTtlPercent() {
    return ddnsTtlPercent;
  }

  public void setDdnsTtlPercent(@javax.annotation.Nullable Float ddnsTtlPercent) {
    this.ddnsTtlPercent = ddnsTtlPercent;
  }


  public IpamsvcAddressBlock ddnsUpdateOnRenew(@javax.annotation.Nullable Boolean ddnsUpdateOnRenew) {
    this.ddnsUpdateOnRenew = ddnsUpdateOnRenew;
    return this;
  }

  /**
   * Instructs the DHCP server to always update the DNS information when a lease is renewed even if its DNS information has not changed.  Defaults to _false_.
   * @return ddnsUpdateOnRenew
   */
  @javax.annotation.Nullable
  public Boolean getDdnsUpdateOnRenew() {
    return ddnsUpdateOnRenew;
  }

  public void setDdnsUpdateOnRenew(@javax.annotation.Nullable Boolean ddnsUpdateOnRenew) {
    this.ddnsUpdateOnRenew = ddnsUpdateOnRenew;
  }


  public IpamsvcAddressBlock ddnsUseConflictResolution(@javax.annotation.Nullable Boolean ddnsUseConflictResolution) {
    this.ddnsUseConflictResolution = ddnsUseConflictResolution;
    return this;
  }

  /**
   * When true, DHCP server will apply conflict resolution, as described in RFC 4703, when attempting to fulfill the update request.  When false, DHCP server will simply attempt to update the DNS entries per the request, regardless of whether or not they conflict with existing entries owned by other DHCP4 clients.  Defaults to _true_.
   * @return ddnsUseConflictResolution
   */
  @javax.annotation.Nullable
  public Boolean getDdnsUseConflictResolution() {
    return ddnsUseConflictResolution;
  }

  public void setDdnsUseConflictResolution(@javax.annotation.Nullable Boolean ddnsUseConflictResolution) {
    this.ddnsUseConflictResolution = ddnsUseConflictResolution;
  }


  /**
   * The ID of the delegation associated with the address block.
   * @return delegation
   */
  @javax.annotation.Nullable
  public String getDelegation() {
    return delegation;
  }



  public IpamsvcAddressBlock dhcpConfig(@javax.annotation.Nullable IpamsvcDHCPConfig dhcpConfig) {
    this.dhcpConfig = dhcpConfig;
    return this;
  }

  /**
   * Get dhcpConfig
   * @return dhcpConfig
   */
  @javax.annotation.Nullable
  public IpamsvcDHCPConfig getDhcpConfig() {
    return dhcpConfig;
  }

  public void setDhcpConfig(@javax.annotation.Nullable IpamsvcDHCPConfig dhcpConfig) {
    this.dhcpConfig = dhcpConfig;
  }


  public IpamsvcAddressBlock dhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
    return this;
  }

  public IpamsvcAddressBlock addDhcpOptionsItem(IpamsvcOptionItem dhcpOptionsItem) {
    if (this.dhcpOptions == null) {
      this.dhcpOptions = new ArrayList<>();
    }
    this.dhcpOptions.add(dhcpOptionsItem);
    return this;
  }

  /**
   * The list of DHCP options for the address block. May be either a specific option or a group of options.
   * @return dhcpOptions
   */
  @javax.annotation.Nullable
  public List<IpamsvcOptionItem> getDhcpOptions() {
    return dhcpOptions;
  }

  public void setDhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
  }


  public IpamsvcAddressBlock dhcpUtilization(@javax.annotation.Nullable IpamsvcDHCPUtilization dhcpUtilization) {
    this.dhcpUtilization = dhcpUtilization;
    return this;
  }

  /**
   * Get dhcpUtilization
   * @return dhcpUtilization
   */
  @javax.annotation.Nullable
  public IpamsvcDHCPUtilization getDhcpUtilization() {
    return dhcpUtilization;
  }

  public void setDhcpUtilization(@javax.annotation.Nullable IpamsvcDHCPUtilization dhcpUtilization) {
    this.dhcpUtilization = dhcpUtilization;
  }


  public IpamsvcAddressBlock discoveryAttrs(@javax.annotation.Nullable Object discoveryAttrs) {
    this.discoveryAttrs = discoveryAttrs;
    return this;
  }

  /**
   * The discovery attributes for this address block in JSON format.
   * @return discoveryAttrs
   */
  @javax.annotation.Nullable
  public Object getDiscoveryAttrs() {
    return discoveryAttrs;
  }

  public void setDiscoveryAttrs(@javax.annotation.Nullable Object discoveryAttrs) {
    this.discoveryAttrs = discoveryAttrs;
  }


  public IpamsvcAddressBlock discoveryMetadata(@javax.annotation.Nullable Object discoveryMetadata) {
    this.discoveryMetadata = discoveryMetadata;
    return this;
  }

  /**
   * The discovery metadata for this address block in JSON format.
   * @return discoveryMetadata
   */
  @javax.annotation.Nullable
  public Object getDiscoveryMetadata() {
    return discoveryMetadata;
  }

  public void setDiscoveryMetadata(@javax.annotation.Nullable Object discoveryMetadata) {
    this.discoveryMetadata = discoveryMetadata;
  }


  public IpamsvcAddressBlock externalKeys(@javax.annotation.Nullable Object externalKeys) {
    this.externalKeys = externalKeys;
    return this;
  }

  /**
   * The external keys (source key) for this address block in JSON format.
   * @return externalKeys
   */
  @javax.annotation.Nullable
  public Object getExternalKeys() {
    return externalKeys;
  }

  public void setExternalKeys(@javax.annotation.Nullable Object externalKeys) {
    this.externalKeys = externalKeys;
  }


  public IpamsvcAddressBlock federatedRealms(@javax.annotation.Nullable List<String> federatedRealms) {
    this.federatedRealms = federatedRealms;
    return this;
  }

  public IpamsvcAddressBlock addFederatedRealmsItem(String federatedRealmsItem) {
    if (this.federatedRealms == null) {
      this.federatedRealms = new ArrayList<>();
    }
    this.federatedRealms.add(federatedRealmsItem);
    return this;
  }

  /**
   * The IDs of the federated realms in which the address block participates.
   * @return federatedRealms
   */
  @javax.annotation.Nullable
  public List<String> getFederatedRealms() {
    return federatedRealms;
  }

  public void setFederatedRealms(@javax.annotation.Nullable List<String> federatedRealms) {
    this.federatedRealms = federatedRealms;
  }


  public IpamsvcAddressBlock headerOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
    return this;
  }

  /**
   * The configuration for header option filename field.
   * @return headerOptionFilename
   */
  @javax.annotation.Nullable
  public String getHeaderOptionFilename() {
    return headerOptionFilename;
  }

  public void setHeaderOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
  }


  public IpamsvcAddressBlock headerOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
    return this;
  }

  /**
   * The configuration for header option server address field.
   * @return headerOptionServerAddress
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerAddress() {
    return headerOptionServerAddress;
  }

  public void setHeaderOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
  }


  public IpamsvcAddressBlock headerOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
    return this;
  }

  /**
   * The configuration for header option server name field.
   * @return headerOptionServerName
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerName() {
    return headerOptionServerName;
  }

  public void setHeaderOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
  }


  public IpamsvcAddressBlock hostnameRewriteChar(@javax.annotation.Nullable String hostnameRewriteChar) {
    this.hostnameRewriteChar = hostnameRewriteChar;
    return this;
  }

  /**
   * The character to replace non-matching characters with, when hostname rewrite is enabled.  Any single ASCII character or no character if the invalid characters should be removed without replacement.  Defaults to \&quot;-\&quot;.
   * @return hostnameRewriteChar
   */
  @javax.annotation.Nullable
  public String getHostnameRewriteChar() {
    return hostnameRewriteChar;
  }

  public void setHostnameRewriteChar(@javax.annotation.Nullable String hostnameRewriteChar) {
    this.hostnameRewriteChar = hostnameRewriteChar;
  }


  public IpamsvcAddressBlock hostnameRewriteEnabled(@javax.annotation.Nullable Boolean hostnameRewriteEnabled) {
    this.hostnameRewriteEnabled = hostnameRewriteEnabled;
    return this;
  }

  /**
   * Indicates if client supplied hostnames will be rewritten prior to DDNS update by replacing every character that does not match _hostname_rewrite_regex_ by _hostname_rewrite_char_.  Defaults to _false_.
   * @return hostnameRewriteEnabled
   */
  @javax.annotation.Nullable
  public Boolean getHostnameRewriteEnabled() {
    return hostnameRewriteEnabled;
  }

  public void setHostnameRewriteEnabled(@javax.annotation.Nullable Boolean hostnameRewriteEnabled) {
    this.hostnameRewriteEnabled = hostnameRewriteEnabled;
  }


  public IpamsvcAddressBlock hostnameRewriteRegex(@javax.annotation.Nullable String hostnameRewriteRegex) {
    this.hostnameRewriteRegex = hostnameRewriteRegex;
    return this;
  }

  /**
   * The regex bracket expression to match valid characters.  Must begin with \&quot;[\&quot; and end with \&quot;]\&quot; and be a compilable POSIX regex.  Defaults to \&quot;[^a-zA-Z0-9_.]\&quot;.
   * @return hostnameRewriteRegex
   */
  @javax.annotation.Nullable
  public String getHostnameRewriteRegex() {
    return hostnameRewriteRegex;
  }

  public void setHostnameRewriteRegex(@javax.annotation.Nullable String hostnameRewriteRegex) {
    this.hostnameRewriteRegex = hostnameRewriteRegex;
  }


  /**
   * The resource identifier.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public IpamsvcAddressBlock inheritanceParent(@javax.annotation.Nullable String inheritanceParent) {
    this.inheritanceParent = inheritanceParent;
    return this;
  }

  /**
   * The resource identifier.
   * @return inheritanceParent
   */
  @javax.annotation.Nullable
  public String getInheritanceParent() {
    return inheritanceParent;
  }

  public void setInheritanceParent(@javax.annotation.Nullable String inheritanceParent) {
    this.inheritanceParent = inheritanceParent;
  }


  public IpamsvcAddressBlock inheritanceSources(@javax.annotation.Nullable IpamsvcDHCPInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
    return this;
  }

  /**
   * Get inheritanceSources
   * @return inheritanceSources
   */
  @javax.annotation.Nullable
  public IpamsvcDHCPInheritance getInheritanceSources() {
    return inheritanceSources;
  }

  public void setInheritanceSources(@javax.annotation.Nullable IpamsvcDHCPInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
  }


  public IpamsvcAddressBlock name(@javax.annotation.Nullable String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the address block. May contain 1 to 256 characters. Can include UTF-8.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nullable String name) {
    this.name = name;
  }


  public IpamsvcAddressBlock parent(@javax.annotation.Nullable String parent) {
    this.parent = parent;
    return this;
  }

  /**
   * The resource identifier.
   * @return parent
   */
  @javax.annotation.Nullable
  public String getParent() {
    return parent;
  }

  public void setParent(@javax.annotation.Nullable String parent) {
    this.parent = parent;
  }


  /**
   * The type of protocol of address block (_ip4_ or _ip6_).
   * @return protocol
   */
  @javax.annotation.Nullable
  public String getProtocol() {
    return protocol;
  }



  public IpamsvcAddressBlock space(@javax.annotation.Nonnull String space) {
    this.space = space;
    return this;
  }

  /**
   * The resource identifier.
   * @return space
   */
  @javax.annotation.Nonnull
  public String getSpace() {
    return space;
  }

  public void setSpace(@javax.annotation.Nonnull String space) {
    this.space = space;
  }


  public IpamsvcAddressBlock tags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
    return this;
  }

  /**
   * The tags for the address block in JSON format.
   * @return tags
   */
  @javax.annotation.Nullable
  public Object getTags() {
    return tags;
  }

  public void setTags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
  }


  public IpamsvcAddressBlock threshold(@javax.annotation.Nullable IpamsvcUtilizationThreshold threshold) {
    this.threshold = threshold;
    return this;
  }

  /**
   * Get threshold
   * @return threshold
   */
  @javax.annotation.Nullable
  public IpamsvcUtilizationThreshold getThreshold() {
    return threshold;
  }

  public void setThreshold(@javax.annotation.Nullable IpamsvcUtilizationThreshold threshold) {
    this.threshold = threshold;
  }


  /**
   * Time when the object has been updated. Equals to _created_at_ if not updated after creation.
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }



  /**
   * The usage is a combination of indicators, each tracking a specific associated use. Listed below are usage indicators with their meaning:  usage indicator        | description  ---------------------- | --------------------------------  _IPAM_                 |  AddressBlock is managed in BloxOne DDI.  _DISCOVERED_           |  AddressBlock is discovered by some network discovery probe like Network Insight or NetMRI in NIOS.
   * @return usage
   */
  @javax.annotation.Nullable
  public List<String> getUsage() {
    return usage;
  }



  public IpamsvcAddressBlock utilization(@javax.annotation.Nullable IpamsvcUtilization utilization) {
    this.utilization = utilization;
    return this;
  }

  /**
   * Get utilization
   * @return utilization
   */
  @javax.annotation.Nullable
  public IpamsvcUtilization getUtilization() {
    return utilization;
  }

  public void setUtilization(@javax.annotation.Nullable IpamsvcUtilization utilization) {
    this.utilization = utilization;
  }


  public IpamsvcAddressBlock utilizationV6(@javax.annotation.Nullable IpamsvcUtilizationV6 utilizationV6) {
    this.utilizationV6 = utilizationV6;
    return this;
  }

  /**
   * Get utilizationV6
   * @return utilizationV6
   */
  @javax.annotation.Nullable
  public IpamsvcUtilizationV6 getUtilizationV6() {
    return utilizationV6;
  }

  public void setUtilizationV6(@javax.annotation.Nullable IpamsvcUtilizationV6 utilizationV6) {
    this.utilizationV6 = utilizationV6;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IpamsvcAddressBlock ipamsvcAddressBlock = (IpamsvcAddressBlock) o;
    return Objects.equals(this.address, ipamsvcAddressBlock.address) &&
        Objects.equals(this.asmConfig, ipamsvcAddressBlock.asmConfig) &&
        Objects.equals(this.asmScopeFlag, ipamsvcAddressBlock.asmScopeFlag) &&
        Objects.equals(this.cidr, ipamsvcAddressBlock.cidr) &&
        Objects.equals(this.comment, ipamsvcAddressBlock.comment) &&
        Objects.equals(this.compartmentId, ipamsvcAddressBlock.compartmentId) &&
        Objects.equals(this.createdAt, ipamsvcAddressBlock.createdAt) &&
        Objects.equals(this.ddnsClientUpdate, ipamsvcAddressBlock.ddnsClientUpdate) &&
        Objects.equals(this.ddnsConflictResolutionMode, ipamsvcAddressBlock.ddnsConflictResolutionMode) &&
        Objects.equals(this.ddnsDomain, ipamsvcAddressBlock.ddnsDomain) &&
        Objects.equals(this.ddnsGenerateName, ipamsvcAddressBlock.ddnsGenerateName) &&
        Objects.equals(this.ddnsGeneratedPrefix, ipamsvcAddressBlock.ddnsGeneratedPrefix) &&
        Objects.equals(this.ddnsSendUpdates, ipamsvcAddressBlock.ddnsSendUpdates) &&
        Objects.equals(this.ddnsTtlPercent, ipamsvcAddressBlock.ddnsTtlPercent) &&
        Objects.equals(this.ddnsUpdateOnRenew, ipamsvcAddressBlock.ddnsUpdateOnRenew) &&
        Objects.equals(this.ddnsUseConflictResolution, ipamsvcAddressBlock.ddnsUseConflictResolution) &&
        Objects.equals(this.delegation, ipamsvcAddressBlock.delegation) &&
        Objects.equals(this.dhcpConfig, ipamsvcAddressBlock.dhcpConfig) &&
        Objects.equals(this.dhcpOptions, ipamsvcAddressBlock.dhcpOptions) &&
        Objects.equals(this.dhcpUtilization, ipamsvcAddressBlock.dhcpUtilization) &&
        Objects.equals(this.discoveryAttrs, ipamsvcAddressBlock.discoveryAttrs) &&
        Objects.equals(this.discoveryMetadata, ipamsvcAddressBlock.discoveryMetadata) &&
        Objects.equals(this.externalKeys, ipamsvcAddressBlock.externalKeys) &&
        Objects.equals(this.federatedRealms, ipamsvcAddressBlock.federatedRealms) &&
        Objects.equals(this.headerOptionFilename, ipamsvcAddressBlock.headerOptionFilename) &&
        Objects.equals(this.headerOptionServerAddress, ipamsvcAddressBlock.headerOptionServerAddress) &&
        Objects.equals(this.headerOptionServerName, ipamsvcAddressBlock.headerOptionServerName) &&
        Objects.equals(this.hostnameRewriteChar, ipamsvcAddressBlock.hostnameRewriteChar) &&
        Objects.equals(this.hostnameRewriteEnabled, ipamsvcAddressBlock.hostnameRewriteEnabled) &&
        Objects.equals(this.hostnameRewriteRegex, ipamsvcAddressBlock.hostnameRewriteRegex) &&
        Objects.equals(this.id, ipamsvcAddressBlock.id) &&
        Objects.equals(this.inheritanceParent, ipamsvcAddressBlock.inheritanceParent) &&
        Objects.equals(this.inheritanceSources, ipamsvcAddressBlock.inheritanceSources) &&
        Objects.equals(this.name, ipamsvcAddressBlock.name) &&
        Objects.equals(this.parent, ipamsvcAddressBlock.parent) &&
        Objects.equals(this.protocol, ipamsvcAddressBlock.protocol) &&
        Objects.equals(this.space, ipamsvcAddressBlock.space) &&
        Objects.equals(this.tags, ipamsvcAddressBlock.tags) &&
        Objects.equals(this.threshold, ipamsvcAddressBlock.threshold) &&
        Objects.equals(this.updatedAt, ipamsvcAddressBlock.updatedAt) &&
        Objects.equals(this.usage, ipamsvcAddressBlock.usage) &&
        Objects.equals(this.utilization, ipamsvcAddressBlock.utilization) &&
        Objects.equals(this.utilizationV6, ipamsvcAddressBlock.utilizationV6);
  }

  @Override
  public int hashCode() {
    return Objects.hash(address, asmConfig, asmScopeFlag, cidr, comment, compartmentId, createdAt, ddnsClientUpdate, ddnsConflictResolutionMode, ddnsDomain, ddnsGenerateName, ddnsGeneratedPrefix, ddnsSendUpdates, ddnsTtlPercent, ddnsUpdateOnRenew, ddnsUseConflictResolution, delegation, dhcpConfig, dhcpOptions, dhcpUtilization, discoveryAttrs, discoveryMetadata, externalKeys, federatedRealms, headerOptionFilename, headerOptionServerAddress, headerOptionServerName, hostnameRewriteChar, hostnameRewriteEnabled, hostnameRewriteRegex, id, inheritanceParent, inheritanceSources, name, parent, protocol, space, tags, threshold, updatedAt, usage, utilization, utilizationV6);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IpamsvcAddressBlock {\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    asmConfig: ").append(toIndentedString(asmConfig)).append("\n");
    sb.append("    asmScopeFlag: ").append(toIndentedString(asmScopeFlag)).append("\n");
    sb.append("    cidr: ").append(toIndentedString(cidr)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    compartmentId: ").append(toIndentedString(compartmentId)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    ddnsClientUpdate: ").append(toIndentedString(ddnsClientUpdate)).append("\n");
    sb.append("    ddnsConflictResolutionMode: ").append(toIndentedString(ddnsConflictResolutionMode)).append("\n");
    sb.append("    ddnsDomain: ").append(toIndentedString(ddnsDomain)).append("\n");
    sb.append("    ddnsGenerateName: ").append(toIndentedString(ddnsGenerateName)).append("\n");
    sb.append("    ddnsGeneratedPrefix: ").append(toIndentedString(ddnsGeneratedPrefix)).append("\n");
    sb.append("    ddnsSendUpdates: ").append(toIndentedString(ddnsSendUpdates)).append("\n");
    sb.append("    ddnsTtlPercent: ").append(toIndentedString(ddnsTtlPercent)).append("\n");
    sb.append("    ddnsUpdateOnRenew: ").append(toIndentedString(ddnsUpdateOnRenew)).append("\n");
    sb.append("    ddnsUseConflictResolution: ").append(toIndentedString(ddnsUseConflictResolution)).append("\n");
    sb.append("    delegation: ").append(toIndentedString(delegation)).append("\n");
    sb.append("    dhcpConfig: ").append(toIndentedString(dhcpConfig)).append("\n");
    sb.append("    dhcpOptions: ").append(toIndentedString(dhcpOptions)).append("\n");
    sb.append("    dhcpUtilization: ").append(toIndentedString(dhcpUtilization)).append("\n");
    sb.append("    discoveryAttrs: ").append(toIndentedString(discoveryAttrs)).append("\n");
    sb.append("    discoveryMetadata: ").append(toIndentedString(discoveryMetadata)).append("\n");
    sb.append("    externalKeys: ").append(toIndentedString(externalKeys)).append("\n");
    sb.append("    federatedRealms: ").append(toIndentedString(federatedRealms)).append("\n");
    sb.append("    headerOptionFilename: ").append(toIndentedString(headerOptionFilename)).append("\n");
    sb.append("    headerOptionServerAddress: ").append(toIndentedString(headerOptionServerAddress)).append("\n");
    sb.append("    headerOptionServerName: ").append(toIndentedString(headerOptionServerName)).append("\n");
    sb.append("    hostnameRewriteChar: ").append(toIndentedString(hostnameRewriteChar)).append("\n");
    sb.append("    hostnameRewriteEnabled: ").append(toIndentedString(hostnameRewriteEnabled)).append("\n");
    sb.append("    hostnameRewriteRegex: ").append(toIndentedString(hostnameRewriteRegex)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    inheritanceParent: ").append(toIndentedString(inheritanceParent)).append("\n");
    sb.append("    inheritanceSources: ").append(toIndentedString(inheritanceSources)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    parent: ").append(toIndentedString(parent)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    space: ").append(toIndentedString(space)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    threshold: ").append(toIndentedString(threshold)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    usage: ").append(toIndentedString(usage)).append("\n");
    sb.append("    utilization: ").append(toIndentedString(utilization)).append("\n");
    sb.append("    utilizationV6: ").append(toIndentedString(utilizationV6)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("address");
    openapiFields.add("asm_config");
    openapiFields.add("asm_scope_flag");
    openapiFields.add("cidr");
    openapiFields.add("comment");
    openapiFields.add("compartment_id");
    openapiFields.add("created_at");
    openapiFields.add("ddns_client_update");
    openapiFields.add("ddns_conflict_resolution_mode");
    openapiFields.add("ddns_domain");
    openapiFields.add("ddns_generate_name");
    openapiFields.add("ddns_generated_prefix");
    openapiFields.add("ddns_send_updates");
    openapiFields.add("ddns_ttl_percent");
    openapiFields.add("ddns_update_on_renew");
    openapiFields.add("ddns_use_conflict_resolution");
    openapiFields.add("delegation");
    openapiFields.add("dhcp_config");
    openapiFields.add("dhcp_options");
    openapiFields.add("dhcp_utilization");
    openapiFields.add("discovery_attrs");
    openapiFields.add("discovery_metadata");
    openapiFields.add("external_keys");
    openapiFields.add("federated_realms");
    openapiFields.add("header_option_filename");
    openapiFields.add("header_option_server_address");
    openapiFields.add("header_option_server_name");
    openapiFields.add("hostname_rewrite_char");
    openapiFields.add("hostname_rewrite_enabled");
    openapiFields.add("hostname_rewrite_regex");
    openapiFields.add("id");
    openapiFields.add("inheritance_parent");
    openapiFields.add("inheritance_sources");
    openapiFields.add("name");
    openapiFields.add("parent");
    openapiFields.add("protocol");
    openapiFields.add("space");
    openapiFields.add("tags");
    openapiFields.add("threshold");
    openapiFields.add("updated_at");
    openapiFields.add("usage");
    openapiFields.add("utilization");
    openapiFields.add("utilization_v6");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("address");
    openapiRequiredFields.add("space");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IpamsvcAddressBlock
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IpamsvcAddressBlock.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IpamsvcAddressBlock is not found in the empty JSON string", IpamsvcAddressBlock.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IpamsvcAddressBlock.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IpamsvcAddressBlock` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : IpamsvcAddressBlock.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("address").toString()));
      }
      // validate the optional field `asm_config`
      if (jsonObj.get("asm_config") != null && !jsonObj.get("asm_config").isJsonNull()) {
        IpamsvcASMConfig.validateJsonElement(jsonObj.get("asm_config"));
      }
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if ((jsonObj.get("compartment_id") != null && !jsonObj.get("compartment_id").isJsonNull()) && !jsonObj.get("compartment_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `compartment_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("compartment_id").toString()));
      }
      if ((jsonObj.get("ddns_client_update") != null && !jsonObj.get("ddns_client_update").isJsonNull()) && !jsonObj.get("ddns_client_update").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_client_update` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_client_update").toString()));
      }
      if ((jsonObj.get("ddns_conflict_resolution_mode") != null && !jsonObj.get("ddns_conflict_resolution_mode").isJsonNull()) && !jsonObj.get("ddns_conflict_resolution_mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_conflict_resolution_mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_conflict_resolution_mode").toString()));
      }
      if ((jsonObj.get("ddns_domain") != null && !jsonObj.get("ddns_domain").isJsonNull()) && !jsonObj.get("ddns_domain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_domain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_domain").toString()));
      }
      if ((jsonObj.get("ddns_generated_prefix") != null && !jsonObj.get("ddns_generated_prefix").isJsonNull()) && !jsonObj.get("ddns_generated_prefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_generated_prefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_generated_prefix").toString()));
      }
      if ((jsonObj.get("delegation") != null && !jsonObj.get("delegation").isJsonNull()) && !jsonObj.get("delegation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `delegation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("delegation").toString()));
      }
      // validate the optional field `dhcp_config`
      if (jsonObj.get("dhcp_config") != null && !jsonObj.get("dhcp_config").isJsonNull()) {
        IpamsvcDHCPConfig.validateJsonElement(jsonObj.get("dhcp_config"));
      }
      if (jsonObj.get("dhcp_options") != null && !jsonObj.get("dhcp_options").isJsonNull()) {
        JsonArray jsonArraydhcpOptions = jsonObj.getAsJsonArray("dhcp_options");
        if (jsonArraydhcpOptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dhcp_options").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dhcp_options` to be an array in the JSON string but got `%s`", jsonObj.get("dhcp_options").toString()));
          }

          // validate the optional field `dhcp_options` (array)
          for (int i = 0; i < jsonArraydhcpOptions.size(); i++) {
            IpamsvcOptionItem.validateJsonElement(jsonArraydhcpOptions.get(i));
          };
        }
      }
      // validate the optional field `dhcp_utilization`
      if (jsonObj.get("dhcp_utilization") != null && !jsonObj.get("dhcp_utilization").isJsonNull()) {
        IpamsvcDHCPUtilization.validateJsonElement(jsonObj.get("dhcp_utilization"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("federated_realms") != null && !jsonObj.get("federated_realms").isJsonNull() && !jsonObj.get("federated_realms").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `federated_realms` to be an array in the JSON string but got `%s`", jsonObj.get("federated_realms").toString()));
      }
      if ((jsonObj.get("header_option_filename") != null && !jsonObj.get("header_option_filename").isJsonNull()) && !jsonObj.get("header_option_filename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_filename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_filename").toString()));
      }
      if ((jsonObj.get("header_option_server_address") != null && !jsonObj.get("header_option_server_address").isJsonNull()) && !jsonObj.get("header_option_server_address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_address").toString()));
      }
      if ((jsonObj.get("header_option_server_name") != null && !jsonObj.get("header_option_server_name").isJsonNull()) && !jsonObj.get("header_option_server_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_name").toString()));
      }
      if ((jsonObj.get("hostname_rewrite_char") != null && !jsonObj.get("hostname_rewrite_char").isJsonNull()) && !jsonObj.get("hostname_rewrite_char").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname_rewrite_char` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname_rewrite_char").toString()));
      }
      if ((jsonObj.get("hostname_rewrite_regex") != null && !jsonObj.get("hostname_rewrite_regex").isJsonNull()) && !jsonObj.get("hostname_rewrite_regex").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname_rewrite_regex` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname_rewrite_regex").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("inheritance_parent") != null && !jsonObj.get("inheritance_parent").isJsonNull()) && !jsonObj.get("inheritance_parent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `inheritance_parent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("inheritance_parent").toString()));
      }
      // validate the optional field `inheritance_sources`
      if (jsonObj.get("inheritance_sources") != null && !jsonObj.get("inheritance_sources").isJsonNull()) {
        IpamsvcDHCPInheritance.validateJsonElement(jsonObj.get("inheritance_sources"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("parent") != null && !jsonObj.get("parent").isJsonNull()) && !jsonObj.get("parent").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `parent` to be a primitive type in the JSON string but got `%s`", jsonObj.get("parent").toString()));
      }
      if ((jsonObj.get("protocol") != null && !jsonObj.get("protocol").isJsonNull()) && !jsonObj.get("protocol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `protocol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("protocol").toString()));
      }
      if (!jsonObj.get("space").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `space` to be a primitive type in the JSON string but got `%s`", jsonObj.get("space").toString()));
      }
      // validate the optional field `threshold`
      if (jsonObj.get("threshold") != null && !jsonObj.get("threshold").isJsonNull()) {
        IpamsvcUtilizationThreshold.validateJsonElement(jsonObj.get("threshold"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("usage") != null && !jsonObj.get("usage").isJsonNull() && !jsonObj.get("usage").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `usage` to be an array in the JSON string but got `%s`", jsonObj.get("usage").toString()));
      }
      // validate the optional field `utilization`
      if (jsonObj.get("utilization") != null && !jsonObj.get("utilization").isJsonNull()) {
        IpamsvcUtilization.validateJsonElement(jsonObj.get("utilization"));
      }
      // validate the optional field `utilization_v6`
      if (jsonObj.get("utilization_v6") != null && !jsonObj.get("utilization_v6").isJsonNull()) {
        IpamsvcUtilizationV6.validateJsonElement(jsonObj.get("utilization_v6"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IpamsvcAddressBlock.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IpamsvcAddressBlock' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IpamsvcAddressBlock> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IpamsvcAddressBlock.class));

       return (TypeAdapter<T>) new TypeAdapter<IpamsvcAddressBlock>() {
           @Override
           public void write(JsonWriter out, IpamsvcAddressBlock value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IpamsvcAddressBlock read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IpamsvcAddressBlock given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IpamsvcAddressBlock
   * @throws IOException if the JSON string is invalid with respect to IpamsvcAddressBlock
   */
  public static IpamsvcAddressBlock fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IpamsvcAddressBlock.class);
  }

  /**
   * Convert an instance of IpamsvcAddressBlock to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

