/*
 * IP Address Management API
 * The IPAM/DHCP Application is a BloxOne DDI service providing IP address management and DHCP protocol features. The IPAM component provides visibility into and provisioning tools to manage networking spaces, monitoring and reporting of entire IP address infrastructures, and integration with DNS and DHCP protocols. The DHCP component provides DHCP protocol configuration service with on-prem host serving DHCP protocol. It is part of the full-featured, DDI cloud solution that enables customers to deploy large numbers of protocol servers to deliver DNS and DHCP throughout their enterprise network.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The __ASM__ object is a synthetic object representing the suggestions from the Automated Scope Management suggestion engine for expanding subnet or range.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:31.429972+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class IpamsvcASM {
  public static final String SERIALIZED_NAME_BACK_END = "back_end";
  @SerializedName(SERIALIZED_NAME_BACK_END)
  @javax.annotation.Nullable
  private String backEnd;

  public static final String SERIALIZED_NAME_BACK_START = "back_start";
  @SerializedName(SERIALIZED_NAME_BACK_START)
  @javax.annotation.Nullable
  private String backStart;

  public static final String SERIALIZED_NAME_BOTH_END = "both_end";
  @SerializedName(SERIALIZED_NAME_BOTH_END)
  @javax.annotation.Nullable
  private String bothEnd;

  public static final String SERIALIZED_NAME_BOTH_START = "both_start";
  @SerializedName(SERIALIZED_NAME_BOTH_START)
  @javax.annotation.Nullable
  private String bothStart;

  public static final String SERIALIZED_NAME_FRONT_END = "front_end";
  @SerializedName(SERIALIZED_NAME_FRONT_END)
  @javax.annotation.Nullable
  private String frontEnd;

  public static final String SERIALIZED_NAME_FRONT_START = "front_start";
  @SerializedName(SERIALIZED_NAME_FRONT_START)
  @javax.annotation.Nullable
  private String frontStart;

  public static final String SERIALIZED_NAME_GROWTH = "growth";
  @SerializedName(SERIALIZED_NAME_GROWTH)
  @javax.annotation.Nullable
  private Integer growth;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_LOOKAHEAD = "lookahead";
  @SerializedName(SERIALIZED_NAME_LOOKAHEAD)
  @javax.annotation.Nullable
  private Integer lookahead;

  public static final String SERIALIZED_NAME_RANGE_END = "range_end";
  @SerializedName(SERIALIZED_NAME_RANGE_END)
  @javax.annotation.Nullable
  private String rangeEnd;

  public static final String SERIALIZED_NAME_RANGE_ID = "range_id";
  @SerializedName(SERIALIZED_NAME_RANGE_ID)
  @javax.annotation.Nullable
  private String rangeId;

  public static final String SERIALIZED_NAME_RANGE_START = "range_start";
  @SerializedName(SERIALIZED_NAME_RANGE_START)
  @javax.annotation.Nullable
  private String rangeStart;

  public static final String SERIALIZED_NAME_SUBNET_ADDRESS = "subnet_address";
  @SerializedName(SERIALIZED_NAME_SUBNET_ADDRESS)
  @javax.annotation.Nullable
  private String subnetAddress;

  public static final String SERIALIZED_NAME_SUBNET_CIDR = "subnet_cidr";
  @SerializedName(SERIALIZED_NAME_SUBNET_CIDR)
  @javax.annotation.Nullable
  private Long subnetCidr;

  public static final String SERIALIZED_NAME_SUBNET_DIRECTION = "subnet_direction";
  @SerializedName(SERIALIZED_NAME_SUBNET_DIRECTION)
  @javax.annotation.Nullable
  private String subnetDirection;

  public static final String SERIALIZED_NAME_SUBNET_ID = "subnet_id";
  @SerializedName(SERIALIZED_NAME_SUBNET_ID)
  @javax.annotation.Nonnull
  private String subnetId;

  public static final String SERIALIZED_NAME_SUBNET_RANGE = "subnet_range";
  @SerializedName(SERIALIZED_NAME_SUBNET_RANGE)
  @javax.annotation.Nullable
  private String subnetRange;

  public static final String SERIALIZED_NAME_SUBNET_RANGE_END = "subnet_range_end";
  @SerializedName(SERIALIZED_NAME_SUBNET_RANGE_END)
  @javax.annotation.Nullable
  private String subnetRangeEnd;

  public static final String SERIALIZED_NAME_SUBNET_RANGE_START = "subnet_range_start";
  @SerializedName(SERIALIZED_NAME_SUBNET_RANGE_START)
  @javax.annotation.Nullable
  private String subnetRangeStart;

  public static final String SERIALIZED_NAME_SUPPRESS = "suppress";
  @SerializedName(SERIALIZED_NAME_SUPPRESS)
  @javax.annotation.Nullable
  private String suppress;

  public static final String SERIALIZED_NAME_SUPPRESS_TIME = "suppress_time";
  @SerializedName(SERIALIZED_NAME_SUPPRESS_TIME)
  @javax.annotation.Nullable
  private Long suppressTime;

  public static final String SERIALIZED_NAME_THRESHOLD_UTILIZATION = "threshold_utilization";
  @SerializedName(SERIALIZED_NAME_THRESHOLD_UTILIZATION)
  @javax.annotation.Nullable
  private Long thresholdUtilization;

  public static final String SERIALIZED_NAME_UPDATE = "update";
  @SerializedName(SERIALIZED_NAME_UPDATE)
  @javax.annotation.Nullable
  private String update;

  public static final String SERIALIZED_NAME_UTILIZATION = "utilization";
  @SerializedName(SERIALIZED_NAME_UTILIZATION)
  @javax.annotation.Nullable
  private Long utilization;

  public IpamsvcASM() {
  }

  public IpamsvcASM(
     String backEnd, 
     String backStart, 
     String bothEnd, 
     String bothStart, 
     String frontEnd, 
     String frontStart, 
     Integer growth, 
     String id, 
     Integer lookahead, 
     String subnetAddress, 
     Long subnetCidr, 
     String subnetDirection, 
     String subnetRangeEnd, 
     String subnetRangeStart, 
     Long thresholdUtilization, 
     Long utilization
  ) {
    this();
    this.backEnd = backEnd;
    this.backStart = backStart;
    this.bothEnd = bothEnd;
    this.bothStart = bothStart;
    this.frontEnd = frontEnd;
    this.frontStart = frontStart;
    this.growth = growth;
    this.id = id;
    this.lookahead = lookahead;
    this.subnetAddress = subnetAddress;
    this.subnetCidr = subnetCidr;
    this.subnetDirection = subnetDirection;
    this.subnetRangeEnd = subnetRangeEnd;
    this.subnetRangeStart = subnetRangeStart;
    this.thresholdUtilization = thresholdUtilization;
    this.utilization = utilization;
  }

  /**
   * The end IP address when adding to the back.
   * @return backEnd
   */
  @javax.annotation.Nullable
  public String getBackEnd() {
    return backEnd;
  }



  /**
   * The start IP address when adding to the back.
   * @return backStart
   */
  @javax.annotation.Nullable
  public String getBackStart() {
    return backStart;
  }



  /**
   * The end IP address when adding to the back.
   * @return bothEnd
   */
  @javax.annotation.Nullable
  public String getBothEnd() {
    return bothEnd;
  }



  /**
   * The start IP address when adding to both front and back.
   * @return bothStart
   */
  @javax.annotation.Nullable
  public String getBothStart() {
    return bothStart;
  }



  /**
   * The end IP address when adding to the front.
   * @return frontEnd
   */
  @javax.annotation.Nullable
  public String getFrontEnd() {
    return frontEnd;
  }



  /**
   * The start IP address when adding to the front.
   * @return frontStart
   */
  @javax.annotation.Nullable
  public String getFrontStart() {
    return frontStart;
  }



  /**
   * Calculated number of addresses to grow range; its value is determined by asm_config growth factor, type, and min_unused after the expansion.
   * @return growth
   */
  @javax.annotation.Nullable
  public Integer getGrowth() {
    return growth;
  }



  /**
   * The resource identifier.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  /**
   * Either the value from the ASM configuration or -1 if the estimate is that utilization will not exceed the threshold.
   * @return lookahead
   */
  @javax.annotation.Nullable
  public Integer getLookahead() {
    return lookahead;
  }



  public IpamsvcASM rangeEnd(@javax.annotation.Nullable String rangeEnd) {
    this.rangeEnd = rangeEnd;
    return this;
  }

  /**
   * The end IP address of the range.
   * @return rangeEnd
   */
  @javax.annotation.Nullable
  public String getRangeEnd() {
    return rangeEnd;
  }

  public void setRangeEnd(@javax.annotation.Nullable String rangeEnd) {
    this.rangeEnd = rangeEnd;
  }


  public IpamsvcASM rangeId(@javax.annotation.Nullable String rangeId) {
    this.rangeId = rangeId;
    return this;
  }

  /**
   * The resource identifier.
   * @return rangeId
   */
  @javax.annotation.Nullable
  public String getRangeId() {
    return rangeId;
  }

  public void setRangeId(@javax.annotation.Nullable String rangeId) {
    this.rangeId = rangeId;
  }


  public IpamsvcASM rangeStart(@javax.annotation.Nullable String rangeStart) {
    this.rangeStart = rangeStart;
    return this;
  }

  /**
   * The start IP address of the range.
   * @return rangeStart
   */
  @javax.annotation.Nullable
  public String getRangeStart() {
    return rangeStart;
  }

  public void setRangeStart(@javax.annotation.Nullable String rangeStart) {
    this.rangeStart = rangeStart;
  }


  /**
   * The suggested subnet expansion.
   * @return subnetAddress
   */
  @javax.annotation.Nullable
  public String getSubnetAddress() {
    return subnetAddress;
  }



  /**
   * The CIDR of the subnet.
   * @return subnetCidr
   */
  @javax.annotation.Nullable
  public Long getSubnetCidr() {
    return subnetCidr;
  }



  /**
   * Indicates where the subnet may expand. As the subnet can only be expanded by one bit at a time, it can only grow in one of the two directions. It is set to _none_ if the subnet can&#39;t be expanded.  Valid values are: * _front_ * _back_ * _none_
   * @return subnetDirection
   */
  @javax.annotation.Nullable
  public String getSubnetDirection() {
    return subnetDirection;
  }



  public IpamsvcASM subnetId(@javax.annotation.Nonnull String subnetId) {
    this.subnetId = subnetId;
    return this;
  }

  /**
   * The resource identifier.
   * @return subnetId
   */
  @javax.annotation.Nonnull
  public String getSubnetId() {
    return subnetId;
  }

  public void setSubnetId(@javax.annotation.Nonnull String subnetId) {
    this.subnetId = subnetId;
  }


  public IpamsvcASM subnetRange(@javax.annotation.Nullable String subnetRange) {
    this.subnetRange = subnetRange;
    return this;
  }

  /**
   * The resource identifier.
   * @return subnetRange
   */
  @javax.annotation.Nullable
  public String getSubnetRange() {
    return subnetRange;
  }

  public void setSubnetRange(@javax.annotation.Nullable String subnetRange) {
    this.subnetRange = subnetRange;
  }


  /**
   * The suggested new range end in expanded subnet.
   * @return subnetRangeEnd
   */
  @javax.annotation.Nullable
  public String getSubnetRangeEnd() {
    return subnetRangeEnd;
  }



  /**
   * The suggested new range start in expanded subnet.
   * @return subnetRangeStart
   */
  @javax.annotation.Nullable
  public String getSubnetRangeStart() {
    return subnetRangeStart;
  }



  public IpamsvcASM suppress(@javax.annotation.Nullable String suppress) {
    this.suppress = suppress;
    return this;
  }

  /**
   * Indicates if future notifications for this subnet should be suppressed.  Valid values are: * _no_ * _time_ * _permanent_  If set to _permanent_ notifications are suppressed until the administrator modifies the configuration for the subnet. If set to _time_ notifications are suppressed until the specified time. Defaults to _no_.
   * @return suppress
   */
  @javax.annotation.Nullable
  public String getSuppress() {
    return suppress;
  }

  public void setSuppress(@javax.annotation.Nullable String suppress) {
    this.suppress = suppress;
  }


  public IpamsvcASM suppressTime(@javax.annotation.Nullable Long suppressTime) {
    this.suppressTime = suppressTime;
    return this;
  }

  /**
   * The time duration in days to suppress the notifications for this subnet.
   * @return suppressTime
   */
  @javax.annotation.Nullable
  public Long getSuppressTime() {
    return suppressTime;
  }

  public void setSuppressTime(@javax.annotation.Nullable Long suppressTime) {
    this.suppressTime = suppressTime;
  }


  /**
   * The utilization threshold as per ASM configuration.
   * @return thresholdUtilization
   */
  @javax.annotation.Nullable
  public Long getThresholdUtilization() {
    return thresholdUtilization;
  }



  public IpamsvcASM update(@javax.annotation.Nullable String update) {
    this.update = update;
    return this;
  }

  /**
   * The object to update.  Valid values are: * _range_ * _subnet_ * _none_
   * @return update
   */
  @javax.annotation.Nullable
  public String getUpdate() {
    return update;
  }

  public void setUpdate(@javax.annotation.Nullable String update) {
    this.update = update;
  }


  /**
   * The utilization of DHCP addresses in the subnet.
   * @return utilization
   */
  @javax.annotation.Nullable
  public Long getUtilization() {
    return utilization;
  }




  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IpamsvcASM ipamsvcASM = (IpamsvcASM) o;
    return Objects.equals(this.backEnd, ipamsvcASM.backEnd) &&
        Objects.equals(this.backStart, ipamsvcASM.backStart) &&
        Objects.equals(this.bothEnd, ipamsvcASM.bothEnd) &&
        Objects.equals(this.bothStart, ipamsvcASM.bothStart) &&
        Objects.equals(this.frontEnd, ipamsvcASM.frontEnd) &&
        Objects.equals(this.frontStart, ipamsvcASM.frontStart) &&
        Objects.equals(this.growth, ipamsvcASM.growth) &&
        Objects.equals(this.id, ipamsvcASM.id) &&
        Objects.equals(this.lookahead, ipamsvcASM.lookahead) &&
        Objects.equals(this.rangeEnd, ipamsvcASM.rangeEnd) &&
        Objects.equals(this.rangeId, ipamsvcASM.rangeId) &&
        Objects.equals(this.rangeStart, ipamsvcASM.rangeStart) &&
        Objects.equals(this.subnetAddress, ipamsvcASM.subnetAddress) &&
        Objects.equals(this.subnetCidr, ipamsvcASM.subnetCidr) &&
        Objects.equals(this.subnetDirection, ipamsvcASM.subnetDirection) &&
        Objects.equals(this.subnetId, ipamsvcASM.subnetId) &&
        Objects.equals(this.subnetRange, ipamsvcASM.subnetRange) &&
        Objects.equals(this.subnetRangeEnd, ipamsvcASM.subnetRangeEnd) &&
        Objects.equals(this.subnetRangeStart, ipamsvcASM.subnetRangeStart) &&
        Objects.equals(this.suppress, ipamsvcASM.suppress) &&
        Objects.equals(this.suppressTime, ipamsvcASM.suppressTime) &&
        Objects.equals(this.thresholdUtilization, ipamsvcASM.thresholdUtilization) &&
        Objects.equals(this.update, ipamsvcASM.update) &&
        Objects.equals(this.utilization, ipamsvcASM.utilization);
  }

  @Override
  public int hashCode() {
    return Objects.hash(backEnd, backStart, bothEnd, bothStart, frontEnd, frontStart, growth, id, lookahead, rangeEnd, rangeId, rangeStart, subnetAddress, subnetCidr, subnetDirection, subnetId, subnetRange, subnetRangeEnd, subnetRangeStart, suppress, suppressTime, thresholdUtilization, update, utilization);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IpamsvcASM {\n");
    sb.append("    backEnd: ").append(toIndentedString(backEnd)).append("\n");
    sb.append("    backStart: ").append(toIndentedString(backStart)).append("\n");
    sb.append("    bothEnd: ").append(toIndentedString(bothEnd)).append("\n");
    sb.append("    bothStart: ").append(toIndentedString(bothStart)).append("\n");
    sb.append("    frontEnd: ").append(toIndentedString(frontEnd)).append("\n");
    sb.append("    frontStart: ").append(toIndentedString(frontStart)).append("\n");
    sb.append("    growth: ").append(toIndentedString(growth)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    lookahead: ").append(toIndentedString(lookahead)).append("\n");
    sb.append("    rangeEnd: ").append(toIndentedString(rangeEnd)).append("\n");
    sb.append("    rangeId: ").append(toIndentedString(rangeId)).append("\n");
    sb.append("    rangeStart: ").append(toIndentedString(rangeStart)).append("\n");
    sb.append("    subnetAddress: ").append(toIndentedString(subnetAddress)).append("\n");
    sb.append("    subnetCidr: ").append(toIndentedString(subnetCidr)).append("\n");
    sb.append("    subnetDirection: ").append(toIndentedString(subnetDirection)).append("\n");
    sb.append("    subnetId: ").append(toIndentedString(subnetId)).append("\n");
    sb.append("    subnetRange: ").append(toIndentedString(subnetRange)).append("\n");
    sb.append("    subnetRangeEnd: ").append(toIndentedString(subnetRangeEnd)).append("\n");
    sb.append("    subnetRangeStart: ").append(toIndentedString(subnetRangeStart)).append("\n");
    sb.append("    suppress: ").append(toIndentedString(suppress)).append("\n");
    sb.append("    suppressTime: ").append(toIndentedString(suppressTime)).append("\n");
    sb.append("    thresholdUtilization: ").append(toIndentedString(thresholdUtilization)).append("\n");
    sb.append("    update: ").append(toIndentedString(update)).append("\n");
    sb.append("    utilization: ").append(toIndentedString(utilization)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("back_end");
    openapiFields.add("back_start");
    openapiFields.add("both_end");
    openapiFields.add("both_start");
    openapiFields.add("front_end");
    openapiFields.add("front_start");
    openapiFields.add("growth");
    openapiFields.add("id");
    openapiFields.add("lookahead");
    openapiFields.add("range_end");
    openapiFields.add("range_id");
    openapiFields.add("range_start");
    openapiFields.add("subnet_address");
    openapiFields.add("subnet_cidr");
    openapiFields.add("subnet_direction");
    openapiFields.add("subnet_id");
    openapiFields.add("subnet_range");
    openapiFields.add("subnet_range_end");
    openapiFields.add("subnet_range_start");
    openapiFields.add("suppress");
    openapiFields.add("suppress_time");
    openapiFields.add("threshold_utilization");
    openapiFields.add("update");
    openapiFields.add("utilization");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("subnet_id");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IpamsvcASM
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IpamsvcASM.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IpamsvcASM is not found in the empty JSON string", IpamsvcASM.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IpamsvcASM.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IpamsvcASM` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : IpamsvcASM.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("back_end") != null && !jsonObj.get("back_end").isJsonNull()) && !jsonObj.get("back_end").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `back_end` to be a primitive type in the JSON string but got `%s`", jsonObj.get("back_end").toString()));
      }
      if ((jsonObj.get("back_start") != null && !jsonObj.get("back_start").isJsonNull()) && !jsonObj.get("back_start").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `back_start` to be a primitive type in the JSON string but got `%s`", jsonObj.get("back_start").toString()));
      }
      if ((jsonObj.get("both_end") != null && !jsonObj.get("both_end").isJsonNull()) && !jsonObj.get("both_end").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `both_end` to be a primitive type in the JSON string but got `%s`", jsonObj.get("both_end").toString()));
      }
      if ((jsonObj.get("both_start") != null && !jsonObj.get("both_start").isJsonNull()) && !jsonObj.get("both_start").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `both_start` to be a primitive type in the JSON string but got `%s`", jsonObj.get("both_start").toString()));
      }
      if ((jsonObj.get("front_end") != null && !jsonObj.get("front_end").isJsonNull()) && !jsonObj.get("front_end").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `front_end` to be a primitive type in the JSON string but got `%s`", jsonObj.get("front_end").toString()));
      }
      if ((jsonObj.get("front_start") != null && !jsonObj.get("front_start").isJsonNull()) && !jsonObj.get("front_start").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `front_start` to be a primitive type in the JSON string but got `%s`", jsonObj.get("front_start").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("range_end") != null && !jsonObj.get("range_end").isJsonNull()) && !jsonObj.get("range_end").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `range_end` to be a primitive type in the JSON string but got `%s`", jsonObj.get("range_end").toString()));
      }
      if ((jsonObj.get("range_id") != null && !jsonObj.get("range_id").isJsonNull()) && !jsonObj.get("range_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `range_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("range_id").toString()));
      }
      if ((jsonObj.get("range_start") != null && !jsonObj.get("range_start").isJsonNull()) && !jsonObj.get("range_start").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `range_start` to be a primitive type in the JSON string but got `%s`", jsonObj.get("range_start").toString()));
      }
      if ((jsonObj.get("subnet_address") != null && !jsonObj.get("subnet_address").isJsonNull()) && !jsonObj.get("subnet_address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnet_address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnet_address").toString()));
      }
      if ((jsonObj.get("subnet_direction") != null && !jsonObj.get("subnet_direction").isJsonNull()) && !jsonObj.get("subnet_direction").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnet_direction` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnet_direction").toString()));
      }
      if (!jsonObj.get("subnet_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnet_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnet_id").toString()));
      }
      if ((jsonObj.get("subnet_range") != null && !jsonObj.get("subnet_range").isJsonNull()) && !jsonObj.get("subnet_range").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnet_range` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnet_range").toString()));
      }
      if ((jsonObj.get("subnet_range_end") != null && !jsonObj.get("subnet_range_end").isJsonNull()) && !jsonObj.get("subnet_range_end").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnet_range_end` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnet_range_end").toString()));
      }
      if ((jsonObj.get("subnet_range_start") != null && !jsonObj.get("subnet_range_start").isJsonNull()) && !jsonObj.get("subnet_range_start").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `subnet_range_start` to be a primitive type in the JSON string but got `%s`", jsonObj.get("subnet_range_start").toString()));
      }
      if ((jsonObj.get("suppress") != null && !jsonObj.get("suppress").isJsonNull()) && !jsonObj.get("suppress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `suppress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("suppress").toString()));
      }
      if ((jsonObj.get("update") != null && !jsonObj.get("update").isJsonNull()) && !jsonObj.get("update").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `update` to be a primitive type in the JSON string but got `%s`", jsonObj.get("update").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IpamsvcASM.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IpamsvcASM' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IpamsvcASM> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IpamsvcASM.class));

       return (TypeAdapter<T>) new TypeAdapter<IpamsvcASM>() {
           @Override
           public void write(JsonWriter out, IpamsvcASM value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IpamsvcASM read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IpamsvcASM given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IpamsvcASM
   * @throws IOException if the JSON string is invalid with respect to IpamsvcASM
   */
  public static IpamsvcASM fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IpamsvcASM.class);
  }

  /**
   * Convert an instance of IpamsvcASM to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

