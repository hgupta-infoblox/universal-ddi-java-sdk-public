/*
 * IP Address Management API
 * The IPAM/DHCP Application is a BloxOne DDI service providing IP address management and DHCP protocol features. The IPAM component provides visibility into and provisioning tools to manage networking spaces, monitoring and reporting of entire IP address infrastructures, and integration with DNS and DHCP protocols. The DHCP component provides DHCP protocol configuration service with on-prem host serving DHCP protocol. It is part of the full-featured, DDI cloud solution that enables customers to deploy large numbers of protocol servers to deliver DNS and DHCP throughout their enterprise network.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.IpamsvcASMConfig;
import org.openapitools.client.model.IpamsvcDDNSZone;
import org.openapitools.client.model.IpamsvcDHCPConfig;
import org.openapitools.client.model.IpamsvcDHCPUtilizationThreshold;
import org.openapitools.client.model.IpamsvcKerberosKey;
import org.openapitools.client.model.IpamsvcLoggingConfig;
import org.openapitools.client.model.IpamsvcOptionItem;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The global DHCP configuration (_dhcp/global_). Used by default unless more specific configuration exists. There is only one instance of this object.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:31.429972+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class IpamsvcGlobal {
  public static final String SERIALIZED_NAME_ACTIVE_SEARCH_ENABLE = "active_search_enable";
  @SerializedName(SERIALIZED_NAME_ACTIVE_SEARCH_ENABLE)
  @javax.annotation.Nullable
  private Boolean activeSearchEnable;

  public static final String SERIALIZED_NAME_ASM_CONFIG = "asm_config";
  @SerializedName(SERIALIZED_NAME_ASM_CONFIG)
  @javax.annotation.Nullable
  private IpamsvcASMConfig asmConfig;

  public static final String SERIALIZED_NAME_CLIENT_PRINCIPAL = "client_principal";
  @SerializedName(SERIALIZED_NAME_CLIENT_PRINCIPAL)
  @javax.annotation.Nullable
  private String clientPrincipal;

  public static final String SERIALIZED_NAME_DDNS_CLIENT_UPDATE = "ddns_client_update";
  @SerializedName(SERIALIZED_NAME_DDNS_CLIENT_UPDATE)
  @javax.annotation.Nullable
  private String ddnsClientUpdate;

  public static final String SERIALIZED_NAME_DDNS_CONFLICT_RESOLUTION_MODE = "ddns_conflict_resolution_mode";
  @SerializedName(SERIALIZED_NAME_DDNS_CONFLICT_RESOLUTION_MODE)
  @javax.annotation.Nullable
  private String ddnsConflictResolutionMode;

  public static final String SERIALIZED_NAME_DDNS_DOMAIN = "ddns_domain";
  @SerializedName(SERIALIZED_NAME_DDNS_DOMAIN)
  @javax.annotation.Nullable
  private String ddnsDomain;

  public static final String SERIALIZED_NAME_DDNS_ENABLED = "ddns_enabled";
  @SerializedName(SERIALIZED_NAME_DDNS_ENABLED)
  @javax.annotation.Nullable
  private Boolean ddnsEnabled;

  public static final String SERIALIZED_NAME_DDNS_GENERATE_NAME = "ddns_generate_name";
  @SerializedName(SERIALIZED_NAME_DDNS_GENERATE_NAME)
  @javax.annotation.Nullable
  private Boolean ddnsGenerateName;

  public static final String SERIALIZED_NAME_DDNS_GENERATED_PREFIX = "ddns_generated_prefix";
  @SerializedName(SERIALIZED_NAME_DDNS_GENERATED_PREFIX)
  @javax.annotation.Nullable
  private String ddnsGeneratedPrefix;

  public static final String SERIALIZED_NAME_DDNS_SEND_UPDATES = "ddns_send_updates";
  @SerializedName(SERIALIZED_NAME_DDNS_SEND_UPDATES)
  @javax.annotation.Nullable
  private Boolean ddnsSendUpdates;

  public static final String SERIALIZED_NAME_DDNS_TTL_PERCENT = "ddns_ttl_percent";
  @SerializedName(SERIALIZED_NAME_DDNS_TTL_PERCENT)
  @javax.annotation.Nullable
  private Float ddnsTtlPercent;

  public static final String SERIALIZED_NAME_DDNS_UPDATE_ON_RENEW = "ddns_update_on_renew";
  @SerializedName(SERIALIZED_NAME_DDNS_UPDATE_ON_RENEW)
  @javax.annotation.Nullable
  private Boolean ddnsUpdateOnRenew;

  public static final String SERIALIZED_NAME_DDNS_USE_CONFLICT_RESOLUTION = "ddns_use_conflict_resolution";
  @SerializedName(SERIALIZED_NAME_DDNS_USE_CONFLICT_RESOLUTION)
  @javax.annotation.Nullable
  private Boolean ddnsUseConflictResolution;

  public static final String SERIALIZED_NAME_DDNS_ZONES = "ddns_zones";
  @SerializedName(SERIALIZED_NAME_DDNS_ZONES)
  @javax.annotation.Nullable
  private List<IpamsvcDDNSZone> ddnsZones = new ArrayList<>();

  public static final String SERIALIZED_NAME_DHCP_CONFIG = "dhcp_config";
  @SerializedName(SERIALIZED_NAME_DHCP_CONFIG)
  @javax.annotation.Nullable
  private IpamsvcDHCPConfig dhcpConfig;

  public static final String SERIALIZED_NAME_DHCP_OPTIONS = "dhcp_options";
  @SerializedName(SERIALIZED_NAME_DHCP_OPTIONS)
  @javax.annotation.Nullable
  private List<IpamsvcOptionItem> dhcpOptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DHCP_OPTIONS_V6 = "dhcp_options_v6";
  @SerializedName(SERIALIZED_NAME_DHCP_OPTIONS_V6)
  @javax.annotation.Nullable
  private List<IpamsvcOptionItem> dhcpOptionsV6 = new ArrayList<>();

  public static final String SERIALIZED_NAME_DHCP_THRESHOLD = "dhcp_threshold";
  @SerializedName(SERIALIZED_NAME_DHCP_THRESHOLD)
  @javax.annotation.Nullable
  private IpamsvcDHCPUtilizationThreshold dhcpThreshold;

  public static final String SERIALIZED_NAME_GSS_TSIG_FALLBACK = "gss_tsig_fallback";
  @SerializedName(SERIALIZED_NAME_GSS_TSIG_FALLBACK)
  @javax.annotation.Nullable
  private Boolean gssTsigFallback;

  public static final String SERIALIZED_NAME_HEADER_OPTION_FILENAME = "header_option_filename";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_FILENAME)
  @javax.annotation.Nullable
  private String headerOptionFilename;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS = "header_option_server_address";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS)
  @javax.annotation.Nullable
  private String headerOptionServerAddress;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME = "header_option_server_name";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME)
  @javax.annotation.Nullable
  private String headerOptionServerName;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_CHAR = "hostname_rewrite_char";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_CHAR)
  @javax.annotation.Nullable
  private String hostnameRewriteChar;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_ENABLED = "hostname_rewrite_enabled";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_ENABLED)
  @javax.annotation.Nullable
  private Boolean hostnameRewriteEnabled;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_REGEX = "hostname_rewrite_regex";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_REGEX)
  @javax.annotation.Nullable
  private String hostnameRewriteRegex;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_KERBEROS_KDC = "kerberos_kdc";
  @SerializedName(SERIALIZED_NAME_KERBEROS_KDC)
  @javax.annotation.Nullable
  private String kerberosKdc;

  public static final String SERIALIZED_NAME_KERBEROS_KEYS = "kerberos_keys";
  @SerializedName(SERIALIZED_NAME_KERBEROS_KEYS)
  @javax.annotation.Nullable
  private List<IpamsvcKerberosKey> kerberosKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_KERBEROS_REKEY_INTERVAL = "kerberos_rekey_interval";
  @SerializedName(SERIALIZED_NAME_KERBEROS_REKEY_INTERVAL)
  @javax.annotation.Nullable
  private Long kerberosRekeyInterval;

  public static final String SERIALIZED_NAME_KERBEROS_RETRY_INTERVAL = "kerberos_retry_interval";
  @SerializedName(SERIALIZED_NAME_KERBEROS_RETRY_INTERVAL)
  @javax.annotation.Nullable
  private Long kerberosRetryInterval;

  public static final String SERIALIZED_NAME_KERBEROS_TKEY_LIFETIME = "kerberos_tkey_lifetime";
  @SerializedName(SERIALIZED_NAME_KERBEROS_TKEY_LIFETIME)
  @javax.annotation.Nullable
  private Long kerberosTkeyLifetime;

  public static final String SERIALIZED_NAME_KERBEROS_TKEY_PROTOCOL = "kerberos_tkey_protocol";
  @SerializedName(SERIALIZED_NAME_KERBEROS_TKEY_PROTOCOL)
  @javax.annotation.Nullable
  private String kerberosTkeyProtocol;

  public static final String SERIALIZED_NAME_LOGGING_CONFIGURATION = "logging_configuration";
  @SerializedName(SERIALIZED_NAME_LOGGING_CONFIGURATION)
  @javax.annotation.Nullable
  private IpamsvcLoggingConfig loggingConfiguration;

  public static final String SERIALIZED_NAME_PREFER_OPTION12 = "prefer_option_12";
  @SerializedName(SERIALIZED_NAME_PREFER_OPTION12)
  @javax.annotation.Nullable
  private Boolean preferOption12;

  public static final String SERIALIZED_NAME_REMOVE_SUFFIX_OPTION81 = "remove_suffix_option_81";
  @SerializedName(SERIALIZED_NAME_REMOVE_SUFFIX_OPTION81)
  @javax.annotation.Nullable
  private Boolean removeSuffixOption81;

  public static final String SERIALIZED_NAME_SERVER_PRINCIPAL = "server_principal";
  @SerializedName(SERIALIZED_NAME_SERVER_PRINCIPAL)
  @javax.annotation.Nullable
  private String serverPrincipal;

  public static final String SERIALIZED_NAME_VENDOR_SPECIFIC_OPTION_OPTION_SPACE = "vendor_specific_option_option_space";
  @SerializedName(SERIALIZED_NAME_VENDOR_SPECIFIC_OPTION_OPTION_SPACE)
  @javax.annotation.Nullable
  private String vendorSpecificOptionOptionSpace;

  public IpamsvcGlobal() {
  }

  public IpamsvcGlobal(
     String id
  ) {
    this();
    this.id = id;
  }

  public IpamsvcGlobal activeSearchEnable(@javax.annotation.Nullable Boolean activeSearchEnable) {
    this.activeSearchEnable = activeSearchEnable;
    return this;
  }

  /**
   * Determines if \&quot;30 Day Active Search\&quot; feature is enabled or not.
   * @return activeSearchEnable
   */
  @javax.annotation.Nullable
  public Boolean getActiveSearchEnable() {
    return activeSearchEnable;
  }

  public void setActiveSearchEnable(@javax.annotation.Nullable Boolean activeSearchEnable) {
    this.activeSearchEnable = activeSearchEnable;
  }


  public IpamsvcGlobal asmConfig(@javax.annotation.Nullable IpamsvcASMConfig asmConfig) {
    this.asmConfig = asmConfig;
    return this;
  }

  /**
   * Get asmConfig
   * @return asmConfig
   */
  @javax.annotation.Nullable
  public IpamsvcASMConfig getAsmConfig() {
    return asmConfig;
  }

  public void setAsmConfig(@javax.annotation.Nullable IpamsvcASMConfig asmConfig) {
    this.asmConfig = asmConfig;
  }


  public IpamsvcGlobal clientPrincipal(@javax.annotation.Nullable String clientPrincipal) {
    this.clientPrincipal = clientPrincipal;
    return this;
  }

  /**
   * The Kerberos principal name. It uses the typical Kerberos notation: &lt;SERVICE-NAME&gt;/&lt;server-domain-name&gt;@&lt;REALM&gt;.  Defaults to empty.
   * @return clientPrincipal
   */
  @javax.annotation.Nullable
  public String getClientPrincipal() {
    return clientPrincipal;
  }

  public void setClientPrincipal(@javax.annotation.Nullable String clientPrincipal) {
    this.clientPrincipal = clientPrincipal;
  }


  public IpamsvcGlobal ddnsClientUpdate(@javax.annotation.Nullable String ddnsClientUpdate) {
    this.ddnsClientUpdate = ddnsClientUpdate;
    return this;
  }

  /**
   * The global configuration to control who does the DDNS updates.  Valid values are: * _client_: DHCP server updates DNS if requested by client. * _server_: DHCP server always updates DNS, overriding an update request from the client, unless the client requests no updates. * _ignore_: DHCP server always updates DNS, even if the client says not to. * _over_client_update_: Same as _server_. DHCP server always updates DNS, overriding an update request from the client, unless the client requests no updates. * _over_no_update_: DHCP server updates DNS even if the client requests that no updates be done. If the client requests to do the update, DHCP server allows it.  Defaults to _client_.
   * @return ddnsClientUpdate
   */
  @javax.annotation.Nullable
  public String getDdnsClientUpdate() {
    return ddnsClientUpdate;
  }

  public void setDdnsClientUpdate(@javax.annotation.Nullable String ddnsClientUpdate) {
    this.ddnsClientUpdate = ddnsClientUpdate;
  }


  public IpamsvcGlobal ddnsConflictResolutionMode(@javax.annotation.Nullable String ddnsConflictResolutionMode) {
    this.ddnsConflictResolutionMode = ddnsConflictResolutionMode;
    return this;
  }

  /**
   * The mode used for resolving conflicts while performing DDNS updates.  Valid values are: * _check_with_dhcid_: It includes adding a DHCID record and checking that record via conflict detection as per RFC 4703. * _no_check_with_dhcid_: This will ignore conflict detection but add a DHCID record when creating/updating an entry. * _check_exists_with_dhcid_: This will check if there is an existing DHCID record but does not verify the value of the record matches the update. This will also update the DHCID record for the entry. * _no_check_without_dhcid_: This ignores conflict detection and will not add a DHCID record when creating/updating a DDNS entry.  Defaults to _check_with_dhcid_.
   * @return ddnsConflictResolutionMode
   */
  @javax.annotation.Nullable
  public String getDdnsConflictResolutionMode() {
    return ddnsConflictResolutionMode;
  }

  public void setDdnsConflictResolutionMode(@javax.annotation.Nullable String ddnsConflictResolutionMode) {
    this.ddnsConflictResolutionMode = ddnsConflictResolutionMode;
  }


  public IpamsvcGlobal ddnsDomain(@javax.annotation.Nullable String ddnsDomain) {
    this.ddnsDomain = ddnsDomain;
    return this;
  }

  /**
   * The domain suffix for DDNS updates. FQDN, may be empty.  Must be specified if _ddns_enabled_ is _true_.  Defaults to empty.
   * @return ddnsDomain
   */
  @javax.annotation.Nullable
  public String getDdnsDomain() {
    return ddnsDomain;
  }

  public void setDdnsDomain(@javax.annotation.Nullable String ddnsDomain) {
    this.ddnsDomain = ddnsDomain;
  }


  public IpamsvcGlobal ddnsEnabled(@javax.annotation.Nullable Boolean ddnsEnabled) {
    this.ddnsEnabled = ddnsEnabled;
    return this;
  }

  /**
   * Indicates if DDNS updates should be performed for leases.  All other ddns_* configuration fields are ignored when this flag is unset.  At a minimum, _ddns_domain_ and _ddns_zones_ must be configured to enable DDNS.  Defaults to _false_.
   * @return ddnsEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDdnsEnabled() {
    return ddnsEnabled;
  }

  public void setDdnsEnabled(@javax.annotation.Nullable Boolean ddnsEnabled) {
    this.ddnsEnabled = ddnsEnabled;
  }


  public IpamsvcGlobal ddnsGenerateName(@javax.annotation.Nullable Boolean ddnsGenerateName) {
    this.ddnsGenerateName = ddnsGenerateName;
    return this;
  }

  /**
   * Indicates if DDNS needs to generate a hostname when not supplied by the client.  Defaults to _false_.
   * @return ddnsGenerateName
   */
  @javax.annotation.Nullable
  public Boolean getDdnsGenerateName() {
    return ddnsGenerateName;
  }

  public void setDdnsGenerateName(@javax.annotation.Nullable Boolean ddnsGenerateName) {
    this.ddnsGenerateName = ddnsGenerateName;
  }


  public IpamsvcGlobal ddnsGeneratedPrefix(@javax.annotation.Nullable String ddnsGeneratedPrefix) {
    this.ddnsGeneratedPrefix = ddnsGeneratedPrefix;
    return this;
  }

  /**
   * The prefix used in the generation of an FQDN.  When generating a name, DHCP server will construct the name in the format: [ddns-generated-prefix]-[address-text].[ddns-qualifying-suffix]. where address-text is simply the lease IP address converted to a hyphenated string.  Defaults to \&quot;myhost\&quot;.
   * @return ddnsGeneratedPrefix
   */
  @javax.annotation.Nullable
  public String getDdnsGeneratedPrefix() {
    return ddnsGeneratedPrefix;
  }

  public void setDdnsGeneratedPrefix(@javax.annotation.Nullable String ddnsGeneratedPrefix) {
    this.ddnsGeneratedPrefix = ddnsGeneratedPrefix;
  }


  public IpamsvcGlobal ddnsSendUpdates(@javax.annotation.Nullable Boolean ddnsSendUpdates) {
    this.ddnsSendUpdates = ddnsSendUpdates;
    return this;
  }

  /**
   * Determines if DDNS updates are enabled at the global level. Defaults to _true_.
   * @return ddnsSendUpdates
   */
  @javax.annotation.Nullable
  public Boolean getDdnsSendUpdates() {
    return ddnsSendUpdates;
  }

  public void setDdnsSendUpdates(@javax.annotation.Nullable Boolean ddnsSendUpdates) {
    this.ddnsSendUpdates = ddnsSendUpdates;
  }


  public IpamsvcGlobal ddnsTtlPercent(@javax.annotation.Nullable Float ddnsTtlPercent) {
    this.ddnsTtlPercent = ddnsTtlPercent;
    return this;
  }

  /**
   * DDNS TTL value - to be calculated as a simple percentage of the lease&#39;s lifetime, using the parameter&#39;s value as the percentage. It is specified as a percentage (e.g. 25, 75). Defaults to unspecified.
   * @return ddnsTtlPercent
   */
  @javax.annotation.Nullable
  public Float getDdnsTtlPercent() {
    return ddnsTtlPercent;
  }

  public void setDdnsTtlPercent(@javax.annotation.Nullable Float ddnsTtlPercent) {
    this.ddnsTtlPercent = ddnsTtlPercent;
  }


  public IpamsvcGlobal ddnsUpdateOnRenew(@javax.annotation.Nullable Boolean ddnsUpdateOnRenew) {
    this.ddnsUpdateOnRenew = ddnsUpdateOnRenew;
    return this;
  }

  /**
   * Instructs the DHCP server to always update the DNS information when a lease is renewed even if its DNS information has not changed.  Defaults to _false_.
   * @return ddnsUpdateOnRenew
   */
  @javax.annotation.Nullable
  public Boolean getDdnsUpdateOnRenew() {
    return ddnsUpdateOnRenew;
  }

  public void setDdnsUpdateOnRenew(@javax.annotation.Nullable Boolean ddnsUpdateOnRenew) {
    this.ddnsUpdateOnRenew = ddnsUpdateOnRenew;
  }


  public IpamsvcGlobal ddnsUseConflictResolution(@javax.annotation.Nullable Boolean ddnsUseConflictResolution) {
    this.ddnsUseConflictResolution = ddnsUseConflictResolution;
    return this;
  }

  /**
   * When true, DHCP server will apply conflict resolution, as described in RFC 4703, when attempting to fulfill the update request.  When false, DHCP server will simply attempt to update the DNS entries per the request, regardless of whether or not they conflict with existing entries owned by other DHCP4 clients.  Defaults to _true_.
   * @return ddnsUseConflictResolution
   */
  @javax.annotation.Nullable
  public Boolean getDdnsUseConflictResolution() {
    return ddnsUseConflictResolution;
  }

  public void setDdnsUseConflictResolution(@javax.annotation.Nullable Boolean ddnsUseConflictResolution) {
    this.ddnsUseConflictResolution = ddnsUseConflictResolution;
  }


  public IpamsvcGlobal ddnsZones(@javax.annotation.Nullable List<IpamsvcDDNSZone> ddnsZones) {
    this.ddnsZones = ddnsZones;
    return this;
  }

  public IpamsvcGlobal addDdnsZonesItem(IpamsvcDDNSZone ddnsZonesItem) {
    if (this.ddnsZones == null) {
      this.ddnsZones = new ArrayList<>();
    }
    this.ddnsZones.add(ddnsZonesItem);
    return this;
  }

  /**
   * DNS zones that DDNS updates can be sent to. There is no resolver fallback. The target zone must be explicitly configured for the update to be performed.  Updates are sent to the closest enclosing zone.  Error if _ddns_enabled_ is _true_ and the _ddns_domain_ does not have a corresponding entry in _ddns_zones_.  Error if there are items with duplicate zone in the list.  Defaults to empty list.
   * @return ddnsZones
   */
  @javax.annotation.Nullable
  public List<IpamsvcDDNSZone> getDdnsZones() {
    return ddnsZones;
  }

  public void setDdnsZones(@javax.annotation.Nullable List<IpamsvcDDNSZone> ddnsZones) {
    this.ddnsZones = ddnsZones;
  }


  public IpamsvcGlobal dhcpConfig(@javax.annotation.Nullable IpamsvcDHCPConfig dhcpConfig) {
    this.dhcpConfig = dhcpConfig;
    return this;
  }

  /**
   * Get dhcpConfig
   * @return dhcpConfig
   */
  @javax.annotation.Nullable
  public IpamsvcDHCPConfig getDhcpConfig() {
    return dhcpConfig;
  }

  public void setDhcpConfig(@javax.annotation.Nullable IpamsvcDHCPConfig dhcpConfig) {
    this.dhcpConfig = dhcpConfig;
  }


  public IpamsvcGlobal dhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
    return this;
  }

  public IpamsvcGlobal addDhcpOptionsItem(IpamsvcOptionItem dhcpOptionsItem) {
    if (this.dhcpOptions == null) {
      this.dhcpOptions = new ArrayList<>();
    }
    this.dhcpOptions.add(dhcpOptionsItem);
    return this;
  }

  /**
   * The list of DHCP options or group of options for IPv4. An option list is ordered and may include both option groups and specific options. Multiple occurrences of the same option or group is not an error. The last occurrence of an option in the list will be used.  Error if the graph of referenced groups contains cycles.  Defaults to empty list.
   * @return dhcpOptions
   */
  @javax.annotation.Nullable
  public List<IpamsvcOptionItem> getDhcpOptions() {
    return dhcpOptions;
  }

  public void setDhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
  }


  public IpamsvcGlobal dhcpOptionsV6(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptionsV6) {
    this.dhcpOptionsV6 = dhcpOptionsV6;
    return this;
  }

  public IpamsvcGlobal addDhcpOptionsV6Item(IpamsvcOptionItem dhcpOptionsV6Item) {
    if (this.dhcpOptionsV6 == null) {
      this.dhcpOptionsV6 = new ArrayList<>();
    }
    this.dhcpOptionsV6.add(dhcpOptionsV6Item);
    return this;
  }

  /**
   * The list of DHCP options or group of options for IPv6. An option list is ordered and may include both option groups and specific options. Multiple occurrences of the same option or group is not an error. The last occurrence of an option in the list will be used.  Error if the graph of referenced groups contains cycles.  Defaults to empty list.
   * @return dhcpOptionsV6
   */
  @javax.annotation.Nullable
  public List<IpamsvcOptionItem> getDhcpOptionsV6() {
    return dhcpOptionsV6;
  }

  public void setDhcpOptionsV6(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptionsV6) {
    this.dhcpOptionsV6 = dhcpOptionsV6;
  }


  public IpamsvcGlobal dhcpThreshold(@javax.annotation.Nullable IpamsvcDHCPUtilizationThreshold dhcpThreshold) {
    this.dhcpThreshold = dhcpThreshold;
    return this;
  }

  /**
   * Get dhcpThreshold
   * @return dhcpThreshold
   */
  @javax.annotation.Nullable
  public IpamsvcDHCPUtilizationThreshold getDhcpThreshold() {
    return dhcpThreshold;
  }

  public void setDhcpThreshold(@javax.annotation.Nullable IpamsvcDHCPUtilizationThreshold dhcpThreshold) {
    this.dhcpThreshold = dhcpThreshold;
  }


  public IpamsvcGlobal gssTsigFallback(@javax.annotation.Nullable Boolean gssTsigFallback) {
    this.gssTsigFallback = gssTsigFallback;
    return this;
  }

  /**
   * The behavior when GSS-TSIG should be used (a matching external DNS server is configured) but no GSS-TSIG key is available. If configured to _false_ (the default) this DNS server is skipped, if configured to _true_ the DNS server is ignored and the DNS update is sent with the configured DHCP-DDNS protection e.g. TSIG key or without any protection when none was configured.  Defaults to _false_.
   * @return gssTsigFallback
   */
  @javax.annotation.Nullable
  public Boolean getGssTsigFallback() {
    return gssTsigFallback;
  }

  public void setGssTsigFallback(@javax.annotation.Nullable Boolean gssTsigFallback) {
    this.gssTsigFallback = gssTsigFallback;
  }


  public IpamsvcGlobal headerOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
    return this;
  }

  /**
   * The configuration for header option filename field.
   * @return headerOptionFilename
   */
  @javax.annotation.Nullable
  public String getHeaderOptionFilename() {
    return headerOptionFilename;
  }

  public void setHeaderOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
  }


  public IpamsvcGlobal headerOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
    return this;
  }

  /**
   * The configuration for header option server address field.
   * @return headerOptionServerAddress
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerAddress() {
    return headerOptionServerAddress;
  }

  public void setHeaderOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
  }


  public IpamsvcGlobal headerOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
    return this;
  }

  /**
   * The configuration for header option server name field.
   * @return headerOptionServerName
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerName() {
    return headerOptionServerName;
  }

  public void setHeaderOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
  }


  public IpamsvcGlobal hostnameRewriteChar(@javax.annotation.Nullable String hostnameRewriteChar) {
    this.hostnameRewriteChar = hostnameRewriteChar;
    return this;
  }

  /**
   * The character to replace non-matching characters with, when hostname rewrite is enabled in global configuration.  Any single ASCII character or no character if the invalid characters should be removed without replacement.  Defaults to \&quot;-\&quot;.
   * @return hostnameRewriteChar
   */
  @javax.annotation.Nullable
  public String getHostnameRewriteChar() {
    return hostnameRewriteChar;
  }

  public void setHostnameRewriteChar(@javax.annotation.Nullable String hostnameRewriteChar) {
    this.hostnameRewriteChar = hostnameRewriteChar;
  }


  public IpamsvcGlobal hostnameRewriteEnabled(@javax.annotation.Nullable Boolean hostnameRewriteEnabled) {
    this.hostnameRewriteEnabled = hostnameRewriteEnabled;
    return this;
  }

  /**
   * The global configuration to indicate if the hostnames supplied by the client will be rewritten prior to DDNS update by replacing every character that does not match _hostname_rewrite_regex_ by _hostname_rewrite_char_.  Defaults to _false_.
   * @return hostnameRewriteEnabled
   */
  @javax.annotation.Nullable
  public Boolean getHostnameRewriteEnabled() {
    return hostnameRewriteEnabled;
  }

  public void setHostnameRewriteEnabled(@javax.annotation.Nullable Boolean hostnameRewriteEnabled) {
    this.hostnameRewriteEnabled = hostnameRewriteEnabled;
  }


  public IpamsvcGlobal hostnameRewriteRegex(@javax.annotation.Nullable String hostnameRewriteRegex) {
    this.hostnameRewriteRegex = hostnameRewriteRegex;
    return this;
  }

  /**
   * The regex bracket expression to match valid characters when hostname rewrite is enabled in global configuration.  Must begin with \&quot;[\&quot; and end with \&quot;]\&quot; and be a compilable POSIX regex.  Defaults to \&quot;[^a-zA-Z0-9_.]\&quot;.
   * @return hostnameRewriteRegex
   */
  @javax.annotation.Nullable
  public String getHostnameRewriteRegex() {
    return hostnameRewriteRegex;
  }

  public void setHostnameRewriteRegex(@javax.annotation.Nullable String hostnameRewriteRegex) {
    this.hostnameRewriteRegex = hostnameRewriteRegex;
  }


  /**
   * The resource identifier.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public IpamsvcGlobal kerberosKdc(@javax.annotation.Nullable String kerberosKdc) {
    this.kerberosKdc = kerberosKdc;
    return this;
  }

  /**
   * Address of Kerberos Key Distribution Center.  Defaults to empty.
   * @return kerberosKdc
   */
  @javax.annotation.Nullable
  public String getKerberosKdc() {
    return kerberosKdc;
  }

  public void setKerberosKdc(@javax.annotation.Nullable String kerberosKdc) {
    this.kerberosKdc = kerberosKdc;
  }


  public IpamsvcGlobal kerberosKeys(@javax.annotation.Nullable List<IpamsvcKerberosKey> kerberosKeys) {
    this.kerberosKeys = kerberosKeys;
    return this;
  }

  public IpamsvcGlobal addKerberosKeysItem(IpamsvcKerberosKey kerberosKeysItem) {
    if (this.kerberosKeys == null) {
      this.kerberosKeys = new ArrayList<>();
    }
    this.kerberosKeys.add(kerberosKeysItem);
    return this;
  }

  /**
   * _kerberos_keys_ contains a list of keys for GSS-TSIG signed dynamic updates.  Defaults to empty.
   * @return kerberosKeys
   */
  @javax.annotation.Nullable
  public List<IpamsvcKerberosKey> getKerberosKeys() {
    return kerberosKeys;
  }

  public void setKerberosKeys(@javax.annotation.Nullable List<IpamsvcKerberosKey> kerberosKeys) {
    this.kerberosKeys = kerberosKeys;
  }


  public IpamsvcGlobal kerberosRekeyInterval(@javax.annotation.Nullable Long kerberosRekeyInterval) {
    this.kerberosRekeyInterval = kerberosRekeyInterval;
    return this;
  }

  /**
   * Time interval (in seconds) the keys for each configured external DNS server are checked for rekeying, i.e. a new key is created to replace the current usable one when its age is greater than the _kerberos_rekey_interval_ value.  Defaults to 120 seconds.
   * @return kerberosRekeyInterval
   */
  @javax.annotation.Nullable
  public Long getKerberosRekeyInterval() {
    return kerberosRekeyInterval;
  }

  public void setKerberosRekeyInterval(@javax.annotation.Nullable Long kerberosRekeyInterval) {
    this.kerberosRekeyInterval = kerberosRekeyInterval;
  }


  public IpamsvcGlobal kerberosRetryInterval(@javax.annotation.Nullable Long kerberosRetryInterval) {
    this.kerberosRetryInterval = kerberosRetryInterval;
    return this;
  }

  /**
   * Time interval (in seconds) to retry to create a key if any error occurred previously for any configured external DNS server.  Defaults to 30 seconds.
   * @return kerberosRetryInterval
   */
  @javax.annotation.Nullable
  public Long getKerberosRetryInterval() {
    return kerberosRetryInterval;
  }

  public void setKerberosRetryInterval(@javax.annotation.Nullable Long kerberosRetryInterval) {
    this.kerberosRetryInterval = kerberosRetryInterval;
  }


  public IpamsvcGlobal kerberosTkeyLifetime(@javax.annotation.Nullable Long kerberosTkeyLifetime) {
    this.kerberosTkeyLifetime = kerberosTkeyLifetime;
    return this;
  }

  /**
   * Lifetime (in seconds) of GSS-TSIG keys in the TKEY protocol.  Defaults to 160 seconds.
   * @return kerberosTkeyLifetime
   */
  @javax.annotation.Nullable
  public Long getKerberosTkeyLifetime() {
    return kerberosTkeyLifetime;
  }

  public void setKerberosTkeyLifetime(@javax.annotation.Nullable Long kerberosTkeyLifetime) {
    this.kerberosTkeyLifetime = kerberosTkeyLifetime;
  }


  public IpamsvcGlobal kerberosTkeyProtocol(@javax.annotation.Nullable String kerberosTkeyProtocol) {
    this.kerberosTkeyProtocol = kerberosTkeyProtocol;
    return this;
  }

  /**
   * Determines which protocol is used to establish the security context with the external DNS servers, TCP or UDP.  Defaults to _tcp_.
   * @return kerberosTkeyProtocol
   */
  @javax.annotation.Nullable
  public String getKerberosTkeyProtocol() {
    return kerberosTkeyProtocol;
  }

  public void setKerberosTkeyProtocol(@javax.annotation.Nullable String kerberosTkeyProtocol) {
    this.kerberosTkeyProtocol = kerberosTkeyProtocol;
  }


  public IpamsvcGlobal loggingConfiguration(@javax.annotation.Nullable IpamsvcLoggingConfig loggingConfiguration) {
    this.loggingConfiguration = loggingConfiguration;
    return this;
  }

  /**
   * Get loggingConfiguration
   * @return loggingConfiguration
   */
  @javax.annotation.Nullable
  public IpamsvcLoggingConfig getLoggingConfiguration() {
    return loggingConfiguration;
  }

  public void setLoggingConfiguration(@javax.annotation.Nullable IpamsvcLoggingConfig loggingConfiguration) {
    this.loggingConfiguration = loggingConfiguration;
  }


  public IpamsvcGlobal preferOption12(@javax.annotation.Nullable Boolean preferOption12) {
    this.preferOption12 = preferOption12;
    return this;
  }

  /**
   * When enabled, DHCP Server will prefer option 12 over option 81 in the incoming client request.  Defaults to _false_.
   * @return preferOption12
   */
  @javax.annotation.Nullable
  public Boolean getPreferOption12() {
    return preferOption12;
  }

  public void setPreferOption12(@javax.annotation.Nullable Boolean preferOption12) {
    this.preferOption12 = preferOption12;
  }


  public IpamsvcGlobal removeSuffixOption81(@javax.annotation.Nullable Boolean removeSuffixOption81) {
    this.removeSuffixOption81 = removeSuffixOption81;
    return this;
  }

  /**
   * When enabled, DHCP Server will remove the suffix from the option 81 in the incoming client request.  Defaults to _false_.
   * @return removeSuffixOption81
   */
  @javax.annotation.Nullable
  public Boolean getRemoveSuffixOption81() {
    return removeSuffixOption81;
  }

  public void setRemoveSuffixOption81(@javax.annotation.Nullable Boolean removeSuffixOption81) {
    this.removeSuffixOption81 = removeSuffixOption81;
  }


  public IpamsvcGlobal serverPrincipal(@javax.annotation.Nullable String serverPrincipal) {
    this.serverPrincipal = serverPrincipal;
    return this;
  }

  /**
   * The Kerberos principal name of the external DNS server that will receive updates.  Defaults to empty.
   * @return serverPrincipal
   */
  @javax.annotation.Nullable
  public String getServerPrincipal() {
    return serverPrincipal;
  }

  public void setServerPrincipal(@javax.annotation.Nullable String serverPrincipal) {
    this.serverPrincipal = serverPrincipal;
  }


  public IpamsvcGlobal vendorSpecificOptionOptionSpace(@javax.annotation.Nullable String vendorSpecificOptionOptionSpace) {
    this.vendorSpecificOptionOptionSpace = vendorSpecificOptionOptionSpace;
    return this;
  }

  /**
   * The resource identifier.
   * @return vendorSpecificOptionOptionSpace
   */
  @javax.annotation.Nullable
  public String getVendorSpecificOptionOptionSpace() {
    return vendorSpecificOptionOptionSpace;
  }

  public void setVendorSpecificOptionOptionSpace(@javax.annotation.Nullable String vendorSpecificOptionOptionSpace) {
    this.vendorSpecificOptionOptionSpace = vendorSpecificOptionOptionSpace;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IpamsvcGlobal ipamsvcGlobal = (IpamsvcGlobal) o;
    return Objects.equals(this.activeSearchEnable, ipamsvcGlobal.activeSearchEnable) &&
        Objects.equals(this.asmConfig, ipamsvcGlobal.asmConfig) &&
        Objects.equals(this.clientPrincipal, ipamsvcGlobal.clientPrincipal) &&
        Objects.equals(this.ddnsClientUpdate, ipamsvcGlobal.ddnsClientUpdate) &&
        Objects.equals(this.ddnsConflictResolutionMode, ipamsvcGlobal.ddnsConflictResolutionMode) &&
        Objects.equals(this.ddnsDomain, ipamsvcGlobal.ddnsDomain) &&
        Objects.equals(this.ddnsEnabled, ipamsvcGlobal.ddnsEnabled) &&
        Objects.equals(this.ddnsGenerateName, ipamsvcGlobal.ddnsGenerateName) &&
        Objects.equals(this.ddnsGeneratedPrefix, ipamsvcGlobal.ddnsGeneratedPrefix) &&
        Objects.equals(this.ddnsSendUpdates, ipamsvcGlobal.ddnsSendUpdates) &&
        Objects.equals(this.ddnsTtlPercent, ipamsvcGlobal.ddnsTtlPercent) &&
        Objects.equals(this.ddnsUpdateOnRenew, ipamsvcGlobal.ddnsUpdateOnRenew) &&
        Objects.equals(this.ddnsUseConflictResolution, ipamsvcGlobal.ddnsUseConflictResolution) &&
        Objects.equals(this.ddnsZones, ipamsvcGlobal.ddnsZones) &&
        Objects.equals(this.dhcpConfig, ipamsvcGlobal.dhcpConfig) &&
        Objects.equals(this.dhcpOptions, ipamsvcGlobal.dhcpOptions) &&
        Objects.equals(this.dhcpOptionsV6, ipamsvcGlobal.dhcpOptionsV6) &&
        Objects.equals(this.dhcpThreshold, ipamsvcGlobal.dhcpThreshold) &&
        Objects.equals(this.gssTsigFallback, ipamsvcGlobal.gssTsigFallback) &&
        Objects.equals(this.headerOptionFilename, ipamsvcGlobal.headerOptionFilename) &&
        Objects.equals(this.headerOptionServerAddress, ipamsvcGlobal.headerOptionServerAddress) &&
        Objects.equals(this.headerOptionServerName, ipamsvcGlobal.headerOptionServerName) &&
        Objects.equals(this.hostnameRewriteChar, ipamsvcGlobal.hostnameRewriteChar) &&
        Objects.equals(this.hostnameRewriteEnabled, ipamsvcGlobal.hostnameRewriteEnabled) &&
        Objects.equals(this.hostnameRewriteRegex, ipamsvcGlobal.hostnameRewriteRegex) &&
        Objects.equals(this.id, ipamsvcGlobal.id) &&
        Objects.equals(this.kerberosKdc, ipamsvcGlobal.kerberosKdc) &&
        Objects.equals(this.kerberosKeys, ipamsvcGlobal.kerberosKeys) &&
        Objects.equals(this.kerberosRekeyInterval, ipamsvcGlobal.kerberosRekeyInterval) &&
        Objects.equals(this.kerberosRetryInterval, ipamsvcGlobal.kerberosRetryInterval) &&
        Objects.equals(this.kerberosTkeyLifetime, ipamsvcGlobal.kerberosTkeyLifetime) &&
        Objects.equals(this.kerberosTkeyProtocol, ipamsvcGlobal.kerberosTkeyProtocol) &&
        Objects.equals(this.loggingConfiguration, ipamsvcGlobal.loggingConfiguration) &&
        Objects.equals(this.preferOption12, ipamsvcGlobal.preferOption12) &&
        Objects.equals(this.removeSuffixOption81, ipamsvcGlobal.removeSuffixOption81) &&
        Objects.equals(this.serverPrincipal, ipamsvcGlobal.serverPrincipal) &&
        Objects.equals(this.vendorSpecificOptionOptionSpace, ipamsvcGlobal.vendorSpecificOptionOptionSpace);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activeSearchEnable, asmConfig, clientPrincipal, ddnsClientUpdate, ddnsConflictResolutionMode, ddnsDomain, ddnsEnabled, ddnsGenerateName, ddnsGeneratedPrefix, ddnsSendUpdates, ddnsTtlPercent, ddnsUpdateOnRenew, ddnsUseConflictResolution, ddnsZones, dhcpConfig, dhcpOptions, dhcpOptionsV6, dhcpThreshold, gssTsigFallback, headerOptionFilename, headerOptionServerAddress, headerOptionServerName, hostnameRewriteChar, hostnameRewriteEnabled, hostnameRewriteRegex, id, kerberosKdc, kerberosKeys, kerberosRekeyInterval, kerberosRetryInterval, kerberosTkeyLifetime, kerberosTkeyProtocol, loggingConfiguration, preferOption12, removeSuffixOption81, serverPrincipal, vendorSpecificOptionOptionSpace);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IpamsvcGlobal {\n");
    sb.append("    activeSearchEnable: ").append(toIndentedString(activeSearchEnable)).append("\n");
    sb.append("    asmConfig: ").append(toIndentedString(asmConfig)).append("\n");
    sb.append("    clientPrincipal: ").append(toIndentedString(clientPrincipal)).append("\n");
    sb.append("    ddnsClientUpdate: ").append(toIndentedString(ddnsClientUpdate)).append("\n");
    sb.append("    ddnsConflictResolutionMode: ").append(toIndentedString(ddnsConflictResolutionMode)).append("\n");
    sb.append("    ddnsDomain: ").append(toIndentedString(ddnsDomain)).append("\n");
    sb.append("    ddnsEnabled: ").append(toIndentedString(ddnsEnabled)).append("\n");
    sb.append("    ddnsGenerateName: ").append(toIndentedString(ddnsGenerateName)).append("\n");
    sb.append("    ddnsGeneratedPrefix: ").append(toIndentedString(ddnsGeneratedPrefix)).append("\n");
    sb.append("    ddnsSendUpdates: ").append(toIndentedString(ddnsSendUpdates)).append("\n");
    sb.append("    ddnsTtlPercent: ").append(toIndentedString(ddnsTtlPercent)).append("\n");
    sb.append("    ddnsUpdateOnRenew: ").append(toIndentedString(ddnsUpdateOnRenew)).append("\n");
    sb.append("    ddnsUseConflictResolution: ").append(toIndentedString(ddnsUseConflictResolution)).append("\n");
    sb.append("    ddnsZones: ").append(toIndentedString(ddnsZones)).append("\n");
    sb.append("    dhcpConfig: ").append(toIndentedString(dhcpConfig)).append("\n");
    sb.append("    dhcpOptions: ").append(toIndentedString(dhcpOptions)).append("\n");
    sb.append("    dhcpOptionsV6: ").append(toIndentedString(dhcpOptionsV6)).append("\n");
    sb.append("    dhcpThreshold: ").append(toIndentedString(dhcpThreshold)).append("\n");
    sb.append("    gssTsigFallback: ").append(toIndentedString(gssTsigFallback)).append("\n");
    sb.append("    headerOptionFilename: ").append(toIndentedString(headerOptionFilename)).append("\n");
    sb.append("    headerOptionServerAddress: ").append(toIndentedString(headerOptionServerAddress)).append("\n");
    sb.append("    headerOptionServerName: ").append(toIndentedString(headerOptionServerName)).append("\n");
    sb.append("    hostnameRewriteChar: ").append(toIndentedString(hostnameRewriteChar)).append("\n");
    sb.append("    hostnameRewriteEnabled: ").append(toIndentedString(hostnameRewriteEnabled)).append("\n");
    sb.append("    hostnameRewriteRegex: ").append(toIndentedString(hostnameRewriteRegex)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    kerberosKdc: ").append(toIndentedString(kerberosKdc)).append("\n");
    sb.append("    kerberosKeys: ").append(toIndentedString(kerberosKeys)).append("\n");
    sb.append("    kerberosRekeyInterval: ").append(toIndentedString(kerberosRekeyInterval)).append("\n");
    sb.append("    kerberosRetryInterval: ").append(toIndentedString(kerberosRetryInterval)).append("\n");
    sb.append("    kerberosTkeyLifetime: ").append(toIndentedString(kerberosTkeyLifetime)).append("\n");
    sb.append("    kerberosTkeyProtocol: ").append(toIndentedString(kerberosTkeyProtocol)).append("\n");
    sb.append("    loggingConfiguration: ").append(toIndentedString(loggingConfiguration)).append("\n");
    sb.append("    preferOption12: ").append(toIndentedString(preferOption12)).append("\n");
    sb.append("    removeSuffixOption81: ").append(toIndentedString(removeSuffixOption81)).append("\n");
    sb.append("    serverPrincipal: ").append(toIndentedString(serverPrincipal)).append("\n");
    sb.append("    vendorSpecificOptionOptionSpace: ").append(toIndentedString(vendorSpecificOptionOptionSpace)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("active_search_enable");
    openapiFields.add("asm_config");
    openapiFields.add("client_principal");
    openapiFields.add("ddns_client_update");
    openapiFields.add("ddns_conflict_resolution_mode");
    openapiFields.add("ddns_domain");
    openapiFields.add("ddns_enabled");
    openapiFields.add("ddns_generate_name");
    openapiFields.add("ddns_generated_prefix");
    openapiFields.add("ddns_send_updates");
    openapiFields.add("ddns_ttl_percent");
    openapiFields.add("ddns_update_on_renew");
    openapiFields.add("ddns_use_conflict_resolution");
    openapiFields.add("ddns_zones");
    openapiFields.add("dhcp_config");
    openapiFields.add("dhcp_options");
    openapiFields.add("dhcp_options_v6");
    openapiFields.add("dhcp_threshold");
    openapiFields.add("gss_tsig_fallback");
    openapiFields.add("header_option_filename");
    openapiFields.add("header_option_server_address");
    openapiFields.add("header_option_server_name");
    openapiFields.add("hostname_rewrite_char");
    openapiFields.add("hostname_rewrite_enabled");
    openapiFields.add("hostname_rewrite_regex");
    openapiFields.add("id");
    openapiFields.add("kerberos_kdc");
    openapiFields.add("kerberos_keys");
    openapiFields.add("kerberos_rekey_interval");
    openapiFields.add("kerberos_retry_interval");
    openapiFields.add("kerberos_tkey_lifetime");
    openapiFields.add("kerberos_tkey_protocol");
    openapiFields.add("logging_configuration");
    openapiFields.add("prefer_option_12");
    openapiFields.add("remove_suffix_option_81");
    openapiFields.add("server_principal");
    openapiFields.add("vendor_specific_option_option_space");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IpamsvcGlobal
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IpamsvcGlobal.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IpamsvcGlobal is not found in the empty JSON string", IpamsvcGlobal.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IpamsvcGlobal.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IpamsvcGlobal` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // validate the optional field `asm_config`
      if (jsonObj.get("asm_config") != null && !jsonObj.get("asm_config").isJsonNull()) {
        IpamsvcASMConfig.validateJsonElement(jsonObj.get("asm_config"));
      }
      if ((jsonObj.get("client_principal") != null && !jsonObj.get("client_principal").isJsonNull()) && !jsonObj.get("client_principal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `client_principal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("client_principal").toString()));
      }
      if ((jsonObj.get("ddns_client_update") != null && !jsonObj.get("ddns_client_update").isJsonNull()) && !jsonObj.get("ddns_client_update").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_client_update` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_client_update").toString()));
      }
      if ((jsonObj.get("ddns_conflict_resolution_mode") != null && !jsonObj.get("ddns_conflict_resolution_mode").isJsonNull()) && !jsonObj.get("ddns_conflict_resolution_mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_conflict_resolution_mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_conflict_resolution_mode").toString()));
      }
      if ((jsonObj.get("ddns_domain") != null && !jsonObj.get("ddns_domain").isJsonNull()) && !jsonObj.get("ddns_domain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_domain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_domain").toString()));
      }
      if ((jsonObj.get("ddns_generated_prefix") != null && !jsonObj.get("ddns_generated_prefix").isJsonNull()) && !jsonObj.get("ddns_generated_prefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_generated_prefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_generated_prefix").toString()));
      }
      if (jsonObj.get("ddns_zones") != null && !jsonObj.get("ddns_zones").isJsonNull()) {
        JsonArray jsonArrayddnsZones = jsonObj.getAsJsonArray("ddns_zones");
        if (jsonArrayddnsZones != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ddns_zones").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ddns_zones` to be an array in the JSON string but got `%s`", jsonObj.get("ddns_zones").toString()));
          }

          // validate the optional field `ddns_zones` (array)
          for (int i = 0; i < jsonArrayddnsZones.size(); i++) {
            IpamsvcDDNSZone.validateJsonElement(jsonArrayddnsZones.get(i));
          };
        }
      }
      // validate the optional field `dhcp_config`
      if (jsonObj.get("dhcp_config") != null && !jsonObj.get("dhcp_config").isJsonNull()) {
        IpamsvcDHCPConfig.validateJsonElement(jsonObj.get("dhcp_config"));
      }
      if (jsonObj.get("dhcp_options") != null && !jsonObj.get("dhcp_options").isJsonNull()) {
        JsonArray jsonArraydhcpOptions = jsonObj.getAsJsonArray("dhcp_options");
        if (jsonArraydhcpOptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dhcp_options").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dhcp_options` to be an array in the JSON string but got `%s`", jsonObj.get("dhcp_options").toString()));
          }

          // validate the optional field `dhcp_options` (array)
          for (int i = 0; i < jsonArraydhcpOptions.size(); i++) {
            IpamsvcOptionItem.validateJsonElement(jsonArraydhcpOptions.get(i));
          };
        }
      }
      if (jsonObj.get("dhcp_options_v6") != null && !jsonObj.get("dhcp_options_v6").isJsonNull()) {
        JsonArray jsonArraydhcpOptionsV6 = jsonObj.getAsJsonArray("dhcp_options_v6");
        if (jsonArraydhcpOptionsV6 != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dhcp_options_v6").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dhcp_options_v6` to be an array in the JSON string but got `%s`", jsonObj.get("dhcp_options_v6").toString()));
          }

          // validate the optional field `dhcp_options_v6` (array)
          for (int i = 0; i < jsonArraydhcpOptionsV6.size(); i++) {
            IpamsvcOptionItem.validateJsonElement(jsonArraydhcpOptionsV6.get(i));
          };
        }
      }
      // validate the optional field `dhcp_threshold`
      if (jsonObj.get("dhcp_threshold") != null && !jsonObj.get("dhcp_threshold").isJsonNull()) {
        IpamsvcDHCPUtilizationThreshold.validateJsonElement(jsonObj.get("dhcp_threshold"));
      }
      if ((jsonObj.get("header_option_filename") != null && !jsonObj.get("header_option_filename").isJsonNull()) && !jsonObj.get("header_option_filename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_filename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_filename").toString()));
      }
      if ((jsonObj.get("header_option_server_address") != null && !jsonObj.get("header_option_server_address").isJsonNull()) && !jsonObj.get("header_option_server_address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_address").toString()));
      }
      if ((jsonObj.get("header_option_server_name") != null && !jsonObj.get("header_option_server_name").isJsonNull()) && !jsonObj.get("header_option_server_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_name").toString()));
      }
      if ((jsonObj.get("hostname_rewrite_char") != null && !jsonObj.get("hostname_rewrite_char").isJsonNull()) && !jsonObj.get("hostname_rewrite_char").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname_rewrite_char` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname_rewrite_char").toString()));
      }
      if ((jsonObj.get("hostname_rewrite_regex") != null && !jsonObj.get("hostname_rewrite_regex").isJsonNull()) && !jsonObj.get("hostname_rewrite_regex").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname_rewrite_regex` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname_rewrite_regex").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("kerberos_kdc") != null && !jsonObj.get("kerberos_kdc").isJsonNull()) && !jsonObj.get("kerberos_kdc").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kerberos_kdc` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kerberos_kdc").toString()));
      }
      if (jsonObj.get("kerberos_keys") != null && !jsonObj.get("kerberos_keys").isJsonNull()) {
        JsonArray jsonArraykerberosKeys = jsonObj.getAsJsonArray("kerberos_keys");
        if (jsonArraykerberosKeys != null) {
          // ensure the json data is an array
          if (!jsonObj.get("kerberos_keys").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `kerberos_keys` to be an array in the JSON string but got `%s`", jsonObj.get("kerberos_keys").toString()));
          }

          // validate the optional field `kerberos_keys` (array)
          for (int i = 0; i < jsonArraykerberosKeys.size(); i++) {
            IpamsvcKerberosKey.validateJsonElement(jsonArraykerberosKeys.get(i));
          };
        }
      }
      if ((jsonObj.get("kerberos_tkey_protocol") != null && !jsonObj.get("kerberos_tkey_protocol").isJsonNull()) && !jsonObj.get("kerberos_tkey_protocol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kerberos_tkey_protocol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kerberos_tkey_protocol").toString()));
      }
      // validate the optional field `logging_configuration`
      if (jsonObj.get("logging_configuration") != null && !jsonObj.get("logging_configuration").isJsonNull()) {
        IpamsvcLoggingConfig.validateJsonElement(jsonObj.get("logging_configuration"));
      }
      if ((jsonObj.get("server_principal") != null && !jsonObj.get("server_principal").isJsonNull()) && !jsonObj.get("server_principal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `server_principal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("server_principal").toString()));
      }
      if ((jsonObj.get("vendor_specific_option_option_space") != null && !jsonObj.get("vendor_specific_option_option_space").isJsonNull()) && !jsonObj.get("vendor_specific_option_option_space").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vendor_specific_option_option_space` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vendor_specific_option_option_space").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IpamsvcGlobal.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IpamsvcGlobal' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IpamsvcGlobal> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IpamsvcGlobal.class));

       return (TypeAdapter<T>) new TypeAdapter<IpamsvcGlobal>() {
           @Override
           public void write(JsonWriter out, IpamsvcGlobal value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IpamsvcGlobal read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IpamsvcGlobal given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IpamsvcGlobal
   * @throws IOException if the JSON string is invalid with respect to IpamsvcGlobal
   */
  public static IpamsvcGlobal fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IpamsvcGlobal.class);
  }

  /**
   * Convert an instance of IpamsvcGlobal to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

