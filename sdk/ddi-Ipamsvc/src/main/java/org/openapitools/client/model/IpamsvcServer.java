/*
 * IP Address Management API
 * The IPAM/DHCP Application is a BloxOne DDI service providing IP address management and DHCP protocol features. The IPAM component provides visibility into and provisioning tools to manage networking spaces, monitoring and reporting of entire IP address infrastructures, and integration with DNS and DHCP protocols. The DHCP component provides DHCP protocol configuration service with on-prem host serving DHCP protocol. It is part of the full-featured, DDI cloud solution that enables customers to deploy large numbers of protocol servers to deliver DNS and DHCP throughout their enterprise network.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.IpamsvcDDNSZone;
import org.openapitools.client.model.IpamsvcDHCPConfig;
import org.openapitools.client.model.IpamsvcKerberosKey;
import org.openapitools.client.model.IpamsvcLoggingConfig;
import org.openapitools.client.model.IpamsvcOptionItem;
import org.openapitools.client.model.IpamsvcServerInheritance;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A DHCP Config Profile (_dhcp/server_) is a named configuration for specified list of hosts.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-28T12:10:31.429972+05:30[Asia/Kolkata]", comments = "Generator version: 7.12.0")
public class IpamsvcServer {
  public static final String SERIALIZED_NAME_CLIENT_PRINCIPAL = "client_principal";
  @SerializedName(SERIALIZED_NAME_CLIENT_PRINCIPAL)
  @javax.annotation.Nullable
  private String clientPrincipal;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  @javax.annotation.Nullable
  private String comment;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_DDNS_CLIENT_UPDATE = "ddns_client_update";
  @SerializedName(SERIALIZED_NAME_DDNS_CLIENT_UPDATE)
  @javax.annotation.Nullable
  private String ddnsClientUpdate;

  public static final String SERIALIZED_NAME_DDNS_CONFLICT_RESOLUTION_MODE = "ddns_conflict_resolution_mode";
  @SerializedName(SERIALIZED_NAME_DDNS_CONFLICT_RESOLUTION_MODE)
  @javax.annotation.Nullable
  private String ddnsConflictResolutionMode;

  public static final String SERIALIZED_NAME_DDNS_DOMAIN = "ddns_domain";
  @SerializedName(SERIALIZED_NAME_DDNS_DOMAIN)
  @javax.annotation.Nullable
  private String ddnsDomain;

  public static final String SERIALIZED_NAME_DDNS_ENABLED = "ddns_enabled";
  @SerializedName(SERIALIZED_NAME_DDNS_ENABLED)
  @javax.annotation.Nullable
  private Boolean ddnsEnabled;

  public static final String SERIALIZED_NAME_DDNS_GENERATE_NAME = "ddns_generate_name";
  @SerializedName(SERIALIZED_NAME_DDNS_GENERATE_NAME)
  @javax.annotation.Nullable
  private Boolean ddnsGenerateName;

  public static final String SERIALIZED_NAME_DDNS_GENERATED_PREFIX = "ddns_generated_prefix";
  @SerializedName(SERIALIZED_NAME_DDNS_GENERATED_PREFIX)
  @javax.annotation.Nullable
  private String ddnsGeneratedPrefix;

  public static final String SERIALIZED_NAME_DDNS_SEND_UPDATES = "ddns_send_updates";
  @SerializedName(SERIALIZED_NAME_DDNS_SEND_UPDATES)
  @javax.annotation.Nullable
  private Boolean ddnsSendUpdates;

  public static final String SERIALIZED_NAME_DDNS_TTL_PERCENT = "ddns_ttl_percent";
  @SerializedName(SERIALIZED_NAME_DDNS_TTL_PERCENT)
  @javax.annotation.Nullable
  private Float ddnsTtlPercent;

  public static final String SERIALIZED_NAME_DDNS_UPDATE_ON_RENEW = "ddns_update_on_renew";
  @SerializedName(SERIALIZED_NAME_DDNS_UPDATE_ON_RENEW)
  @javax.annotation.Nullable
  private Boolean ddnsUpdateOnRenew;

  public static final String SERIALIZED_NAME_DDNS_USE_CONFLICT_RESOLUTION = "ddns_use_conflict_resolution";
  @SerializedName(SERIALIZED_NAME_DDNS_USE_CONFLICT_RESOLUTION)
  @javax.annotation.Nullable
  private Boolean ddnsUseConflictResolution;

  public static final String SERIALIZED_NAME_DDNS_ZONES = "ddns_zones";
  @SerializedName(SERIALIZED_NAME_DDNS_ZONES)
  @javax.annotation.Nullable
  private List<IpamsvcDDNSZone> ddnsZones = new ArrayList<>();

  public static final String SERIALIZED_NAME_DHCP_CONFIG = "dhcp_config";
  @SerializedName(SERIALIZED_NAME_DHCP_CONFIG)
  @javax.annotation.Nullable
  private IpamsvcDHCPConfig dhcpConfig;

  public static final String SERIALIZED_NAME_DHCP_OPTIONS = "dhcp_options";
  @SerializedName(SERIALIZED_NAME_DHCP_OPTIONS)
  @javax.annotation.Nullable
  private List<IpamsvcOptionItem> dhcpOptions = new ArrayList<>();

  public static final String SERIALIZED_NAME_DHCP_OPTIONS_V6 = "dhcp_options_v6";
  @SerializedName(SERIALIZED_NAME_DHCP_OPTIONS_V6)
  @javax.annotation.Nullable
  private List<IpamsvcOptionItem> dhcpOptionsV6 = new ArrayList<>();

  public static final String SERIALIZED_NAME_GSS_TSIG_FALLBACK = "gss_tsig_fallback";
  @SerializedName(SERIALIZED_NAME_GSS_TSIG_FALLBACK)
  @javax.annotation.Nullable
  private Boolean gssTsigFallback;

  public static final String SERIALIZED_NAME_HEADER_OPTION_FILENAME = "header_option_filename";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_FILENAME)
  @javax.annotation.Nullable
  private String headerOptionFilename;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS = "header_option_server_address";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_ADDRESS)
  @javax.annotation.Nullable
  private String headerOptionServerAddress;

  public static final String SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME = "header_option_server_name";
  @SerializedName(SERIALIZED_NAME_HEADER_OPTION_SERVER_NAME)
  @javax.annotation.Nullable
  private String headerOptionServerName;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_CHAR = "hostname_rewrite_char";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_CHAR)
  @javax.annotation.Nullable
  private String hostnameRewriteChar;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_ENABLED = "hostname_rewrite_enabled";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_ENABLED)
  @javax.annotation.Nullable
  private Boolean hostnameRewriteEnabled;

  public static final String SERIALIZED_NAME_HOSTNAME_REWRITE_REGEX = "hostname_rewrite_regex";
  @SerializedName(SERIALIZED_NAME_HOSTNAME_REWRITE_REGEX)
  @javax.annotation.Nullable
  private String hostnameRewriteRegex;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nullable
  private String id;

  public static final String SERIALIZED_NAME_INHERITANCE_SOURCES = "inheritance_sources";
  @SerializedName(SERIALIZED_NAME_INHERITANCE_SOURCES)
  @javax.annotation.Nullable
  private IpamsvcServerInheritance inheritanceSources;

  public static final String SERIALIZED_NAME_KERBEROS_KDC = "kerberos_kdc";
  @SerializedName(SERIALIZED_NAME_KERBEROS_KDC)
  @javax.annotation.Nullable
  private String kerberosKdc;

  public static final String SERIALIZED_NAME_KERBEROS_KEYS = "kerberos_keys";
  @SerializedName(SERIALIZED_NAME_KERBEROS_KEYS)
  @javax.annotation.Nullable
  private List<IpamsvcKerberosKey> kerberosKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_KERBEROS_REKEY_INTERVAL = "kerberos_rekey_interval";
  @SerializedName(SERIALIZED_NAME_KERBEROS_REKEY_INTERVAL)
  @javax.annotation.Nullable
  private Long kerberosRekeyInterval;

  public static final String SERIALIZED_NAME_KERBEROS_RETRY_INTERVAL = "kerberos_retry_interval";
  @SerializedName(SERIALIZED_NAME_KERBEROS_RETRY_INTERVAL)
  @javax.annotation.Nullable
  private Long kerberosRetryInterval;

  public static final String SERIALIZED_NAME_KERBEROS_TKEY_LIFETIME = "kerberos_tkey_lifetime";
  @SerializedName(SERIALIZED_NAME_KERBEROS_TKEY_LIFETIME)
  @javax.annotation.Nullable
  private Long kerberosTkeyLifetime;

  public static final String SERIALIZED_NAME_KERBEROS_TKEY_PROTOCOL = "kerberos_tkey_protocol";
  @SerializedName(SERIALIZED_NAME_KERBEROS_TKEY_PROTOCOL)
  @javax.annotation.Nullable
  private String kerberosTkeyProtocol;

  public static final String SERIALIZED_NAME_LOGGING_CONFIGURATION = "logging_configuration";
  @SerializedName(SERIALIZED_NAME_LOGGING_CONFIGURATION)
  @javax.annotation.Nullable
  private IpamsvcLoggingConfig loggingConfiguration;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nonnull
  private String name;

  public static final String SERIALIZED_NAME_PROFILE_TYPE = "profile_type";
  @SerializedName(SERIALIZED_NAME_PROFILE_TYPE)
  @javax.annotation.Nullable
  private String profileType;

  public static final String SERIALIZED_NAME_SERVER_PRINCIPAL = "server_principal";
  @SerializedName(SERIALIZED_NAME_SERVER_PRINCIPAL)
  @javax.annotation.Nullable
  private String serverPrincipal;

  public static final String SERIALIZED_NAME_TAGS = "tags";
  @SerializedName(SERIALIZED_NAME_TAGS)
  @javax.annotation.Nullable
  private Object tags;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_VENDOR_SPECIFIC_OPTION_OPTION_SPACE = "vendor_specific_option_option_space";
  @SerializedName(SERIALIZED_NAME_VENDOR_SPECIFIC_OPTION_OPTION_SPACE)
  @javax.annotation.Nullable
  private String vendorSpecificOptionOptionSpace;

  public IpamsvcServer() {
  }

  public IpamsvcServer(
     OffsetDateTime createdAt, 
     String id, 
     OffsetDateTime updatedAt
  ) {
    this();
    this.createdAt = createdAt;
    this.id = id;
    this.updatedAt = updatedAt;
  }

  public IpamsvcServer clientPrincipal(@javax.annotation.Nullable String clientPrincipal) {
    this.clientPrincipal = clientPrincipal;
    return this;
  }

  /**
   * The Kerberos principal name. It uses the typical Kerberos notation: &lt;SERVICE-NAME&gt;/&lt;server-domain-name&gt;@&lt;REALM&gt;.  Defaults to empty.
   * @return clientPrincipal
   */
  @javax.annotation.Nullable
  public String getClientPrincipal() {
    return clientPrincipal;
  }

  public void setClientPrincipal(@javax.annotation.Nullable String clientPrincipal) {
    this.clientPrincipal = clientPrincipal;
  }


  public IpamsvcServer comment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * The description for the DHCP Config Profile. May contain 0 to 1024 characters. Can include UTF-8.
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
  }


  /**
   * Time when the object has been created.
   * @return createdAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }



  public IpamsvcServer ddnsClientUpdate(@javax.annotation.Nullable String ddnsClientUpdate) {
    this.ddnsClientUpdate = ddnsClientUpdate;
    return this;
  }

  /**
   * Controls who does the DDNS updates.  Valid values are: * _client_: DHCP server updates DNS if requested by client. * _server_: DHCP server always updates DNS, overriding an update request from the client, unless the client requests no updates. * _ignore_: DHCP server always updates DNS, even if the client says not to. * _over_client_update_: Same as _server_. DHCP server always updates DNS, overriding an update request from the client, unless the client requests no updates. * _over_no_update_: DHCP server updates DNS even if the client requests that no updates be done. If the client requests to do the update, DHCP server allows it.  Defaults to _client_.
   * @return ddnsClientUpdate
   */
  @javax.annotation.Nullable
  public String getDdnsClientUpdate() {
    return ddnsClientUpdate;
  }

  public void setDdnsClientUpdate(@javax.annotation.Nullable String ddnsClientUpdate) {
    this.ddnsClientUpdate = ddnsClientUpdate;
  }


  public IpamsvcServer ddnsConflictResolutionMode(@javax.annotation.Nullable String ddnsConflictResolutionMode) {
    this.ddnsConflictResolutionMode = ddnsConflictResolutionMode;
    return this;
  }

  /**
   * The mode used for resolving conflicts while performing DDNS updates.  Valid values are: * _check_with_dhcid_: It includes adding a DHCID record and checking that record via conflict detection as per RFC 4703. * _no_check_with_dhcid_: This will ignore conflict detection but add a DHCID record when creating/updating an entry. * _check_exists_with_dhcid_: This will check if there is an existing DHCID record but does not verify the value of the record matches the update. This will also update the DHCID record for the entry. * _no_check_without_dhcid_: This ignores conflict detection and will not add a DHCID record when creating/updating a DDNS entry.  Defaults to _check_with_dhcid_.
   * @return ddnsConflictResolutionMode
   */
  @javax.annotation.Nullable
  public String getDdnsConflictResolutionMode() {
    return ddnsConflictResolutionMode;
  }

  public void setDdnsConflictResolutionMode(@javax.annotation.Nullable String ddnsConflictResolutionMode) {
    this.ddnsConflictResolutionMode = ddnsConflictResolutionMode;
  }


  public IpamsvcServer ddnsDomain(@javax.annotation.Nullable String ddnsDomain) {
    this.ddnsDomain = ddnsDomain;
    return this;
  }

  /**
   * The domain suffix for DDNS updates. FQDN, may be empty.  Required if _ddns_enabled_ is true.  Defaults to empty.
   * @return ddnsDomain
   */
  @javax.annotation.Nullable
  public String getDdnsDomain() {
    return ddnsDomain;
  }

  public void setDdnsDomain(@javax.annotation.Nullable String ddnsDomain) {
    this.ddnsDomain = ddnsDomain;
  }


  public IpamsvcServer ddnsEnabled(@javax.annotation.Nullable Boolean ddnsEnabled) {
    this.ddnsEnabled = ddnsEnabled;
    return this;
  }

  /**
   * Indicates if DDNS updates should be performed for leases. All other _ddns_*_ configuration is ignored when this flag is unset.  At a minimum, _ddns_domain_ and _ddns_zones_ must be configured to enable DDNS.  Defaults to _false_.
   * @return ddnsEnabled
   */
  @javax.annotation.Nullable
  public Boolean getDdnsEnabled() {
    return ddnsEnabled;
  }

  public void setDdnsEnabled(@javax.annotation.Nullable Boolean ddnsEnabled) {
    this.ddnsEnabled = ddnsEnabled;
  }


  public IpamsvcServer ddnsGenerateName(@javax.annotation.Nullable Boolean ddnsGenerateName) {
    this.ddnsGenerateName = ddnsGenerateName;
    return this;
  }

  /**
   * Indicates if DDNS should generate a hostname when not supplied by the client.  Defaults to _false_.
   * @return ddnsGenerateName
   */
  @javax.annotation.Nullable
  public Boolean getDdnsGenerateName() {
    return ddnsGenerateName;
  }

  public void setDdnsGenerateName(@javax.annotation.Nullable Boolean ddnsGenerateName) {
    this.ddnsGenerateName = ddnsGenerateName;
  }


  public IpamsvcServer ddnsGeneratedPrefix(@javax.annotation.Nullable String ddnsGeneratedPrefix) {
    this.ddnsGeneratedPrefix = ddnsGeneratedPrefix;
    return this;
  }

  /**
   * The prefix used in the generation of an FQDN.  When generating a name, DHCP server will construct the name in the format: [ddns-generated-prefix]-[address-text].[ddns-qualifying-suffix]. where address-text is simply the lease IP address converted to a hyphenated string.  Defaults to \&quot;myhost\&quot;.
   * @return ddnsGeneratedPrefix
   */
  @javax.annotation.Nullable
  public String getDdnsGeneratedPrefix() {
    return ddnsGeneratedPrefix;
  }

  public void setDdnsGeneratedPrefix(@javax.annotation.Nullable String ddnsGeneratedPrefix) {
    this.ddnsGeneratedPrefix = ddnsGeneratedPrefix;
  }


  public IpamsvcServer ddnsSendUpdates(@javax.annotation.Nullable Boolean ddnsSendUpdates) {
    this.ddnsSendUpdates = ddnsSendUpdates;
    return this;
  }

  /**
   * Determines if DDNS updates are enabled at the server level. Defaults to _true_.
   * @return ddnsSendUpdates
   */
  @javax.annotation.Nullable
  public Boolean getDdnsSendUpdates() {
    return ddnsSendUpdates;
  }

  public void setDdnsSendUpdates(@javax.annotation.Nullable Boolean ddnsSendUpdates) {
    this.ddnsSendUpdates = ddnsSendUpdates;
  }


  public IpamsvcServer ddnsTtlPercent(@javax.annotation.Nullable Float ddnsTtlPercent) {
    this.ddnsTtlPercent = ddnsTtlPercent;
    return this;
  }

  /**
   * DDNS TTL value - to be calculated as a simple percentage of the lease&#39;s lifetime, using the parameter&#39;s value as the percentage. It is specified as a percentage (e.g. 25, 75). Defaults to unspecified.
   * @return ddnsTtlPercent
   */
  @javax.annotation.Nullable
  public Float getDdnsTtlPercent() {
    return ddnsTtlPercent;
  }

  public void setDdnsTtlPercent(@javax.annotation.Nullable Float ddnsTtlPercent) {
    this.ddnsTtlPercent = ddnsTtlPercent;
  }


  public IpamsvcServer ddnsUpdateOnRenew(@javax.annotation.Nullable Boolean ddnsUpdateOnRenew) {
    this.ddnsUpdateOnRenew = ddnsUpdateOnRenew;
    return this;
  }

  /**
   * Instructs the DHCP server to always update the DNS information when a lease is renewed even if its DNS information has not changed.  Defaults to _false_.
   * @return ddnsUpdateOnRenew
   */
  @javax.annotation.Nullable
  public Boolean getDdnsUpdateOnRenew() {
    return ddnsUpdateOnRenew;
  }

  public void setDdnsUpdateOnRenew(@javax.annotation.Nullable Boolean ddnsUpdateOnRenew) {
    this.ddnsUpdateOnRenew = ddnsUpdateOnRenew;
  }


  public IpamsvcServer ddnsUseConflictResolution(@javax.annotation.Nullable Boolean ddnsUseConflictResolution) {
    this.ddnsUseConflictResolution = ddnsUseConflictResolution;
    return this;
  }

  /**
   * When true, DHCP server will apply conflict resolution, as described in RFC 4703, when attempting to fulfill the update request.  When false, DHCP server will simply attempt to update the DNS entries per the request, regardless of whether or not they conflict with existing entries owned by other DHCP4 clients.  Defaults to _true_.
   * @return ddnsUseConflictResolution
   */
  @javax.annotation.Nullable
  public Boolean getDdnsUseConflictResolution() {
    return ddnsUseConflictResolution;
  }

  public void setDdnsUseConflictResolution(@javax.annotation.Nullable Boolean ddnsUseConflictResolution) {
    this.ddnsUseConflictResolution = ddnsUseConflictResolution;
  }


  public IpamsvcServer ddnsZones(@javax.annotation.Nullable List<IpamsvcDDNSZone> ddnsZones) {
    this.ddnsZones = ddnsZones;
    return this;
  }

  public IpamsvcServer addDdnsZonesItem(IpamsvcDDNSZone ddnsZonesItem) {
    if (this.ddnsZones == null) {
      this.ddnsZones = new ArrayList<>();
    }
    this.ddnsZones.add(ddnsZonesItem);
    return this;
  }

  /**
   * The DNS zones that DDNS updates can be sent to. There is no resolver fallback. The target zone must be explicitly configured for the update to be performed.  Updates are sent to the closest enclosing zone.  Error if _ddns_enabled_ is _true_ and the _ddns_domain_ does not have a corresponding entry in _ddns_zones_.  Error if there are items with duplicate zone in the list.  Defaults to empty list.
   * @return ddnsZones
   */
  @javax.annotation.Nullable
  public List<IpamsvcDDNSZone> getDdnsZones() {
    return ddnsZones;
  }

  public void setDdnsZones(@javax.annotation.Nullable List<IpamsvcDDNSZone> ddnsZones) {
    this.ddnsZones = ddnsZones;
  }


  public IpamsvcServer dhcpConfig(@javax.annotation.Nullable IpamsvcDHCPConfig dhcpConfig) {
    this.dhcpConfig = dhcpConfig;
    return this;
  }

  /**
   * Get dhcpConfig
   * @return dhcpConfig
   */
  @javax.annotation.Nullable
  public IpamsvcDHCPConfig getDhcpConfig() {
    return dhcpConfig;
  }

  public void setDhcpConfig(@javax.annotation.Nullable IpamsvcDHCPConfig dhcpConfig) {
    this.dhcpConfig = dhcpConfig;
  }


  public IpamsvcServer dhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
    return this;
  }

  public IpamsvcServer addDhcpOptionsItem(IpamsvcOptionItem dhcpOptionsItem) {
    if (this.dhcpOptions == null) {
      this.dhcpOptions = new ArrayList<>();
    }
    this.dhcpOptions.add(dhcpOptionsItem);
    return this;
  }

  /**
   * The list of DHCP options or group of options for IPv4. An option list is ordered and may include both option groups and specific options. Multiple occurences of the same option or group is not an error. The last occurence of an option in the list will be used.  Error if the graph of referenced groups contains cycles.  Defaults to empty list.
   * @return dhcpOptions
   */
  @javax.annotation.Nullable
  public List<IpamsvcOptionItem> getDhcpOptions() {
    return dhcpOptions;
  }

  public void setDhcpOptions(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptions) {
    this.dhcpOptions = dhcpOptions;
  }


  public IpamsvcServer dhcpOptionsV6(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptionsV6) {
    this.dhcpOptionsV6 = dhcpOptionsV6;
    return this;
  }

  public IpamsvcServer addDhcpOptionsV6Item(IpamsvcOptionItem dhcpOptionsV6Item) {
    if (this.dhcpOptionsV6 == null) {
      this.dhcpOptionsV6 = new ArrayList<>();
    }
    this.dhcpOptionsV6.add(dhcpOptionsV6Item);
    return this;
  }

  /**
   * The list of DHCP options or group of options for IPv6. An option list is ordered and may include both option groups and specific options. Multiple occurences of the same option or group is not an error. The last occurence of an option in the list will be used.  Error if the graph of referenced groups contains cycles.  Defaults to empty list.
   * @return dhcpOptionsV6
   */
  @javax.annotation.Nullable
  public List<IpamsvcOptionItem> getDhcpOptionsV6() {
    return dhcpOptionsV6;
  }

  public void setDhcpOptionsV6(@javax.annotation.Nullable List<IpamsvcOptionItem> dhcpOptionsV6) {
    this.dhcpOptionsV6 = dhcpOptionsV6;
  }


  public IpamsvcServer gssTsigFallback(@javax.annotation.Nullable Boolean gssTsigFallback) {
    this.gssTsigFallback = gssTsigFallback;
    return this;
  }

  /**
   * The behavior when GSS-TSIG should be used (a matching external DNS server is configured) but no GSS-TSIG key is available. If configured to _false_ (the default) this DNS server is skipped, if configured to _true_ the DNS server is ignored and the DNS update is sent with the configured DHCP-DDNS protection e.g. TSIG key or without any protection when none was configured.  Defaults to _false_.
   * @return gssTsigFallback
   */
  @javax.annotation.Nullable
  public Boolean getGssTsigFallback() {
    return gssTsigFallback;
  }

  public void setGssTsigFallback(@javax.annotation.Nullable Boolean gssTsigFallback) {
    this.gssTsigFallback = gssTsigFallback;
  }


  public IpamsvcServer headerOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
    return this;
  }

  /**
   * The configuration for header option filename field.
   * @return headerOptionFilename
   */
  @javax.annotation.Nullable
  public String getHeaderOptionFilename() {
    return headerOptionFilename;
  }

  public void setHeaderOptionFilename(@javax.annotation.Nullable String headerOptionFilename) {
    this.headerOptionFilename = headerOptionFilename;
  }


  public IpamsvcServer headerOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
    return this;
  }

  /**
   * The configuration for header option server address field.
   * @return headerOptionServerAddress
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerAddress() {
    return headerOptionServerAddress;
  }

  public void setHeaderOptionServerAddress(@javax.annotation.Nullable String headerOptionServerAddress) {
    this.headerOptionServerAddress = headerOptionServerAddress;
  }


  public IpamsvcServer headerOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
    return this;
  }

  /**
   * The configuration for header option server name field.
   * @return headerOptionServerName
   */
  @javax.annotation.Nullable
  public String getHeaderOptionServerName() {
    return headerOptionServerName;
  }

  public void setHeaderOptionServerName(@javax.annotation.Nullable String headerOptionServerName) {
    this.headerOptionServerName = headerOptionServerName;
  }


  public IpamsvcServer hostnameRewriteChar(@javax.annotation.Nullable String hostnameRewriteChar) {
    this.hostnameRewriteChar = hostnameRewriteChar;
    return this;
  }

  /**
   * The character to replace non-matching characters with, when hostname rewrite is enabled.  Any single ASCII character or no character if the invalid characters should be removed without replacement.  Defaults to \&quot;-\&quot;.
   * @return hostnameRewriteChar
   */
  @javax.annotation.Nullable
  public String getHostnameRewriteChar() {
    return hostnameRewriteChar;
  }

  public void setHostnameRewriteChar(@javax.annotation.Nullable String hostnameRewriteChar) {
    this.hostnameRewriteChar = hostnameRewriteChar;
  }


  public IpamsvcServer hostnameRewriteEnabled(@javax.annotation.Nullable Boolean hostnameRewriteEnabled) {
    this.hostnameRewriteEnabled = hostnameRewriteEnabled;
    return this;
  }

  /**
   * Indicates if client supplied hostnames will be rewritten prior to DDNS update by replacing every character that does not match _hostname_rewrite_regex_ by _hostname_rewrite_char_.  Defaults to _false_.
   * @return hostnameRewriteEnabled
   */
  @javax.annotation.Nullable
  public Boolean getHostnameRewriteEnabled() {
    return hostnameRewriteEnabled;
  }

  public void setHostnameRewriteEnabled(@javax.annotation.Nullable Boolean hostnameRewriteEnabled) {
    this.hostnameRewriteEnabled = hostnameRewriteEnabled;
  }


  public IpamsvcServer hostnameRewriteRegex(@javax.annotation.Nullable String hostnameRewriteRegex) {
    this.hostnameRewriteRegex = hostnameRewriteRegex;
    return this;
  }

  /**
   * The regex bracket expression to match valid characters.  Must begin with \&quot;[\&quot; and end with \&quot;]\&quot; and be a compilable POSIX regex.  Defaults to \&quot;[^a-zA-Z0-9_.]\&quot;.
   * @return hostnameRewriteRegex
   */
  @javax.annotation.Nullable
  public String getHostnameRewriteRegex() {
    return hostnameRewriteRegex;
  }

  public void setHostnameRewriteRegex(@javax.annotation.Nullable String hostnameRewriteRegex) {
    this.hostnameRewriteRegex = hostnameRewriteRegex;
  }


  /**
   * The resource identifier.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public IpamsvcServer inheritanceSources(@javax.annotation.Nullable IpamsvcServerInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
    return this;
  }

  /**
   * Get inheritanceSources
   * @return inheritanceSources
   */
  @javax.annotation.Nullable
  public IpamsvcServerInheritance getInheritanceSources() {
    return inheritanceSources;
  }

  public void setInheritanceSources(@javax.annotation.Nullable IpamsvcServerInheritance inheritanceSources) {
    this.inheritanceSources = inheritanceSources;
  }


  public IpamsvcServer kerberosKdc(@javax.annotation.Nullable String kerberosKdc) {
    this.kerberosKdc = kerberosKdc;
    return this;
  }

  /**
   * Address of Kerberos Key Distribution Center.  Defaults to empty.
   * @return kerberosKdc
   */
  @javax.annotation.Nullable
  public String getKerberosKdc() {
    return kerberosKdc;
  }

  public void setKerberosKdc(@javax.annotation.Nullable String kerberosKdc) {
    this.kerberosKdc = kerberosKdc;
  }


  public IpamsvcServer kerberosKeys(@javax.annotation.Nullable List<IpamsvcKerberosKey> kerberosKeys) {
    this.kerberosKeys = kerberosKeys;
    return this;
  }

  public IpamsvcServer addKerberosKeysItem(IpamsvcKerberosKey kerberosKeysItem) {
    if (this.kerberosKeys == null) {
      this.kerberosKeys = new ArrayList<>();
    }
    this.kerberosKeys.add(kerberosKeysItem);
    return this;
  }

  /**
   * _kerberos_keys_ contains a list of keys for GSS-TSIG signed dynamic updates.  Defaults to empty.
   * @return kerberosKeys
   */
  @javax.annotation.Nullable
  public List<IpamsvcKerberosKey> getKerberosKeys() {
    return kerberosKeys;
  }

  public void setKerberosKeys(@javax.annotation.Nullable List<IpamsvcKerberosKey> kerberosKeys) {
    this.kerberosKeys = kerberosKeys;
  }


  public IpamsvcServer kerberosRekeyInterval(@javax.annotation.Nullable Long kerberosRekeyInterval) {
    this.kerberosRekeyInterval = kerberosRekeyInterval;
    return this;
  }

  /**
   * Time interval (in seconds) the keys for each configured external DNS server are checked for rekeying, i.e. a new key is created to replace the current usable one when its age is greater than the _kerberos_rekey_interval_ value.  Defaults to 120 seconds.
   * @return kerberosRekeyInterval
   */
  @javax.annotation.Nullable
  public Long getKerberosRekeyInterval() {
    return kerberosRekeyInterval;
  }

  public void setKerberosRekeyInterval(@javax.annotation.Nullable Long kerberosRekeyInterval) {
    this.kerberosRekeyInterval = kerberosRekeyInterval;
  }


  public IpamsvcServer kerberosRetryInterval(@javax.annotation.Nullable Long kerberosRetryInterval) {
    this.kerberosRetryInterval = kerberosRetryInterval;
    return this;
  }

  /**
   * Time interval (in seconds) to retry to create a key if any error occurred previously for any configured external DNS server.  Defaults to 30 seconds.
   * @return kerberosRetryInterval
   */
  @javax.annotation.Nullable
  public Long getKerberosRetryInterval() {
    return kerberosRetryInterval;
  }

  public void setKerberosRetryInterval(@javax.annotation.Nullable Long kerberosRetryInterval) {
    this.kerberosRetryInterval = kerberosRetryInterval;
  }


  public IpamsvcServer kerberosTkeyLifetime(@javax.annotation.Nullable Long kerberosTkeyLifetime) {
    this.kerberosTkeyLifetime = kerberosTkeyLifetime;
    return this;
  }

  /**
   * Lifetime (in seconds) of GSS-TSIG keys in the TKEY protocol.  Defaults to 160 seconds.
   * @return kerberosTkeyLifetime
   */
  @javax.annotation.Nullable
  public Long getKerberosTkeyLifetime() {
    return kerberosTkeyLifetime;
  }

  public void setKerberosTkeyLifetime(@javax.annotation.Nullable Long kerberosTkeyLifetime) {
    this.kerberosTkeyLifetime = kerberosTkeyLifetime;
  }


  public IpamsvcServer kerberosTkeyProtocol(@javax.annotation.Nullable String kerberosTkeyProtocol) {
    this.kerberosTkeyProtocol = kerberosTkeyProtocol;
    return this;
  }

  /**
   * Determines which protocol is used to establish the security context with the external DNS servers, TCP or UDP.  Defaults to _tcp_.
   * @return kerberosTkeyProtocol
   */
  @javax.annotation.Nullable
  public String getKerberosTkeyProtocol() {
    return kerberosTkeyProtocol;
  }

  public void setKerberosTkeyProtocol(@javax.annotation.Nullable String kerberosTkeyProtocol) {
    this.kerberosTkeyProtocol = kerberosTkeyProtocol;
  }


  public IpamsvcServer loggingConfiguration(@javax.annotation.Nullable IpamsvcLoggingConfig loggingConfiguration) {
    this.loggingConfiguration = loggingConfiguration;
    return this;
  }

  /**
   * Get loggingConfiguration
   * @return loggingConfiguration
   */
  @javax.annotation.Nullable
  public IpamsvcLoggingConfig getLoggingConfiguration() {
    return loggingConfiguration;
  }

  public void setLoggingConfiguration(@javax.annotation.Nullable IpamsvcLoggingConfig loggingConfiguration) {
    this.loggingConfiguration = loggingConfiguration;
  }


  public IpamsvcServer name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the DHCP Config Profile. Must contain 1 to 256 characters. Can include UTF-8.
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public IpamsvcServer profileType(@javax.annotation.Nullable String profileType) {
    this.profileType = profileType;
    return this;
  }

  /**
   * The type of server object.  Defaults to _server_.  Valid values are: * _server_: The server profile type. * _subnet_: The subnet profile type.
   * @return profileType
   */
  @javax.annotation.Nullable
  public String getProfileType() {
    return profileType;
  }

  public void setProfileType(@javax.annotation.Nullable String profileType) {
    this.profileType = profileType;
  }


  public IpamsvcServer serverPrincipal(@javax.annotation.Nullable String serverPrincipal) {
    this.serverPrincipal = serverPrincipal;
    return this;
  }

  /**
   * The Kerberos principal name of the external DNS server that will receive updates.  Defaults to empty.
   * @return serverPrincipal
   */
  @javax.annotation.Nullable
  public String getServerPrincipal() {
    return serverPrincipal;
  }

  public void setServerPrincipal(@javax.annotation.Nullable String serverPrincipal) {
    this.serverPrincipal = serverPrincipal;
  }


  public IpamsvcServer tags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
    return this;
  }

  /**
   * The tags for the DHCP Config Profile in JSON format.
   * @return tags
   */
  @javax.annotation.Nullable
  public Object getTags() {
    return tags;
  }

  public void setTags(@javax.annotation.Nullable Object tags) {
    this.tags = tags;
  }


  /**
   * Time when the object has been updated. Equals to _created_at_ if not updated after creation.
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }



  public IpamsvcServer vendorSpecificOptionOptionSpace(@javax.annotation.Nullable String vendorSpecificOptionOptionSpace) {
    this.vendorSpecificOptionOptionSpace = vendorSpecificOptionOptionSpace;
    return this;
  }

  /**
   * The resource identifier.
   * @return vendorSpecificOptionOptionSpace
   */
  @javax.annotation.Nullable
  public String getVendorSpecificOptionOptionSpace() {
    return vendorSpecificOptionOptionSpace;
  }

  public void setVendorSpecificOptionOptionSpace(@javax.annotation.Nullable String vendorSpecificOptionOptionSpace) {
    this.vendorSpecificOptionOptionSpace = vendorSpecificOptionOptionSpace;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IpamsvcServer ipamsvcServer = (IpamsvcServer) o;
    return Objects.equals(this.clientPrincipal, ipamsvcServer.clientPrincipal) &&
        Objects.equals(this.comment, ipamsvcServer.comment) &&
        Objects.equals(this.createdAt, ipamsvcServer.createdAt) &&
        Objects.equals(this.ddnsClientUpdate, ipamsvcServer.ddnsClientUpdate) &&
        Objects.equals(this.ddnsConflictResolutionMode, ipamsvcServer.ddnsConflictResolutionMode) &&
        Objects.equals(this.ddnsDomain, ipamsvcServer.ddnsDomain) &&
        Objects.equals(this.ddnsEnabled, ipamsvcServer.ddnsEnabled) &&
        Objects.equals(this.ddnsGenerateName, ipamsvcServer.ddnsGenerateName) &&
        Objects.equals(this.ddnsGeneratedPrefix, ipamsvcServer.ddnsGeneratedPrefix) &&
        Objects.equals(this.ddnsSendUpdates, ipamsvcServer.ddnsSendUpdates) &&
        Objects.equals(this.ddnsTtlPercent, ipamsvcServer.ddnsTtlPercent) &&
        Objects.equals(this.ddnsUpdateOnRenew, ipamsvcServer.ddnsUpdateOnRenew) &&
        Objects.equals(this.ddnsUseConflictResolution, ipamsvcServer.ddnsUseConflictResolution) &&
        Objects.equals(this.ddnsZones, ipamsvcServer.ddnsZones) &&
        Objects.equals(this.dhcpConfig, ipamsvcServer.dhcpConfig) &&
        Objects.equals(this.dhcpOptions, ipamsvcServer.dhcpOptions) &&
        Objects.equals(this.dhcpOptionsV6, ipamsvcServer.dhcpOptionsV6) &&
        Objects.equals(this.gssTsigFallback, ipamsvcServer.gssTsigFallback) &&
        Objects.equals(this.headerOptionFilename, ipamsvcServer.headerOptionFilename) &&
        Objects.equals(this.headerOptionServerAddress, ipamsvcServer.headerOptionServerAddress) &&
        Objects.equals(this.headerOptionServerName, ipamsvcServer.headerOptionServerName) &&
        Objects.equals(this.hostnameRewriteChar, ipamsvcServer.hostnameRewriteChar) &&
        Objects.equals(this.hostnameRewriteEnabled, ipamsvcServer.hostnameRewriteEnabled) &&
        Objects.equals(this.hostnameRewriteRegex, ipamsvcServer.hostnameRewriteRegex) &&
        Objects.equals(this.id, ipamsvcServer.id) &&
        Objects.equals(this.inheritanceSources, ipamsvcServer.inheritanceSources) &&
        Objects.equals(this.kerberosKdc, ipamsvcServer.kerberosKdc) &&
        Objects.equals(this.kerberosKeys, ipamsvcServer.kerberosKeys) &&
        Objects.equals(this.kerberosRekeyInterval, ipamsvcServer.kerberosRekeyInterval) &&
        Objects.equals(this.kerberosRetryInterval, ipamsvcServer.kerberosRetryInterval) &&
        Objects.equals(this.kerberosTkeyLifetime, ipamsvcServer.kerberosTkeyLifetime) &&
        Objects.equals(this.kerberosTkeyProtocol, ipamsvcServer.kerberosTkeyProtocol) &&
        Objects.equals(this.loggingConfiguration, ipamsvcServer.loggingConfiguration) &&
        Objects.equals(this.name, ipamsvcServer.name) &&
        Objects.equals(this.profileType, ipamsvcServer.profileType) &&
        Objects.equals(this.serverPrincipal, ipamsvcServer.serverPrincipal) &&
        Objects.equals(this.tags, ipamsvcServer.tags) &&
        Objects.equals(this.updatedAt, ipamsvcServer.updatedAt) &&
        Objects.equals(this.vendorSpecificOptionOptionSpace, ipamsvcServer.vendorSpecificOptionOptionSpace);
  }

  @Override
  public int hashCode() {
    return Objects.hash(clientPrincipal, comment, createdAt, ddnsClientUpdate, ddnsConflictResolutionMode, ddnsDomain, ddnsEnabled, ddnsGenerateName, ddnsGeneratedPrefix, ddnsSendUpdates, ddnsTtlPercent, ddnsUpdateOnRenew, ddnsUseConflictResolution, ddnsZones, dhcpConfig, dhcpOptions, dhcpOptionsV6, gssTsigFallback, headerOptionFilename, headerOptionServerAddress, headerOptionServerName, hostnameRewriteChar, hostnameRewriteEnabled, hostnameRewriteRegex, id, inheritanceSources, kerberosKdc, kerberosKeys, kerberosRekeyInterval, kerberosRetryInterval, kerberosTkeyLifetime, kerberosTkeyProtocol, loggingConfiguration, name, profileType, serverPrincipal, tags, updatedAt, vendorSpecificOptionOptionSpace);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IpamsvcServer {\n");
    sb.append("    clientPrincipal: ").append(toIndentedString(clientPrincipal)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    ddnsClientUpdate: ").append(toIndentedString(ddnsClientUpdate)).append("\n");
    sb.append("    ddnsConflictResolutionMode: ").append(toIndentedString(ddnsConflictResolutionMode)).append("\n");
    sb.append("    ddnsDomain: ").append(toIndentedString(ddnsDomain)).append("\n");
    sb.append("    ddnsEnabled: ").append(toIndentedString(ddnsEnabled)).append("\n");
    sb.append("    ddnsGenerateName: ").append(toIndentedString(ddnsGenerateName)).append("\n");
    sb.append("    ddnsGeneratedPrefix: ").append(toIndentedString(ddnsGeneratedPrefix)).append("\n");
    sb.append("    ddnsSendUpdates: ").append(toIndentedString(ddnsSendUpdates)).append("\n");
    sb.append("    ddnsTtlPercent: ").append(toIndentedString(ddnsTtlPercent)).append("\n");
    sb.append("    ddnsUpdateOnRenew: ").append(toIndentedString(ddnsUpdateOnRenew)).append("\n");
    sb.append("    ddnsUseConflictResolution: ").append(toIndentedString(ddnsUseConflictResolution)).append("\n");
    sb.append("    ddnsZones: ").append(toIndentedString(ddnsZones)).append("\n");
    sb.append("    dhcpConfig: ").append(toIndentedString(dhcpConfig)).append("\n");
    sb.append("    dhcpOptions: ").append(toIndentedString(dhcpOptions)).append("\n");
    sb.append("    dhcpOptionsV6: ").append(toIndentedString(dhcpOptionsV6)).append("\n");
    sb.append("    gssTsigFallback: ").append(toIndentedString(gssTsigFallback)).append("\n");
    sb.append("    headerOptionFilename: ").append(toIndentedString(headerOptionFilename)).append("\n");
    sb.append("    headerOptionServerAddress: ").append(toIndentedString(headerOptionServerAddress)).append("\n");
    sb.append("    headerOptionServerName: ").append(toIndentedString(headerOptionServerName)).append("\n");
    sb.append("    hostnameRewriteChar: ").append(toIndentedString(hostnameRewriteChar)).append("\n");
    sb.append("    hostnameRewriteEnabled: ").append(toIndentedString(hostnameRewriteEnabled)).append("\n");
    sb.append("    hostnameRewriteRegex: ").append(toIndentedString(hostnameRewriteRegex)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    inheritanceSources: ").append(toIndentedString(inheritanceSources)).append("\n");
    sb.append("    kerberosKdc: ").append(toIndentedString(kerberosKdc)).append("\n");
    sb.append("    kerberosKeys: ").append(toIndentedString(kerberosKeys)).append("\n");
    sb.append("    kerberosRekeyInterval: ").append(toIndentedString(kerberosRekeyInterval)).append("\n");
    sb.append("    kerberosRetryInterval: ").append(toIndentedString(kerberosRetryInterval)).append("\n");
    sb.append("    kerberosTkeyLifetime: ").append(toIndentedString(kerberosTkeyLifetime)).append("\n");
    sb.append("    kerberosTkeyProtocol: ").append(toIndentedString(kerberosTkeyProtocol)).append("\n");
    sb.append("    loggingConfiguration: ").append(toIndentedString(loggingConfiguration)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    profileType: ").append(toIndentedString(profileType)).append("\n");
    sb.append("    serverPrincipal: ").append(toIndentedString(serverPrincipal)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    vendorSpecificOptionOptionSpace: ").append(toIndentedString(vendorSpecificOptionOptionSpace)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("client_principal");
    openapiFields.add("comment");
    openapiFields.add("created_at");
    openapiFields.add("ddns_client_update");
    openapiFields.add("ddns_conflict_resolution_mode");
    openapiFields.add("ddns_domain");
    openapiFields.add("ddns_enabled");
    openapiFields.add("ddns_generate_name");
    openapiFields.add("ddns_generated_prefix");
    openapiFields.add("ddns_send_updates");
    openapiFields.add("ddns_ttl_percent");
    openapiFields.add("ddns_update_on_renew");
    openapiFields.add("ddns_use_conflict_resolution");
    openapiFields.add("ddns_zones");
    openapiFields.add("dhcp_config");
    openapiFields.add("dhcp_options");
    openapiFields.add("dhcp_options_v6");
    openapiFields.add("gss_tsig_fallback");
    openapiFields.add("header_option_filename");
    openapiFields.add("header_option_server_address");
    openapiFields.add("header_option_server_name");
    openapiFields.add("hostname_rewrite_char");
    openapiFields.add("hostname_rewrite_enabled");
    openapiFields.add("hostname_rewrite_regex");
    openapiFields.add("id");
    openapiFields.add("inheritance_sources");
    openapiFields.add("kerberos_kdc");
    openapiFields.add("kerberos_keys");
    openapiFields.add("kerberos_rekey_interval");
    openapiFields.add("kerberos_retry_interval");
    openapiFields.add("kerberos_tkey_lifetime");
    openapiFields.add("kerberos_tkey_protocol");
    openapiFields.add("logging_configuration");
    openapiFields.add("name");
    openapiFields.add("profile_type");
    openapiFields.add("server_principal");
    openapiFields.add("tags");
    openapiFields.add("updated_at");
    openapiFields.add("vendor_specific_option_option_space");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to IpamsvcServer
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IpamsvcServer.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IpamsvcServer is not found in the empty JSON string", IpamsvcServer.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IpamsvcServer.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IpamsvcServer` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : IpamsvcServer.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("client_principal") != null && !jsonObj.get("client_principal").isJsonNull()) && !jsonObj.get("client_principal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `client_principal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("client_principal").toString()));
      }
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if ((jsonObj.get("ddns_client_update") != null && !jsonObj.get("ddns_client_update").isJsonNull()) && !jsonObj.get("ddns_client_update").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_client_update` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_client_update").toString()));
      }
      if ((jsonObj.get("ddns_conflict_resolution_mode") != null && !jsonObj.get("ddns_conflict_resolution_mode").isJsonNull()) && !jsonObj.get("ddns_conflict_resolution_mode").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_conflict_resolution_mode` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_conflict_resolution_mode").toString()));
      }
      if ((jsonObj.get("ddns_domain") != null && !jsonObj.get("ddns_domain").isJsonNull()) && !jsonObj.get("ddns_domain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_domain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_domain").toString()));
      }
      if ((jsonObj.get("ddns_generated_prefix") != null && !jsonObj.get("ddns_generated_prefix").isJsonNull()) && !jsonObj.get("ddns_generated_prefix").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `ddns_generated_prefix` to be a primitive type in the JSON string but got `%s`", jsonObj.get("ddns_generated_prefix").toString()));
      }
      if (jsonObj.get("ddns_zones") != null && !jsonObj.get("ddns_zones").isJsonNull()) {
        JsonArray jsonArrayddnsZones = jsonObj.getAsJsonArray("ddns_zones");
        if (jsonArrayddnsZones != null) {
          // ensure the json data is an array
          if (!jsonObj.get("ddns_zones").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `ddns_zones` to be an array in the JSON string but got `%s`", jsonObj.get("ddns_zones").toString()));
          }

          // validate the optional field `ddns_zones` (array)
          for (int i = 0; i < jsonArrayddnsZones.size(); i++) {
            IpamsvcDDNSZone.validateJsonElement(jsonArrayddnsZones.get(i));
          };
        }
      }
      // validate the optional field `dhcp_config`
      if (jsonObj.get("dhcp_config") != null && !jsonObj.get("dhcp_config").isJsonNull()) {
        IpamsvcDHCPConfig.validateJsonElement(jsonObj.get("dhcp_config"));
      }
      if (jsonObj.get("dhcp_options") != null && !jsonObj.get("dhcp_options").isJsonNull()) {
        JsonArray jsonArraydhcpOptions = jsonObj.getAsJsonArray("dhcp_options");
        if (jsonArraydhcpOptions != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dhcp_options").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dhcp_options` to be an array in the JSON string but got `%s`", jsonObj.get("dhcp_options").toString()));
          }

          // validate the optional field `dhcp_options` (array)
          for (int i = 0; i < jsonArraydhcpOptions.size(); i++) {
            IpamsvcOptionItem.validateJsonElement(jsonArraydhcpOptions.get(i));
          };
        }
      }
      if (jsonObj.get("dhcp_options_v6") != null && !jsonObj.get("dhcp_options_v6").isJsonNull()) {
        JsonArray jsonArraydhcpOptionsV6 = jsonObj.getAsJsonArray("dhcp_options_v6");
        if (jsonArraydhcpOptionsV6 != null) {
          // ensure the json data is an array
          if (!jsonObj.get("dhcp_options_v6").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `dhcp_options_v6` to be an array in the JSON string but got `%s`", jsonObj.get("dhcp_options_v6").toString()));
          }

          // validate the optional field `dhcp_options_v6` (array)
          for (int i = 0; i < jsonArraydhcpOptionsV6.size(); i++) {
            IpamsvcOptionItem.validateJsonElement(jsonArraydhcpOptionsV6.get(i));
          };
        }
      }
      if ((jsonObj.get("header_option_filename") != null && !jsonObj.get("header_option_filename").isJsonNull()) && !jsonObj.get("header_option_filename").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_filename` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_filename").toString()));
      }
      if ((jsonObj.get("header_option_server_address") != null && !jsonObj.get("header_option_server_address").isJsonNull()) && !jsonObj.get("header_option_server_address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_address").toString()));
      }
      if ((jsonObj.get("header_option_server_name") != null && !jsonObj.get("header_option_server_name").isJsonNull()) && !jsonObj.get("header_option_server_name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `header_option_server_name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("header_option_server_name").toString()));
      }
      if ((jsonObj.get("hostname_rewrite_char") != null && !jsonObj.get("hostname_rewrite_char").isJsonNull()) && !jsonObj.get("hostname_rewrite_char").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname_rewrite_char` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname_rewrite_char").toString()));
      }
      if ((jsonObj.get("hostname_rewrite_regex") != null && !jsonObj.get("hostname_rewrite_regex").isJsonNull()) && !jsonObj.get("hostname_rewrite_regex").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hostname_rewrite_regex` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hostname_rewrite_regex").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `inheritance_sources`
      if (jsonObj.get("inheritance_sources") != null && !jsonObj.get("inheritance_sources").isJsonNull()) {
        IpamsvcServerInheritance.validateJsonElement(jsonObj.get("inheritance_sources"));
      }
      if ((jsonObj.get("kerberos_kdc") != null && !jsonObj.get("kerberos_kdc").isJsonNull()) && !jsonObj.get("kerberos_kdc").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kerberos_kdc` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kerberos_kdc").toString()));
      }
      if (jsonObj.get("kerberos_keys") != null && !jsonObj.get("kerberos_keys").isJsonNull()) {
        JsonArray jsonArraykerberosKeys = jsonObj.getAsJsonArray("kerberos_keys");
        if (jsonArraykerberosKeys != null) {
          // ensure the json data is an array
          if (!jsonObj.get("kerberos_keys").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `kerberos_keys` to be an array in the JSON string but got `%s`", jsonObj.get("kerberos_keys").toString()));
          }

          // validate the optional field `kerberos_keys` (array)
          for (int i = 0; i < jsonArraykerberosKeys.size(); i++) {
            IpamsvcKerberosKey.validateJsonElement(jsonArraykerberosKeys.get(i));
          };
        }
      }
      if ((jsonObj.get("kerberos_tkey_protocol") != null && !jsonObj.get("kerberos_tkey_protocol").isJsonNull()) && !jsonObj.get("kerberos_tkey_protocol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `kerberos_tkey_protocol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("kerberos_tkey_protocol").toString()));
      }
      // validate the optional field `logging_configuration`
      if (jsonObj.get("logging_configuration") != null && !jsonObj.get("logging_configuration").isJsonNull()) {
        IpamsvcLoggingConfig.validateJsonElement(jsonObj.get("logging_configuration"));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("profile_type") != null && !jsonObj.get("profile_type").isJsonNull()) && !jsonObj.get("profile_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `profile_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("profile_type").toString()));
      }
      if ((jsonObj.get("server_principal") != null && !jsonObj.get("server_principal").isJsonNull()) && !jsonObj.get("server_principal").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `server_principal` to be a primitive type in the JSON string but got `%s`", jsonObj.get("server_principal").toString()));
      }
      if ((jsonObj.get("vendor_specific_option_option_space") != null && !jsonObj.get("vendor_specific_option_option_space").isJsonNull()) && !jsonObj.get("vendor_specific_option_option_space").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `vendor_specific_option_option_space` to be a primitive type in the JSON string but got `%s`", jsonObj.get("vendor_specific_option_option_space").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IpamsvcServer.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IpamsvcServer' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IpamsvcServer> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IpamsvcServer.class));

       return (TypeAdapter<T>) new TypeAdapter<IpamsvcServer>() {
           @Override
           public void write(JsonWriter out, IpamsvcServer value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IpamsvcServer read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of IpamsvcServer given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of IpamsvcServer
   * @throws IOException if the JSON string is invalid with respect to IpamsvcServer
   */
  public static IpamsvcServer fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IpamsvcServer.class);
  }

  /**
   * Convert an instance of IpamsvcServer to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

